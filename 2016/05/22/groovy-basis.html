<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Groovy基础 | 飞雪无情的博客</title><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/pure-min.css"><link rel="stylesheet" type="text/css" href="/css/grids-responsive-min.css"><link rel="stylesheet" type="text/css" href="/css/style.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Groovy基础</h1><a id="logo" href="/.">飞雪无情的博客</a><p class="description">专注于Android、Java、移动互联网、项目管理、软件架构</p></div><div id="nav-menu"><a href="/." class="current"><i class="icon-home"> 首页</i></a><a href="/books/"><i class="icon-history"> 新书</i></a><a href="/archives/"><i class="icon-archive"> 归档</i></a><a href="/about/"><i class="icon-about"> 关于</i></a><a href="/atom.xml"><i class="icon-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post post-page"><h1 class="post-title">Groovy基础</h1><div class="post-meta">2016-05-22 | <span class="categories">分类于<a href="/categories/Android/"> Android</a><a href="/categories/Android/Gradle/"> Gradle</a></span></div><span data-thread-key="2016/05/22/groovy-basis.html" class="ds-thread-count"></span><div class="clear"><div id="toc" class="toc-article"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#字符串"><span class="toc-number">1.</span> <span class="toc-text">字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#集合"><span class="toc-number">2.</span> <span class="toc-text">集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#List"><span class="toc-number">2.1.</span> <span class="toc-text">List</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Map"><span class="toc-number">2.2.</span> <span class="toc-text">Map</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#方法"><span class="toc-number">3.</span> <span class="toc-text">方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#括号是可以省略的"><span class="toc-number">3.1.</span> <span class="toc-text">括号是可以省略的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#return是可以不写的"><span class="toc-number">3.2.</span> <span class="toc-text">return是可以不写的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码块是可以作为参数传递的"><span class="toc-number">3.3.</span> <span class="toc-text">代码块是可以作为参数传递的</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaBean"><span class="toc-number">4.</span> <span class="toc-text">JavaBean</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#闭包"><span class="toc-number">5.</span> <span class="toc-text">闭包</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#初识闭包"><span class="toc-number">5.1.</span> <span class="toc-text">初识闭包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#向闭包传递参数"><span class="toc-number">5.2.</span> <span class="toc-text">向闭包传递参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#闭包委托"><span class="toc-number">5.3.</span> <span class="toc-text">闭包委托</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DSL"><span class="toc-number">6.</span> <span class="toc-text">DSL</span></a></li></ol></div></div><div class="post-content"><p>以下内容节选自《Android Gradle权威指南》，更多关于《Android Gradle权威指南》的内容请参见<a href="http://yuedu.baidu.com/ebook/14a722970740be1e640e9a3e" target="_blank" rel="external">http://yuedu.baidu.com/ebook/14a722970740be1e640e9a3e</a></p>
<p>Groovy是基于JVM虚拟机的一种动态语言，它的语法和Java非常相似，由Java入门Groovy，基本上没有任何障碍。Groovy完全兼容Java，又在此基础上增加了很多动态类型和灵活的特性，比如支持闭包，支持DSL，可以说它是一门非常灵活的动态脚本语言。</p>
<p>Groovy的特性虽然不多，但也有一些，我们不可能在这里都讲完，这也不是这本书的初衷，在这里我挑一些和Gradle有关的知识讲，让大家很快的入门Groovy，并且能看懂这门脚本语言，知道在Gradle为什么这么写。其次是每个Gradle的build脚本文件都是一个Groovy脚本文件，你可以在里面写任何符合Groovy的代码，比如定义类，生命函数，定义变量等等，而Groovy又完全兼容Java，这就意味着你可以在build脚本文件里写任何的Java代码，非常灵活方便。</p>
<h2 id="字符串">字符串</h2><p>字符串，每一门语言都会有对字符串的处理，Java相对要稍微复杂一些，限制比较多，相比而言，Groovy非常方便，比如字符串的运算、求值、正则等等。</p>
<p>从现在开始我们算是正式的介绍Groovy了，在此之前我们先要知道，在Groovy中，分号不是必须的。相信很多用Java的朋友都习惯了，没一行的结束必须有分号，但是Groovy每这个强制规定，所以你看到的Gradle脚本很多都没有分号，其实这个是Groovy的特性，而不是Gradle的。没有分号的时候，我们阅读的时候没一行默认为有分号就好了。</p>
<p>在Groovy中，单引号和双引号都可以定义一个字符串常量（Java里单引号定义一个字符），不同的是单引号标记的是纯粹的字符串常量，而不是对字符串里的表达式做运算，但是双引号可以。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> printStringClass &lt;&lt; &#123;</span><br><span class="line">    defstr1 = <span class="string">'单引号'</span></span><br><span class="line">    defstr2 = <span class="string">"双引号"</span></span><br><span class="line">    <span class="keyword">println</span><span class="string">"单引号定义的字符串类型:"</span>+str1.getClass().name</span><br><span class="line">    <span class="keyword">println</span><span class="string">"双引号定义的字符串类型:"</span>+str2.getClass().name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>./gradlew printStringClass</strong>运行后我们能可以看到输出：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">单引号定义的字符串类型:java<span class="class">.lang</span><span class="class">.String</span></span><br><span class="line">双引号定义的字符串类型:java<span class="class">.lang</span><span class="class">.String</span></span><br></pre></td></tr></table></figure>
<p>不管是单引号定义的还是双引号定义的都是String类型。<br>刚刚我们讲了单引号不能对字符串里的表达式做运算，下面我们看个例子：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">task</span> printStringVar &lt;&lt; &#123;</span><br><span class="line">    <span class="title">defname</span> = <span class="string">"张三"</span></span><br><span class="line">    println<span class="string">'单引号的变量计算:<span class="variable">$&#123;name&#125;</span>'</span></span><br><span class="line">    println<span class="string">"单引号的变量计算:<span class="variable">$&#123;name&#125;</span>"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>./gradlew printStringVar运行后输出：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">单引号的变量计算:$&#123;<span class="property">name</span>&#125;</span><br><span class="line">单引号的变量计算:张三</span><br></pre></td></tr></table></figure>
<p>可以看到，双引号标记的输出了我们想要的结果，但是单引号没有，所以大家可以记住了，单引号没有运算的能力，它里面的所有都是常量字符串。</p>
<p>双引号可以直接进行表达式计算的这个能力非常好用，我们可以用这种方式进行字符串链接运算，再也不用Java中繁琐的+号了。记住这个嵌套的规则，一个美元符号紧跟着一对花括号，花括号里放表达式，比如${name},${1+1}等等，只有一个变量的时候可以省略花括号，比如$name。</p>
<h2 id="集合">集合</h2><p>集合，也是我们在Java中经常用到的，Groovy完全兼容了Java的集合，并且进行了扩展，使得生命一个集合，迭代一个集合、查找集合的元素等等操作变得非常容易。常见的集合有List、Set、Map和Queue，这里我们只介绍常用的List和Map。</p>
<h3 id="List">List</h3><p>在Java里，定义一个List，需要New一个实现了List接口的类，太繁琐，在Groovy中则非常简单。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> printList &lt;&lt; &#123;</span><br><span class="line">    <span class="keyword">def</span> numList =[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line">    <span class="keyword">println</span> numList.getClass().name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以通过输出看到numList是一个ArrayList类型。</p>
<p>定义好集合了，怎么访问它里面的元素呢，像Java一样，使用get方法？太Low了，Groovy提供了非常简便的方法。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> printList &lt;&lt; &#123;</span><br><span class="line">    <span class="keyword">def</span> numList =[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line">    <span class="keyword">println</span> numList.getClass().name</span><br><span class="line">    <span class="keyword">println</span> numList[<span class="number">1</span>]<span class="comment">//访问第二个元素</span></span><br><span class="line">    <span class="keyword">println</span> numList[-<span class="number">1</span>]<span class="comment">//访问最后一个元素</span></span><br><span class="line">    <span class="keyword">println</span> numList[-<span class="number">2</span>]<span class="comment">//访问倒数第二个元素</span></span><br><span class="line">    <span class="keyword">println</span> numList[<span class="number">1</span>..<span class="number">3</span>]<span class="comment">//访问第二个到第四个元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Groovy提供下标索引的方式访问，就像数组一样，除此之外，还提供了负下标和范围索引。负下标索引代表从右边开始数，-1就代表从右侧数第一个，-2代表右侧数第二个，以此类推；1..3这种是一个范围索引，中间用两个.分开，这个会经常遇到。</p>
<p>除了访问方便之外，Groovy还为List提供了非常方便的迭代操作，这就是each方法，该方法接受一个闭包作为参数，可以访问List里的每个元素。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> printList &lt;&lt; &#123;</span><br><span class="line">    <span class="keyword">def</span> numList =[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line">    <span class="keyword">println</span> numList.getClass().name</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">println</span> numList[<span class="number">1</span>]<span class="comment">//访问第二个元素</span></span><br><span class="line">    <span class="keyword">println</span> numList[-<span class="number">1</span>]<span class="comment">//访问最后一个元素</span></span><br><span class="line">    <span class="keyword">println</span> numList[-<span class="number">2</span>]<span class="comment">//访问倒数第二个元素</span></span><br><span class="line">    <span class="keyword">println</span> numList[<span class="number">1</span>..<span class="number">3</span>]<span class="comment">//f访问第二个到第四个元素</span></span><br><span class="line">    </span><br><span class="line">    numList.<span class="keyword">each</span> &#123;</span><br><span class="line">        <span class="keyword">println</span> it</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>it变量就是正在迭代的元素，这里有闭包的知识，我们可以先这么记住，后面详细讲。</p>
<h3 id="Map">Map</h3><p>Map和List很像，只不过它的值是一个K:V键值对，所以在Groovy中Map的定义也非常简单。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> printlnMap &lt;&lt; &#123;</span><br><span class="line">    <span class="keyword">def</span> map1 =[<span class="string">'width'</span>:<span class="number">1024</span>,<span class="string">'height'</span>:<span class="number">768</span>]</span><br><span class="line">    <span class="keyword">println</span> map1.getClass().name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>访问也非常灵活容易，采用map[key]或者map.key的方式都可以。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> printlnMap &lt;&lt; &#123;</span><br><span class="line">    <span class="keyword">def</span> map1 =[<span class="string">'width'</span>:<span class="number">1024</span>,<span class="string">'height'</span>:<span class="number">768</span>]</span><br><span class="line">    <span class="keyword">println</span> map1.getClass().name</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">println</span> map1[<span class="string">'width'</span>]</span><br><span class="line">    <span class="keyword">println</span> map1.height</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两种方式都能快速的取出指定key的值，怎么样，比Java方便的多吧。</p>
<p>对于Map的迭代，当然也少不了each方法，只不过被迭代的元素是一个Map.Entry的实例。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> printlnMap &lt;&lt; &#123;</span><br><span class="line">    <span class="keyword">def</span> map1 =[<span class="string">'width'</span>:<span class="number">1024</span>,<span class="string">'height'</span>:<span class="number">768</span>]</span><br><span class="line">    <span class="keyword">println</span> map1.getClass().name</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">println</span> map1[<span class="string">'width'</span>]</span><br><span class="line">    <span class="keyword">println</span> map1.height</span><br><span class="line">    </span><br><span class="line">    map1.<span class="keyword">each</span> &#123;</span><br><span class="line">        <span class="keyword">println</span> <span class="string">"Key:$&#123;it.key&#125;,Value:$&#123;it.value&#125;"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于集合，Groovy还提供了诸如collect、find、findAll等便捷的方法，有兴趣的朋友可以找相关文档看一下，这里就不一一讲了。</p>
<h2 id="方法">方法</h2><p>方法大家都不陌生，这里特别用一节讲的目的主要是讲Groovy方法和Java的不同，然后我们才能看明白我们的Gradle脚本里的代码，突然发现，原来这是一个方法调用啊！</p>
<h3 id="括号是可以省略的">括号是可以省略的</h3><p>我们在Java中调用一个方法都是invokeMethod(parm1,parm2)，非常规范，Java就是这么中规中矩的语言，在Groovy中就要灵活的多，可以省略()变成这样invokeMethod parm1，parm2  是不是觉得非常简洁，这在定义DSL的时候非常有用，书写也非常方便。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> invokeMethod &lt;&lt; &#123;</span><br><span class="line">    method1(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">    method1 <span class="number">1</span>,<span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">def</span> method1(<span class="keyword">int</span> a,<span class="keyword">int</span> b)&#123;</span><br><span class="line">    <span class="keyword">println</span> a+b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上例中这两种调用方式的结果是一样的，有没有觉得第二种更简洁的多，Gradle中的方法调用都是这种写法。</p>
<h3 id="return是可以不写的">return是可以不写的</h3><p>在Groovy中，我们定义有返回值的方法时，return语句不是必须的，当没有return的时候，Groovy会把方法执行过程中的最后一句代码作为其返回值。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> printMethodReturn &lt;&lt; &#123;</span><br><span class="line">    <span class="keyword">def</span> add1 = method2 <span class="number">1</span>,<span class="number">2</span></span><br><span class="line">    <span class="keyword">def</span> add2 = method2 <span class="number">5</span>,<span class="number">3</span></span><br><span class="line">    <span class="keyword">println</span> <span class="string">"add1:$&#123;add1&#125;,add2:$&#123;add2&#125;"</span></span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">def</span> method2(<span class="keyword">int</span> a,<span class="keyword">int</span> b)&#123;</span><br><span class="line">    <span class="keyword">if</span>(a&gt;b)&#123;</span><br><span class="line">        a</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        b</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行./gradlew printMethodReturn后可以看到输出：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">add1</span><span class="pseudo">:2</span>,<span class="tag">add2</span><span class="pseudo">:5</span></span><br></pre></td></tr></table></figure>
<p>从例子中可以看出，当a作为最后一行被执行的代码时，a就是该方法的返回值，反之则是b。</p>
<h3 id="代码块是可以作为参数传递的">代码块是可以作为参数传递的</h3><p>代码块—一段被花括号包围的代码，其实就是我们后面要将的闭包，Groovy是允许其作为参数传递的，但是结合这我们上面方法的特性，最后的基于闭包的方法调用就会非常优雅、易读。以我们的集合的each方法为例，它接受的参数其实就是一个闭包。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基于死板的写法其实是这样</span></span><br><span class="line">numList.<span class="keyword">each</span>(&#123;<span class="keyword">println</span> it&#125;)</span><br><span class="line"><span class="comment">//我们格式化一下，是不是好看一些</span></span><br><span class="line">numList.<span class="keyword">each</span>(&#123;</span><br><span class="line">    <span class="keyword">println</span> it</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//好看一些，Groovy规定，如果方法的最后一个参数是闭包，可以放到方法外面</span></span><br><span class="line">numList.<span class="keyword">each</span>()&#123;</span><br><span class="line">    <span class="keyword">println</span> it</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//然后方法可以省略，就变成我们经常看到的啦</span></span><br><span class="line">numList.<span class="keyword">each</span> &#123;</span><br><span class="line">    <span class="keyword">println</span> it</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>了解了这个演进方式，你再看到类似的这样的写法就明白了，原来是一个方法调用，以此类推，你也知道怎么定义一个方法，让别人这么调用。</p>
<h2 id="JavaBean">JavaBean</h2><p>JavaBean是一个非常好的概念，你现在看到的组件化、插件化、配置集成等都是基于JavaBean。在Java中为了访问和修改JavaBean的属性，我们不得不重复的生成getter/setter方法，并且使用他们，太麻烦，太繁琐，这在Groovy中得到很大的改善。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">task helloJavaBean &lt;&lt; &#123;</span><br><span class="line">    Person p = <span class="keyword">new</span> Person()</span><br><span class="line">   </span><br><span class="line">    println <span class="string">"名字是：<span class="subst">$&#123;p.name&#125;</span>"</span></span><br><span class="line">    p.name = <span class="string">"张三"</span></span><br><span class="line">    println <span class="string">"名字是：<span class="subst">$&#123;p.name&#125;</span>"</span></span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    private <span class="built_in">String</span> name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在没有给name属性赋值的时候，输出是null，赋值后，输出的就是“张三”了，通过上面例子，我们发现，我们在Groovy可以非常容易的访问和修改JavaBean的属性值，而不用借助getter/setter方法，这是因为Groovy都帮我们搞定了。</p>
<p>在Groovy中，并不是一定要定义成员变量，才能作为类的属性访问，我们直接getter/setter方法，也一样可以当做属性访问。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> helloJavaBean &lt;&lt; &#123;</span><br><span class="line">    Person p = <span class="keyword">new</span> Person()</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">println</span> <span class="string">"名字是：$&#123;p.name&#125;"</span></span><br><span class="line">    p.name = <span class="string">"张三"</span></span><br><span class="line">    <span class="keyword">println</span> <span class="string">"名字是：$&#123;p.name&#125;"</span></span><br><span class="line">    <span class="keyword">println</span> <span class="string">"年龄是：$&#123;p.age&#125;"</span></span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">    <span class="keyword">private</span> String name</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> getAge()&#123;</span><br><span class="line">        <span class="number">12</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上面的例子我们可以发现，我并没有定义一个age的成员变量，但是我一样可以通过p.age获取到该值，这是因为我们定义了getAge()方法。那么这时候我们能不能修改age的值呢？答案是不能的，因为我们没有为其定义setter方法。</p>
<p>在Gradle中你会见到很多这种写法，你开始以为这是该对象的一个属性，其实只是因为该对象里定义了相应的getter/setter方法而已。</p>
<h2 id="闭包">闭包</h2><p>闭包是Groovy的一个非常重要的特性，可以说他是DSL的基础。闭包不是Groovy的首创，但是它支持这一重要特性，这就使用我们的代码灵活、轻量、可复用，再也不用像Java一样动不动就要搞一个类了，虽然Java后来有了匿名内部类，但是一样冗余不灵活。</p>
<h3 id="初识闭包">初识闭包</h3><p>前面我们讲过，闭包其实就是一段代码块，下面我们就一步步实现自己的闭包，了解闭包的it变量的由来。集合的each方法我们已经非常熟悉了，我们就以其为例，实现一个类似的闭包功能。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> helloClosure &lt;&lt; &#123;</span><br><span class="line">    <span class="comment">//使用我们自定义的闭包</span></span><br><span class="line">    customEach &#123;</span><br><span class="line">        <span class="keyword">println</span> it</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">def</span> customEach(closure)&#123;</span><br><span class="line">    <span class="comment">//模拟一个有10个元素的集合，开始迭代</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i in <span class="number">1</span>..<span class="number">10</span>)&#123;</span><br><span class="line">        closure(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的例子中我们定义了一个方法customEach，它只有一个参数，用于接收一个闭包（代码块），那么这个闭包如何执行呢？很简单，跟一对括号就是执行了，会JavaScript的朋友是不是觉得很熟悉，把它当做一个方法调用，括号里的参数就是该闭包接收的参数，如果只有一个参数，那么就是我们的it变量了。</p>
<h3 id="向闭包传递参数">向闭包传递参数</h3><p>上一节我们讲了，当闭包有一个参数时，默认就是it；当有多个参数是，it就不能表示了，我们需要把参数一一列出。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> helloClosure &lt;&lt; &#123;</span><br><span class="line">    <span class="comment">//多个参数</span></span><br><span class="line">    eachMap &#123;k,v -&gt;</span><br><span class="line">        <span class="keyword">println</span> <span class="string">"$&#123;k&#125; is $&#123;v&#125;"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">def</span> eachMap(closure)&#123;</span><br><span class="line">    <span class="keyword">def</span> map1 = [<span class="string">"name"</span>:<span class="string">"张三"</span>,<span class="string">"age"</span>:<span class="number">18</span>]</span><br><span class="line">    map1.<span class="keyword">each</span> &#123;</span><br><span class="line">        closure(it.key,it.value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从例子中我们可以看到，我们为闭包传递了两个参数，一个key，一个value，便于我们演示。这是我们我们就不能使用it了，必须要显式的声明出来，如例子中的k，v，符号-&gt;用于把闭包的参数和主体区分开来。</p>
<h3 id="闭包委托">闭包委托</h3><p>Groovy闭包的强大之处在于它支持闭包方法的委托。Groovy的闭包有thisObject、owner、delegate三个属性，当你在闭包内调用方法时，由他们来确定使用哪个对象来处理。默认情况下delegate和owner是相等的，但是delegate是可以被修改的，这个功能是非常强大的，Gradle中的很闭包的很多功能都是通过修改delegate实现的。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> helloDelegate &lt;&lt; &#123;</span><br><span class="line">    <span class="keyword">new</span> Delegate().test &#123;</span><br><span class="line">        <span class="keyword">println</span> <span class="string">"thisObject:$&#123;thisObject.getClass()&#125;"</span></span><br><span class="line">        <span class="keyword">println</span> <span class="string">"owner:$&#123;owner.getClass()&#125;"</span></span><br><span class="line">        <span class="keyword">println</span> <span class="string">"delegate:$&#123;delegate.getClass()&#125;"</span></span><br><span class="line">        method1()</span><br><span class="line">        it.method1()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">def</span> method1()&#123;</span><br><span class="line">    <span class="keyword">println</span> <span class="string">"Context this:$&#123;this.getClass()&#125; in root"</span></span><br><span class="line">    <span class="keyword">println</span> <span class="string">"method1 in root"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> Delegate &#123;</span><br><span class="line">    <span class="keyword">def</span> method1()&#123;</span><br><span class="line">        <span class="keyword">println</span> <span class="string">"Delegate this:$&#123;this.getClass()&#125; in Delegate"</span></span><br><span class="line">        <span class="keyword">println</span> <span class="string">"method1 in Delegate"</span></span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">def</span> test(Closure&lt;Delegate&gt; closure)&#123;</span><br><span class="line">        closure(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行我们可以看到输出：</p>
<figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">thisObject:<span class="keyword"><span class="keyword">class</span> <span class="title">build_e27c427w88bo0afju9niqltzf</span></span></span><br><span class="line"><span class="literal">owner</span>:<span class="keyword"><span class="keyword">class</span> <span class="title">build_e27c427w88bo0afju9niqltzf</span>$<span class="title">_run_closure2</span></span></span><br><span class="line">delegate:<span class="keyword"><span class="keyword">class</span> <span class="title">build_e27c427w88bo0afju9niqltzf</span>$<span class="title">_run_closure2</span></span></span><br><span class="line">this:<span class="keyword"><span class="keyword">class</span> <span class="title">build_e27c427w88bo0afju9niqltzf</span> <span class="title">in</span> <span class="title">root</span></span></span><br><span class="line">method1 <span class="keyword">in</span> <span class="literal">root</span></span><br><span class="line">this:<span class="keyword"><span class="keyword">class</span> <span class="title">Delegate</span> <span class="title">in</span> <span class="title">Delegate</span></span></span><br><span class="line">method1 <span class="keyword">in</span> <span class="constant">Delegate</span></span><br></pre></td></tr></table></figure>
<p>通过上面的例子我们发现，thisObject的优先级最高，默认情况下，优先使用thisObject来处理闭包中调用的方法，如果有则执行。从输出中我们也可以看到这个thisObject其实就是这个构建脚本的上下文，他和脚本中的this对象是相等的。</p>
<p>从例子中也证明了delegate和owner是相等的，他们两个的优先级是owner要比delegate高，所以对于闭包内方法的处理顺序是thisObject&gt;owner&gt;delegate。</p>
<p>在DSL中，比如Gradle，我们一般会指定delegate为当前的it，这样我们在闭包内就可以对该it进行配置，或者调用其方法。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">task</span> configClosure &lt;&lt; &#123;</span><br><span class="line">    person &#123;</span><br><span class="line">        personName = <span class="string">"张三"</span></span><br><span class="line">        personAge = <span class="number">20</span></span><br><span class="line">        dumpPerson()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class">   </span><br><span class="line"><span class="keyword">class</span> <span class="type">Person</span> &#123;</span><br><span class="line">    <span class="type">String</span> personName</span><br><span class="line">    int personAge</span><br><span class="line">   </span><br><span class="line">    def dumpPerson<span class="container">()</span>&#123;</span><br><span class="line">        println "name is $&#123;personName&#125;,age is $&#123;personAge&#125;"</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line">def person<span class="container">(<span class="type">Closure</span>&lt;<span class="type">Person</span>&gt; <span class="title">closure</span>)</span>&#123;</span><br><span class="line">    <span class="type">Person</span> p = new <span class="type">Person</span><span class="container">()</span>;</span><br><span class="line">    closure.delegate = p</span><br><span class="line">    //委托模式优先</span><br><span class="line">    closure.setResolveStrategy<span class="container">(<span class="type">Closure</span>.<span class="type">DELEGATE_FIRST</span>)</span>;</span><br><span class="line">    closure<span class="container">(<span class="title">p</span>)</span></span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p>例子中我们设置了委托对象为当前创建的Person实例，并且设置了委托模式优先，所以我们在试用person方法创建一个Person的实例时，可以在闭包里直接对该Person实例配置，有没有发现和我们在Gradle试用task创建一个Task的用法很像，其实在Gradle中有很多类似的用法，在Gradle也基本上都是使用delegate的方式使用闭包进行配置等操作。</p>
<h2 id="DSL">DSL</h2><p> DSL(Domain Specific Language),领域特定语言，说白了就是专门关注某一领域专门语言，在于专，而不是全，所以才叫领域特定的，而不是像Java这种通用全面的语言。</p>
<p>Gradle就是一门DSL，他是基于Groovy的，专门解决自动化构建的DSL。自动化构建太复杂、太麻烦、太专业，我们理解不了，没问题，专家们就开发了DSL—Gradle，我们作为开发者只要按照Gradle DSL定义的，书写相应的Gradle脚本就可以达到我们自动化构建的目的，这也是DSL的初衷。</p>
<p>DSL涉及的东西还有很多，这里我们简单的提一下概念，让大家有个了解，关于这方便更详细的可以阅读世界级软件开发大师Martin Fowler的《领域特定语言》，这本书介绍的非常详细。</p>
<p>以上内容节选自《Android Gradle权威指南》，更多关于《Android Gradle权威指南》的内容请参见<a href="http://yuedu.baidu.com/ebook/14a722970740be1e640e9a3e" target="_blank" rel="external">http://yuedu.baidu.com/ebook/14a722970740be1e640e9a3e</a></p>
</div><div class="tags"><a href="/tags/Android/">Android</a><a href="/tags/Gradle/">Gradle</a></div><div class="post-nav"><a href="/2016/04/11/android-gradle-getting-started.html" class="next">Android Gradle 入门<i class="icon-next"></i></a></div><div data-thread-key="2016/05/22/groovy-basis.html" data-title="Groovy基础" data-url="http://www.flysnow.org/2016/05/22/groovy-basis.html" class="ds-share flat"><div class="ds-share-inline"><ul class="ds-share-icons-16"><li data-toggle="ds-share-icons-more"><a href="javascript:void(0);" class="ds-more">分享到：</a></li><li><a href="javascript:void(0);" data-service="weibo" class="ds-weibo">微博</a></li><li><a href="javascript:void(0);" data-service="qzone" class="ds-qzone">QQ空间</a></li><li><a href="javascript:void(0);" data-service="qqt" class="ds-qqt">腾讯微博</a></li><li><a href="javascript:void(0);" data-service="wechat" class="ds-wechat">微信</a></li></ul><div class="ds-share-icons-more"></div></div></div><div data-thread-key="2016/05/22/groovy-basis.html" data-title="Groovy基础" data-url="http://www.flysnow.org/2016/05/22/groovy-basis.html" data-author-key="1" class="ds-thread"></div></div></div></div><div class="pure-u-1-4"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search" class="search-form-input"/><input type="hidden" name="sitesearch" value="http://www.flysnow.org"/></form></div><div class="widget"><div class="widget-title">最新文章</div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/05/22/groovy-basis.html">Groovy基础</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/11/android-gradle-getting-started.html">Android Gradle 入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/08/13/android-tech-docs-support-annotations.html">Android注解支持(Support Annotations)</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/08/06/android-tech-docs-tools-attributes.html">Android技术文档翻译--工具属性(Tools Attributes)</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/08/03/android-tech-docs-ant-tasks.html">android技术文档翻译--ant任务</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/03/30/manage-your-android-project-with-gradle.html">使用Gradle管理你的Android Studio工程</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/03/19/android-process-application-init-databases-problem.html">Android多进程的数据库访问问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/03/10/github-page-with-hexo.html">使用Hexo在Github上搭建自己的博客</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/01/12/android-gradle-plugin-translate-done.html">Android Gradle插件中文指南</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/07/13/effective-programming-more-than-writing-code.html">高效能程序员的修炼</a></li></ul></div><div class="widget"><div class="comments-title">最近评论</div><div data-num-items="5" data-show-avatars="0" data-show-time="1" data-show-admin="0" data-excerpt-length="32" data-show-title="1" class="ds-recent-comments"></div></div><div class="widget"><div class="widget-title">分类</div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/Gradle/">Gradle</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android/Gradle/">Gradle</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Hexo/">Hexo</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/软件开发/">软件开发</a></li></ul></div><div class="widget"><div class="widget-title">标签</div><div class="tagcloud"><a href="/tags/Ubuntu/" style="font-size: 15px;">Ubuntu</a><a href="/tags/Android/" style="font-size: 15px;">Android</a><a href="/tags/Ant/" style="font-size: 15px;">Ant</a><a href="/tags/数据库/" style="font-size: 15px;">数据库</a><a href="/tags/Hexo/" style="font-size: 15px;">Hexo</a><a href="/tags/Github/" style="font-size: 15px;">Github</a><a href="/tags/翻译/" style="font-size: 15px;">翻译</a><a href="/tags/软件开发/" style="font-size: 15px;">软件开发</a><a href="/tags/Apache/" style="font-size: 15px;">Apache</a><a href="/tags/Linux/" style="font-size: 15px;">Linux</a><a href="/tags/Nginx/" style="font-size: 15px;">Nginx</a><a href="/tags/PHP/" style="font-size: 15px;">PHP</a><a href="/tags/Gradle/" style="font-size: 15px;">Gradle</a><a href="/tags/开源/" style="font-size: 15px;">开源</a><a href="/tags/Http/" style="font-size: 15px;">Http</a><a href="/tags/HttpClitent/" style="font-size: 15px;">HttpClitent</a><a href="/tags/API/" style="font-size: 15px;">API</a><a href="/tags/Widget/" style="font-size: 15px;">Widget</a><a href="/tags/goagent/" style="font-size: 15px;">goagent</a><a href="/tags/代理/" style="font-size: 15px;">代理</a><a href="/tags/翻墙/" style="font-size: 15px;">翻墙</a><a href="/tags/Email/" style="font-size: 15px;">Email</a><a href="/tags/敏捷/" style="font-size: 15px;">敏捷</a><a href="/tags/软件工程/" style="font-size: 15px;">软件工程</a><a href="/tags/Intent/" style="font-size: 15px;">Intent</a></div></div><div class="widget"><div class="widget-title">友情链接</div><ul></ul><a href="http://yuedu.baidu.com/ebook/14a722970740be1e640e9a3e" title="Android Gradle权威指南" target="_blank">Android Gradle权威指南</a></div></div></div></div><div id="footer">© <a href="/." rel="nofollow">飞雪无情的博客.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div><a id="rocket" href="#top" class="show"></a><script src="/js/jquery.min.js" type="text/javascript"></script>
<script src="/js/totop.js" type="text/javascript"></script><script src="/js/fancybox.pack.js" type="text/javascript"></script>
<script src="/js/jquery.fancybox.js" type="text/javascript"></script><link rel="stylesheet" href="/css/jquery.fancybox.css" type="text/css"><script>var duoshuoQuery = {short_name:'flysnow'};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0]
        || document.getElementsByTagName('body')[0]).appendChild(ds);
})();
</script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-44570956-1','auto');ga('send','pageview');
</script></div></body></html>