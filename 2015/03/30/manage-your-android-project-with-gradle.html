<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>使用Gradle管理你的Android Studio工程 | 飞雪无情的博客</title><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/pure-min.css"><link rel="stylesheet" type="text/css" href="/css/grids-responsive-min.css"><link rel="stylesheet" type="text/css" href="/css/style.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">使用Gradle管理你的Android Studio工程</h1><a id="logo" href="/.">飞雪无情的博客</a><p class="description">专注于Android、Java、移动互联网、项目管理、软件架构</p></div><div id="nav-menu"><a href="/." class="current"><i class="icon-home"> 首页</i></a><a href="/books/"><i class="icon-history"> 新书</i></a><a href="/archives/"><i class="icon-archive"> 归档</i></a><a href="/about/"><i class="icon-about"> 关于</i></a><a href="/atom.xml"><i class="icon-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post post-page"><h1 class="post-title">使用Gradle管理你的Android Studio工程</h1><div class="post-meta">2015-03-30 | <span class="categories">分类于<a href="/categories/Android/"> Android</a></span></div><span data-thread-key="2015/03/30/manage-your-android-project-with-gradle.html" class="ds-thread-count"></span><div class="post-content"><h1 id="Gradle简介">Gradle简介</h1><p><strong>Gradle</strong> 是一个基于Ant和Maven概念的项目自动化建构工具。它使用一种基于Groovy的特定领域语言(DSL)来声明项目设置，这比我们的ANT使用XML构建配置要灵活的多。在编写配置时，你可以像编程一样灵活，Gradle是基于Groovy的DSL语言，完全兼容JAVA</p>
<h1 id="Gradle入门">Gradle入门</h1><p>projects 和 tasks是Gradle中最重要的两个概念，任何一个Gradle构建都是由一个或者多个project组成，每个project可以是一个jar包，一个web应用，或者一个android app等，每个project又由多个task构成，一个task其实就是构建过程中一个原子性的操作，比如编译、拷贝等。</p>
<p>一个build.gradle文件是一个构建脚本，当运行gradle命令的时候会从当前目录查找build.gradle文件来执行构建。下面我们来看下gradle的Hello World。在build.gradle构建文件中输入以下构建脚本：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">task hello &#123;</span><br><span class="line">    doLast &#123;</span><br><span class="line">        println <span class="string">'Hello world!'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>task定义了一个任务，这个任务名字是hello。doLast是Task的方法，意思是在该hello任务执行之后作的事情，可以用一个闭包配置它,这里是输出Hello world!字符串。我们在终端里执行如下命令运行查看结果：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$gradle</span> hello -q</span><br><span class="line">Hello world!</span><br></pre></td></tr></table></figure></p>
<p>其他关于Gradle的更多介绍请参考<a href="https://gradle.org/docs/current/userguide/userguide" target="_blank" rel="external">Gradle使用指南</a></p>
<h1 id="Android_Studio入门">Android Studio入门</h1><p>使用Android Studio新建一个工程之后，其目录结构是这样的：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">├── app <span class="comment">#Android App目录</span></span><br><span class="line">│   ├── app.iml</span><br><span class="line">│   ├── build <span class="comment">#构建输出目录</span></span><br><span class="line">│   ├── build.gradle <span class="comment">#构建脚本</span></span><br><span class="line">│   ├── libs <span class="comment">#so相关库</span></span><br><span class="line">│   ├── proguard-rules.pro <span class="comment">#proguard混淆配置</span></span><br><span class="line">│   └── src <span class="comment">#源代码，资源等</span></span><br><span class="line">├── build</span><br><span class="line">│   └── intermediates</span><br><span class="line">├── build.gradle <span class="comment">#工程构建文件</span></span><br><span class="line">├── gradle</span><br><span class="line">│   └── wrapper</span><br><span class="line">├── gradle.properties <span class="comment">#gradle的配置</span></span><br><span class="line">├── gradlew <span class="comment">#gradle wrapper linux shell脚本</span></span><br><span class="line">├── gradlew.bat</span><br><span class="line">├── LibSqlite.iml</span><br><span class="line">├── local.properties <span class="comment">#配置Androod SDK位置文件</span></span><br><span class="line">└── settings.gradle <span class="comment">#工程配置</span></span><br></pre></td></tr></table></figure>
<p>settings.gradle用于配置project，标明其下有几个module，比如这里包含一个:app module</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include <span class="string">':app'</span></span><br></pre></td></tr></table></figure>
<p>和settings.gradle在同一目录下的build.gradle是一个顶级的build配置文件，在这里可以为所有project以及module配置一些常用的配置。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// Top-level build file <span class="built_in">where</span> you can add configuration options common to all sub-projects/modules.</span><br><span class="line"></span><br><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        jcenter()//使用jcenter库</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        // 依赖android提供的<span class="number">1.1</span>.<span class="number">0</span>的gradle build</span><br><span class="line">        classpath <span class="string">'com.android.tools.build:gradle:1.1.0'</span></span><br><span class="line"></span><br><span class="line">        // NOTE: Do not place your application dependencies here; they belong</span><br><span class="line">        // <span class="keyword">in</span> the individual module build.gradle files</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//为所有的工程的repositories配置为jcenters</span><br><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Android_Gradle基本配置">Android Gradle基本配置</h1><p>下面着重说一下Android的Gradle，毕竟对Android开发来说，这才是重中之重。这里以初始化好的build.gradle为例。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: <span class="string">'com.android.application'</span></span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">    compileSdkVersion <span class="number">21</span></span><br><span class="line">    buildToolsVersion <span class="string">"22.0.1"</span></span><br><span class="line"></span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        applicationId <span class="string">"org.flysnow.demo"</span></span><br><span class="line">        minSdkVersion <span class="number">9</span></span><br><span class="line">        targetSdkVersion <span class="number">21</span></span><br><span class="line">        versionCode <span class="number">1</span></span><br><span class="line">        versionName <span class="string">"1.0"</span></span><br><span class="line">    &#125;</span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            minifyEnabled <span class="literal">false</span></span><br><span class="line">            proguardFiles getDefaultProguardFile(<span class="string">'proguard-android.txt'</span>), <span class="string">'proguard-rules.pro'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile fileTree(dir: <span class="string">'libs'</span>, include: [<span class="string">'*.jar'</span>])</span><br><span class="line">    compile <span class="string">'com.android.support:appcompat-v7:22.0.0'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>开头第一行apply plugin: ‘com.android.application’，这表示该module是一个app module，应用了com.android.application插件，如果是一个android library，那么这里的是apply plugin: ‘com.android.library’。</p>
<p>其次是基于哪个SDK编译，这里是API LEVEL，是21，buildToolsVersion是基于哪个构建工具版本进行构建的。defaultConfig是默认配置，如果没有其他的配置覆盖，就会使用这里的。看其属性的名字就可以知道其作用，比如applicationId是配置包名的，versionCode是版本号，versionName是版本名称等。</p>
<p>buildTypes是构建类型，常用的有release和debug两种，可以在这里面启用混淆，启用zipAlign以及配置签名信息等。</p>
<p>dependencies就不属于Android专有的配置了，它定义了该module需要依赖的jar，aar，jcenter库信息。</p>
<h1 id="配置应用的签名信息">配置应用的签名信息</h1><p>在android.signingConfigs{}下定义一个或者多个签名信息，然后在buildTypes{}配置使用即可。比如这里</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line"></span><br><span class="line">    signingConfigs &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            storeFile file(<span class="string">"release.keystore"</span>)</span><br><span class="line">            keyAlias <span class="string">"release"</span></span><br><span class="line">            keyPassword <span class="string">"123456"</span></span><br><span class="line">            storePassword <span class="string">"123456"</span></span><br><span class="line">        &#125;</span><br><span class="line">        debug &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            signingConfig signingConfigs.release</span><br><span class="line">        &#125;</span><br><span class="line">        debug &#123;</span><br><span class="line">            signingConfig signingConfigs.debug</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>storeFile是签名证书文件，keyAlias是别名，keyPassword是key的密码，storePassword是证书的密码。配好好相关信息即可在buildTypes配置使用。</p>
<h1 id="启用proguard混淆">启用proguard混淆</h1><p>我们可以为不同的buildTypes选择是否启用混淆，一般release发布版本是需要启用混淆的，这样别人反编译之后就很难分析你的代码，而我们自己开发调试的时候是不需要混淆的，所以debug不启用混淆。对release启用混淆的配置如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line"></span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            minifyEnabled <span class="literal">true</span></span><br><span class="line">            proguardFile <span class="string">'proguard.cfg'</span></span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>minifyEnabled为true表示启用混淆，proguardFile是混淆使用的配置文件，这里是module根目录下的proguard.cfg文件</p>
<h1 id="启用zipAlign">启用zipAlign</h1><p>这个也是比较简单的，同样也是在buildTypes里配置，可以为不用的buildTypes选择时候开启zipAlign<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line"></span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            zipAlignEnabled <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="多渠道打包">多渠道打包</h1><p>东西到了国内就变了，做什么都是一窝蜂，比如Android App市场就是，所以才有了多渠道打包，每次发版几十个渠道包。还好Android Gradle给我们提供了productFlavors，让我们可以对生成的APK包进行定制，所以就有了多渠道。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">android  &#123;</span><br><span class="line">    productFlavors &#123;</span><br><span class="line">        dev&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        google&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        baidu&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样当我们运行assembleRelease的时候就会生成3个release包，分别是dev、google以及baidu的。目前看这三个包除了文件名没有什么不一样，因为我们还没有定制，使用的都是defaultConfig配置。这里的flavor和defaultConfig是一样的，可以自定义其applicationId、versionCode以及versionName等信息，比如区分不同包名：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">android  &#123;</span><br><span class="line">    productFlavors &#123;</span><br><span class="line">        dev&#123;</span><br><span class="line">            applicationId <span class="string">"org.flysnow.demo.dev"</span></span><br><span class="line">        &#125;</span><br><span class="line">        google&#123;</span><br><span class="line">            applicationId <span class="string">"org.flysnow.demo.google"</span></span><br><span class="line">        &#125;</span><br><span class="line">        baidu&#123;</span><br><span class="line">            applicationId <span class="string">"org.flysnow.demo.baidu"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="批量修改生成的apk文件名">批量修改生成的apk文件名</h1><p>在我们打包发版的时候，一次性打几十个包，这时候我们就想让生成的apk文件名有区分，比如一眼就能看出这个apk是哪个版本的，哪个渠道的，是哪天打的包等等，这就需要我们在生成apk文件的时候动态修改生成的apk文件名达到这一目的。这里以我们的产品随手记为例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">def <span class="function"><span class="title">buildTime</span></span>() &#123;</span><br><span class="line">    def date = new Date()</span><br><span class="line">    def formattedDate = date.format(<span class="string">'yyyyMMdd'</span>)</span><br><span class="line">    <span class="built_in">return</span> formattedDate</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            applicationVariants.all &#123; variant -&gt;</span><br><span class="line">                variant.outputs.each &#123; output -&gt;</span><br><span class="line">                    <span class="keyword">if</span> (output.outputFile != null &amp;&amp; output.outputFile.name.endsWith(<span class="string">'.apk'</span>)</span><br><span class="line">                        &amp;&amp;<span class="string">'release'</span>.equals(variant.buildType.name)) &#123;</span><br><span class="line">                        def apkFile = new File(</span><br><span class="line">                                output.outputFile.getParent(),</span><br><span class="line">                                <span class="string">"Mymoney_<span class="variable">$&#123;variant.flavorName&#125;</span>_v<span class="variable">$&#123;variant.versionName&#125;</span>_<span class="variable">$&#123;buildTime()&#125;</span>.apk"</span>)</span><br><span class="line">                        output.outputFile = apkFile</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以baidu渠道为例，以上的代码会生成一个名字为Mymoney_baidu_v9.5.2.6_20150330.apk安装包。下面我们分析一下，Android Gradle任务比较复杂，它的很多任务都是自动生成的，为了可以更灵活的控制，Android Gradle提供了applicationVariants、libraryVariants以及testVariants，他们分别适用于app、library、app和library都适用。</p>
<p>这里是循环处理每个applicationVariant，当他们的输出文件名以apk结尾并且buildType是release时，重新设置新的输出文件名，这样就达到了我们批量修改生成的文件名的目的。</p>
<h1 id="AndroidManifest里的占位符">AndroidManifest里的占位符</h1><p>AndroidManifest.xml这是一个很重要的文件，我们的很多配置都在这里定义。有时候我们的一些配置信息，比如一个第三方应用的key，第三方统计分析的渠道号等也要在这里进行配置。这里以友盟统计分析平台为例，演示这一功能的使用。在友盟统计分析中，我们需要根据渠道进行统计，比如google，百度，应用宝等渠道的活跃新增等，友盟的SDK是在AndroidManifest里配置一个name为UMENG_CHANNEL的meta-data，这样这个meta-data的值就表示这个apk是哪个渠道，我们版本发布有几十个渠道，以前ant打包的时候是采用文字替换的办法，现在Gradle有更好的处理办法，那就是manifestPlaceholders，它允许我们动态替换我们在AndroidManifest文件里定义的占位符。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">meta-data</span> <span class="attribute">android:value</span>=<span class="value">"$&#123;UMENG_CHANNEL_VALUE&#125;"</span> <span class="attribute">android:name</span>=<span class="value">"UMENG_CHANNEL"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>如上${UMENG_CHANNEL_VALUE}就是一个占位符，然后我们在gradle的defaultConfig；里这样定义脚本：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        manifestPlaceholders = [UMENG_CHANNEL_VALUE: <span class="string">'dev'</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以前的意思就是我们的默认配置里AndroidManifest的${UMENG_CHANNEL_VALUE}占位符会被dev这个字符串所替换，也就说默认运行的版本是一个开发板。以此类推，我们其他渠道的版本就可以这样定义：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">android  &#123;</span><br><span class="line">    productFlavors &#123;</span><br><span class="line">        google&#123;</span><br><span class="line">            applicationId <span class="string">"org.flysnow.demo.google"</span></span><br><span class="line">            manifestPlaceholders.put(<span class="string">"UMENG_CHANNEL_VALUE"</span>,<span class="string">'google'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        baidu&#123;</span><br><span class="line">            applicationId <span class="string">"org.flysnow.demo.baidu"</span></span><br><span class="line">            manifestPlaceholders.put(<span class="string">"UMENG_CHANNEL_VALUE"</span>,<span class="string">'baidu'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样有多少个渠道就做多少次这样的定义，即可完成分渠道统计。但是如果上百个渠道，这样一个个写的确太累，很麻烦，我们继续研究，同学们有没有发现，我们的渠道名字和我们的flavorName一样，我们用这个flavorName作为UMENG_CHANNEL_VALUE不就好了吗，可以批量的替换吗？当然可以，这又体现了我们Gradle的强大和灵活之处。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">productFlavors.all &#123; flavor -&gt;</span><br><span class="line">        manifestPlaceholders.put(<span class="string">"UMENG_CHANNEL_VALUE"</span>,name)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>循环每个flavor，并把他们的UMENG_CHANNEL_VALUE设置为他们自己的name名字，ok，搞定。</p>
<h1 id="自定义你的BuildConfig">自定义你的BuildConfig</h1><p>BuildConfig.java是Android Gradle自动生成的一个java类文件，无法手动编译，但是可以通过Gradle控制，也就是说他是动态可配置的，有了这个功能就很好玩了，这里以生产环境和测试环境为例来说明该功能的使用。</p>
<p>我们在开发App的时候免不了要和服务器进行通信，我们的服务器一般都有生产和测试环境，当我们处理开发和测试的时候使用测试环境进行调试，正式发布的时候使用生成环境。以前的时候我们通过把不同的配置文件打包进APK中来控制，现在不一样了，我们有更简便的方法，这就是buildConfigField。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        buildConfigField <span class="string">'String'</span>,<span class="string">'API_SERVER_URL'</span>,<span class="string">'"http://test.flysnow.org/"'</span></span><br><span class="line">    &#125;</span><br><span class="line">    productFlavors &#123;</span><br><span class="line">        google&#123;</span><br><span class="line">            buildConfigField <span class="string">'String'</span>,<span class="string">'API_SERVER_URL'</span>,<span class="string">'"http://www.flysnow.org/"'</span></span><br><span class="line">        &#125;</span><br><span class="line">        baidu&#123;</span><br><span class="line">            buildConfigField <span class="string">'String'</span>,<span class="string">'API_SERVER_URL'</span>,<span class="string">'"http://www.flysnow.org/"'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>buildConfigField 一共有3个参数，第一个是数据类型，就是你定义的常量值是一个什么类型，和Java的类型是对等的，这里是String。第二个参数是常量名，这里是API_SERVER_URL。第三个参数是常量值。如此定义之后，就会在BuildConfig.java中生成一个常量名为API_SERVER_URL的常量定义。默认配置的生成是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String API_SERVER_URL = <span class="string">"http://test.flysnow.org/"</span></span><br></pre></td></tr></table></figure>
<p>当是baidu和google渠道的时候生成的就是<code>http://www.flysnow.org/</code>了。这个常量可以在我们编码中引用。在我们进行打包的时候会根据Gradle配置动态替换。</p>
<p>我们发现一般渠道版本都是用来发布的，肯定用的是生产服务器，所以我们可以使用批处理来搞定这个事情，而不用在一个个渠道里写这些配置。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">productFlavors.all &#123; flavor -&gt;</span><br><span class="line">        buildConfigField <span class="string">'String'</span>,<span class="string">'API_SERVER_URL'</span>,<span class="string">'"http://www.flysnow.org/"'</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>此外，比如Gradle的resValue，也是和buildConfigField，只不过它控制生成的是资源，比如我们在android的values.xml定义生成的字符串。可以用它来动态生成我们想要的字符串，比如应用的名字，可能一些渠道会不一样，这样就可以很灵活的控制自动生成，关于resValue详细介绍请参考相关文档，这里不再举例说明。</p>
<h1 id="插装测试覆盖率代码">插装测试覆盖率代码</h1><p>代码覆盖率现在已经成为检验单元测试是否覆盖到的一种手段，Android Gradle提供了原生的用于单元测试的代码覆盖率，这个就是jacoco。今天我们不谈这个，我想要的是在我们生成的APK包中已经包含了检测代码覆盖率的代码，这样当我们安装APK后运行进行一些测试的时候，这些检测代码覆盖率的代码就会被执行到，这样最后我们导出一份代码测试覆盖率的文件，然后生成查看测试覆盖率报告看哪些覆盖到，哪些没有覆盖到。这种场景在检测测试工程师测试功能以及Android UI自动化测试是否完全覆盖尤为有效。这里代码覆盖率框架我选择的是emma，一来这个在Ant打包的时候一直在用，二来它具有很方便的插装功能。</p>
<p>emma插装的是class文件，所以我们只能在编译完java文件生成class文件后进行插装，这是我们进行覆盖率代码插装的最好时机。找到了时机，那么具体对应在Gradle脚本上是哪呢？还记不记得我们上面讲的applicationVariants，每一个applicationVariant都有一个javaCompile属性，javaCompile是一个JavaCompile类型的Task，这个就是负责编译java代码的。是Task就有doLast方法，就是在这个任务本身完成之后要做的事情，我们就是在这个方法里进行我们的代码覆盖率的安装。一般我们这个插装只是在特性情况下，那么我们新增一个特殊的flavor好了，专门做这个使用，这里我姑且叫feature。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">applicationVariants.all &#123; variant -&gt;</span><br><span class="line">    //为feature 版本加上代码覆盖率</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">'feature'</span>.equals(variant.flavorName))&#123;</span><br><span class="line">        variant.javaCompile.doLast &#123;</span><br><span class="line">            def coverageFile=file(<span class="string">'out/coverage.em'</span>)</span><br><span class="line">            <span class="keyword">if</span>(coverageFile.exists())&#123;</span><br><span class="line">                coverageFile.delete()</span><br><span class="line">            &#125;</span><br><span class="line">            javaexec &#123;</span><br><span class="line">                main <span class="string">'emma'</span></span><br><span class="line">                args <span class="string">'instr'</span>,<span class="string">'-ip'</span>,variant.javaCompile.destinationDir,<span class="string">'-m'</span>,<span class="string">'overwrite'</span>,<span class="string">'-out'</span>,<span class="string">'out/coverage.em'</span></span><br><span class="line">                classpath files(new File(getSdkDirectory(),<span class="string">'tools/lib/emma.jar'</span>))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>非常简单，我们使用javaexec命令执行java应用程序进程插装，插装模式使用的是overwrite，就是插装后覆盖源文件。getSdkDirectory()函数获取你电脑上的Android SDK目录，这里我们使用SDK自带的emma，保持每个人的统一。另外注意进行代码覆盖率插装的APK不能进行代码混淆，这个很简单，为feature flavor指定不混淆的proguardFile覆盖默认的proguardFile即可。最后该APK需要emma的框架代码，所以要配置feature flavor的特殊依赖信息。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compile fileTree(dir: <span class="string">'libs'</span>, include: <span class="string">'*.jar'</span>)</span><br><span class="line">    featureCompile files(new File(android.getSdkDirectory(),<span class="string">'tools/lib/emma_device.jar'</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="dexOptions_javaMaxHeapSize">dexOptions javaMaxHeapSize</h1><p>在Gradle 进行dex的可能会遇到内存不够用的情况，错误信息大概是java.lang.OutOfMemoryError: GC overhead limit exceeded。这个时候只需要配置dexOptions的javaMaxHeapSize大小即可，我这里配置4g：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dexOptions &#123;</span><br><span class="line">    javaMaxHeapSize <span class="string">"4g"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="结束语">结束语</h1><p>到这里Android Gradle在项目中的大概使用就着一些了，当然不用的项目可以定制的程度不一样，关于更详细和更深入的介绍可以参考我之前翻译的官方文档 <a href="https://github.com/rujews/android-tech-docs/blob/master/new-build-system/user-guide/README.md" target="_blank" rel="external">https://github.com/rujews/android-tech-docs/blob/master/new-build-system/user-guide/README.md</a> ，也可以在博客下方留言交流。</p>
</div><div class="tags"><a href="/tags/Android/">Android</a><a href="/tags/Gradle/">Gradle</a></div><div class="post-nav"><a href="/2015/08/03/android-tech-docs-ant-tasks.html" class="pre"><i class="icon-previous">android技术文档翻译--ant任务</i></a><a href="/2015/03/19/android-process-application-init-databases-problem.html" class="next">Android多进程的数据库访问问题<i class="icon-next"></i></a></div><div data-thread-key="2015/03/30/manage-your-android-project-with-gradle.html" data-title="使用Gradle管理你的Android Studio工程" data-url="http://www.flysnow.org/2015/03/30/manage-your-android-project-with-gradle.html" class="ds-share flat"><div class="ds-share-inline"><ul class="ds-share-icons-16"><li data-toggle="ds-share-icons-more"><a href="javascript:void(0);" class="ds-more">分享到：</a></li><li><a href="javascript:void(0);" data-service="weibo" class="ds-weibo">微博</a></li><li><a href="javascript:void(0);" data-service="qzone" class="ds-qzone">QQ空间</a></li><li><a href="javascript:void(0);" data-service="qqt" class="ds-qqt">腾讯微博</a></li><li><a href="javascript:void(0);" data-service="wechat" class="ds-wechat">微信</a></li></ul><div class="ds-share-icons-more"></div></div></div><div data-thread-key="2015/03/30/manage-your-android-project-with-gradle.html" data-title="使用Gradle管理你的Android Studio工程" data-url="http://www.flysnow.org/2015/03/30/manage-your-android-project-with-gradle.html" data-author-key="1" class="ds-thread"></div></div></div></div><div class="pure-u-1-4"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search" class="search-form-input"/><input type="hidden" name="sitesearch" value="http://www.flysnow.org"/></form></div><div class="widget"><div class="widget-title">最新文章</div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/05/22/groovy-basis.html">Groovy基础</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/11/android-gradle-getting-started.html">Android Gradle 入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/08/13/android-tech-docs-support-annotations.html">Android注解支持(Support Annotations)</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/08/06/android-tech-docs-tools-attributes.html">Android技术文档翻译--工具属性(Tools Attributes)</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/08/03/android-tech-docs-ant-tasks.html">android技术文档翻译--ant任务</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/03/30/manage-your-android-project-with-gradle.html">使用Gradle管理你的Android Studio工程</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/03/19/android-process-application-init-databases-problem.html">Android多进程的数据库访问问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/03/10/github-page-with-hexo.html">使用Hexo在Github上搭建自己的博客</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/01/12/android-gradle-plugin-translate-done.html">Android Gradle插件中文指南</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/07/13/effective-programming-more-than-writing-code.html">高效能程序员的修炼</a></li></ul></div><div class="widget"><div class="comments-title">最近评论</div><div data-num-items="5" data-show-avatars="0" data-show-time="1" data-show-admin="0" data-excerpt-length="32" data-show-title="1" class="ds-recent-comments"></div></div><div class="widget"><div class="widget-title">分类</div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/Gradle/">Gradle</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android/Gradle/">Gradle</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Hexo/">Hexo</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/软件开发/">软件开发</a></li></ul></div><div class="widget"><div class="widget-title">标签</div><div class="tagcloud"><a href="/tags/Ubuntu/" style="font-size: 15px;">Ubuntu</a><a href="/tags/Android/" style="font-size: 15px;">Android</a><a href="/tags/Ant/" style="font-size: 15px;">Ant</a><a href="/tags/数据库/" style="font-size: 15px;">数据库</a><a href="/tags/Hexo/" style="font-size: 15px;">Hexo</a><a href="/tags/Github/" style="font-size: 15px;">Github</a><a href="/tags/翻译/" style="font-size: 15px;">翻译</a><a href="/tags/软件开发/" style="font-size: 15px;">软件开发</a><a href="/tags/Apache/" style="font-size: 15px;">Apache</a><a href="/tags/Linux/" style="font-size: 15px;">Linux</a><a href="/tags/Nginx/" style="font-size: 15px;">Nginx</a><a href="/tags/PHP/" style="font-size: 15px;">PHP</a><a href="/tags/Gradle/" style="font-size: 15px;">Gradle</a><a href="/tags/开源/" style="font-size: 15px;">开源</a><a href="/tags/Http/" style="font-size: 15px;">Http</a><a href="/tags/HttpClitent/" style="font-size: 15px;">HttpClitent</a><a href="/tags/API/" style="font-size: 15px;">API</a><a href="/tags/Widget/" style="font-size: 15px;">Widget</a><a href="/tags/goagent/" style="font-size: 15px;">goagent</a><a href="/tags/代理/" style="font-size: 15px;">代理</a><a href="/tags/翻墙/" style="font-size: 15px;">翻墙</a><a href="/tags/Email/" style="font-size: 15px;">Email</a><a href="/tags/敏捷/" style="font-size: 15px;">敏捷</a><a href="/tags/软件工程/" style="font-size: 15px;">软件工程</a><a href="/tags/Intent/" style="font-size: 15px;">Intent</a></div></div><div class="widget"><div class="widget-title">友情链接</div><ul></ul><a href="http://yuedu.baidu.com/ebook/14a722970740be1e640e9a3e" title="Android Gradle权威指南" target="_blank">Android Gradle权威指南</a></div></div></div></div><div id="footer">© <a href="/." rel="nofollow">飞雪无情的博客.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div><a id="rocket" href="#top" class="show"></a><script src="/js/jquery.min.js" type="text/javascript"></script>
<script src="/js/totop.js" type="text/javascript"></script><script src="/js/fancybox.pack.js" type="text/javascript"></script>
<script src="/js/jquery.fancybox.js" type="text/javascript"></script><link rel="stylesheet" href="/css/jquery.fancybox.css" type="text/css"><script>var duoshuoQuery = {short_name:'flysnow'};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0]
        || document.getElementsByTagName('body')[0]).appendChild(ds);
})();
</script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-44570956-1','auto');ga('send','pageview');
</script></div></body></html>