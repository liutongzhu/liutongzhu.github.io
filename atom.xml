<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[飞雪无情的博客]]></title>
  <subtitle><![CDATA[专注于Android、Java、移动互联网、项目管理、软件架构]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://www.flysnow.org/"/>
  <updated>2016-05-22T10:34:46.653Z</updated>
  <id>http://www.flysnow.org/</id>
  
  <author>
    <name><![CDATA[飞雪无情]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Groovy基础]]></title>
    <link href="http://www.flysnow.org/2016/05/22/groovy-basis.html"/>
    <id>http://www.flysnow.org/2016/05/22/groovy-basis.html</id>
    <published>2016-05-22T10:17:50.000Z</published>
    <updated>2016-05-22T10:34:46.653Z</updated>
    <content type="html"><![CDATA[<p>以下内容节选自《Android Gradle权威指南》，更多关于《Android Gradle权威指南》的内容请参见<a href="http://yuedu.baidu.com/ebook/14a722970740be1e640e9a3e" target="_blank" rel="external">http://yuedu.baidu.com/ebook/14a722970740be1e640e9a3e</a></p>
<p>Groovy是基于JVM虚拟机的一种动态语言，它的语法和Java非常相似，由Java入门Groovy，基本上没有任何障碍。Groovy完全兼容Java，又在此基础上增加了很多动态类型和灵活的特性，比如支持闭包，支持DSL，可以说它是一门非常灵活的动态脚本语言。</p>
<p>Groovy的特性虽然不多，但也有一些，我们不可能在这里都讲完，这也不是这本书的初衷，在这里我挑一些和Gradle有关的知识讲，让大家很快的入门Groovy，并且能看懂这门脚本语言，知道在Gradle为什么这么写。其次是每个Gradle的build脚本文件都是一个Groovy脚本文件，你可以在里面写任何符合Groovy的代码，比如定义类，生命函数，定义变量等等，而Groovy又完全兼容Java，这就意味着你可以在build脚本文件里写任何的Java代码，非常灵活方便。</p>
<h2 id="字符串">字符串</h2><p>字符串，每一门语言都会有对字符串的处理，Java相对要稍微复杂一些，限制比较多，相比而言，Groovy非常方便，比如字符串的运算、求值、正则等等。</p>
<p>从现在开始我们算是正式的介绍Groovy了，在此之前我们先要知道，在Groovy中，分号不是必须的。相信很多用Java的朋友都习惯了，没一行的结束必须有分号，但是Groovy每这个强制规定，所以你看到的Gradle脚本很多都没有分号，其实这个是Groovy的特性，而不是Gradle的。没有分号的时候，我们阅读的时候没一行默认为有分号就好了。</p>
<p>在Groovy中，单引号和双引号都可以定义一个字符串常量（Java里单引号定义一个字符），不同的是单引号标记的是纯粹的字符串常量，而不是对字符串里的表达式做运算，但是双引号可以。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> printStringClass &lt;&lt; &#123;</span><br><span class="line">    defstr1 = <span class="string">'单引号'</span></span><br><span class="line">    defstr2 = <span class="string">"双引号"</span></span><br><span class="line">    <span class="keyword">println</span><span class="string">"单引号定义的字符串类型:"</span>+str1.getClass().name</span><br><span class="line">    <span class="keyword">println</span><span class="string">"双引号定义的字符串类型:"</span>+str2.getClass().name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>./gradlew printStringClass</strong>运行后我们能可以看到输出：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">单引号定义的字符串类型:java<span class="class">.lang</span><span class="class">.String</span></span><br><span class="line">双引号定义的字符串类型:java<span class="class">.lang</span><span class="class">.String</span></span><br></pre></td></tr></table></figure>
<p>不管是单引号定义的还是双引号定义的都是String类型。<br>刚刚我们讲了单引号不能对字符串里的表达式做运算，下面我们看个例子：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">task</span> printStringVar &lt;&lt; &#123;</span><br><span class="line">    <span class="title">defname</span> = <span class="string">"张三"</span></span><br><span class="line">    println<span class="string">'单引号的变量计算:<span class="variable">$&#123;name&#125;</span>'</span></span><br><span class="line">    println<span class="string">"单引号的变量计算:<span class="variable">$&#123;name&#125;</span>"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>./gradlew printStringVar运行后输出：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">单引号的变量计算:$&#123;<span class="property">name</span>&#125;</span><br><span class="line">单引号的变量计算:张三</span><br></pre></td></tr></table></figure>
<p>可以看到，双引号标记的输出了我们想要的结果，但是单引号没有，所以大家可以记住了，单引号没有运算的能力，它里面的所有都是常量字符串。</p>
<p>双引号可以直接进行表达式计算的这个能力非常好用，我们可以用这种方式进行字符串链接运算，再也不用Java中繁琐的+号了。记住这个嵌套的规则，一个美元符号紧跟着一对花括号，花括号里放表达式，比如${name},${1+1}等等，只有一个变量的时候可以省略花括号，比如$name。</p>
<h2 id="集合">集合</h2><p>集合，也是我们在Java中经常用到的，Groovy完全兼容了Java的集合，并且进行了扩展，使得生命一个集合，迭代一个集合、查找集合的元素等等操作变得非常容易。常见的集合有List、Set、Map和Queue，这里我们只介绍常用的List和Map。</p>
<h3 id="List">List</h3><p>在Java里，定义一个List，需要New一个实现了List接口的类，太繁琐，在Groovy中则非常简单。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> printList &lt;&lt; &#123;</span><br><span class="line">    <span class="keyword">def</span> numList =[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line">    <span class="keyword">println</span> numList.getClass().name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以通过输出看到numList是一个ArrayList类型。</p>
<p>定义好集合了，怎么访问它里面的元素呢，像Java一样，使用get方法？太Low了，Groovy提供了非常简便的方法。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> printList &lt;&lt; &#123;</span><br><span class="line">    <span class="keyword">def</span> numList =[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line">    <span class="keyword">println</span> numList.getClass().name</span><br><span class="line">    <span class="keyword">println</span> numList[<span class="number">1</span>]<span class="comment">//访问第二个元素</span></span><br><span class="line">    <span class="keyword">println</span> numList[-<span class="number">1</span>]<span class="comment">//访问最后一个元素</span></span><br><span class="line">    <span class="keyword">println</span> numList[-<span class="number">2</span>]<span class="comment">//访问倒数第二个元素</span></span><br><span class="line">    <span class="keyword">println</span> numList[<span class="number">1</span>..<span class="number">3</span>]<span class="comment">//访问第二个到第四个元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Groovy提供下标索引的方式访问，就像数组一样，除此之外，还提供了负下标和范围索引。负下标索引代表从右边开始数，-1就代表从右侧数第一个，-2代表右侧数第二个，以此类推；1..3这种是一个范围索引，中间用两个.分开，这个会经常遇到。</p>
<p>除了访问方便之外，Groovy还为List提供了非常方便的迭代操作，这就是each方法，该方法接受一个闭包作为参数，可以访问List里的每个元素。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> printList &lt;&lt; &#123;</span><br><span class="line">    <span class="keyword">def</span> numList =[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line">    <span class="keyword">println</span> numList.getClass().name</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">println</span> numList[<span class="number">1</span>]<span class="comment">//访问第二个元素</span></span><br><span class="line">    <span class="keyword">println</span> numList[-<span class="number">1</span>]<span class="comment">//访问最后一个元素</span></span><br><span class="line">    <span class="keyword">println</span> numList[-<span class="number">2</span>]<span class="comment">//访问倒数第二个元素</span></span><br><span class="line">    <span class="keyword">println</span> numList[<span class="number">1</span>..<span class="number">3</span>]<span class="comment">//f访问第二个到第四个元素</span></span><br><span class="line">    </span><br><span class="line">    numList.<span class="keyword">each</span> &#123;</span><br><span class="line">        <span class="keyword">println</span> it</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>it变量就是正在迭代的元素，这里有闭包的知识，我们可以先这么记住，后面详细讲。</p>
<h3 id="Map">Map</h3><p>Map和List很像，只不过它的值是一个K:V键值对，所以在Groovy中Map的定义也非常简单。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> printlnMap &lt;&lt; &#123;</span><br><span class="line">    <span class="keyword">def</span> map1 =[<span class="string">'width'</span>:<span class="number">1024</span>,<span class="string">'height'</span>:<span class="number">768</span>]</span><br><span class="line">    <span class="keyword">println</span> map1.getClass().name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>访问也非常灵活容易，采用map[key]或者map.key的方式都可以。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> printlnMap &lt;&lt; &#123;</span><br><span class="line">    <span class="keyword">def</span> map1 =[<span class="string">'width'</span>:<span class="number">1024</span>,<span class="string">'height'</span>:<span class="number">768</span>]</span><br><span class="line">    <span class="keyword">println</span> map1.getClass().name</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">println</span> map1[<span class="string">'width'</span>]</span><br><span class="line">    <span class="keyword">println</span> map1.height</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两种方式都能快速的取出指定key的值，怎么样，比Java方便的多吧。</p>
<p>对于Map的迭代，当然也少不了each方法，只不过被迭代的元素是一个Map.Entry的实例。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> printlnMap &lt;&lt; &#123;</span><br><span class="line">    <span class="keyword">def</span> map1 =[<span class="string">'width'</span>:<span class="number">1024</span>,<span class="string">'height'</span>:<span class="number">768</span>]</span><br><span class="line">    <span class="keyword">println</span> map1.getClass().name</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">println</span> map1[<span class="string">'width'</span>]</span><br><span class="line">    <span class="keyword">println</span> map1.height</span><br><span class="line">    </span><br><span class="line">    map1.<span class="keyword">each</span> &#123;</span><br><span class="line">        <span class="keyword">println</span> <span class="string">"Key:$&#123;it.key&#125;,Value:$&#123;it.value&#125;"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于集合，Groovy还提供了诸如collect、find、findAll等便捷的方法，有兴趣的朋友可以找相关文档看一下，这里就不一一讲了。</p>
<h2 id="方法">方法</h2><p>方法大家都不陌生，这里特别用一节讲的目的主要是讲Groovy方法和Java的不同，然后我们才能看明白我们的Gradle脚本里的代码，突然发现，原来这是一个方法调用啊！</p>
<h3 id="括号是可以省略的">括号是可以省略的</h3><p>我们在Java中调用一个方法都是invokeMethod(parm1,parm2)，非常规范，Java就是这么中规中矩的语言，在Groovy中就要灵活的多，可以省略()变成这样invokeMethod parm1，parm2  是不是觉得非常简洁，这在定义DSL的时候非常有用，书写也非常方便。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> invokeMethod &lt;&lt; &#123;</span><br><span class="line">    method1(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">    method1 <span class="number">1</span>,<span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">def</span> method1(<span class="keyword">int</span> a,<span class="keyword">int</span> b)&#123;</span><br><span class="line">    <span class="keyword">println</span> a+b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上例中这两种调用方式的结果是一样的，有没有觉得第二种更简洁的多，Gradle中的方法调用都是这种写法。</p>
<h3 id="return是可以不写的">return是可以不写的</h3><p>在Groovy中，我们定义有返回值的方法时，return语句不是必须的，当没有return的时候，Groovy会把方法执行过程中的最后一句代码作为其返回值。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> printMethodReturn &lt;&lt; &#123;</span><br><span class="line">    <span class="keyword">def</span> add1 = method2 <span class="number">1</span>,<span class="number">2</span></span><br><span class="line">    <span class="keyword">def</span> add2 = method2 <span class="number">5</span>,<span class="number">3</span></span><br><span class="line">    <span class="keyword">println</span> <span class="string">"add1:$&#123;add1&#125;,add2:$&#123;add2&#125;"</span></span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">def</span> method2(<span class="keyword">int</span> a,<span class="keyword">int</span> b)&#123;</span><br><span class="line">    <span class="keyword">if</span>(a&gt;b)&#123;</span><br><span class="line">        a</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        b</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行./gradlew printMethodReturn后可以看到输出：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">add1</span><span class="pseudo">:2</span>,<span class="tag">add2</span><span class="pseudo">:5</span></span><br></pre></td></tr></table></figure>
<p>从例子中可以看出，当a作为最后一行被执行的代码时，a就是该方法的返回值，反之则是b。</p>
<h3 id="代码块是可以作为参数传递的">代码块是可以作为参数传递的</h3><p>代码块—一段被花括号包围的代码，其实就是我们后面要将的闭包，Groovy是允许其作为参数传递的，但是结合这我们上面方法的特性，最后的基于闭包的方法调用就会非常优雅、易读。以我们的集合的each方法为例，它接受的参数其实就是一个闭包。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基于死板的写法其实是这样</span></span><br><span class="line">numList.<span class="keyword">each</span>(&#123;<span class="keyword">println</span> it&#125;)</span><br><span class="line"><span class="comment">//我们格式化一下，是不是好看一些</span></span><br><span class="line">numList.<span class="keyword">each</span>(&#123;</span><br><span class="line">    <span class="keyword">println</span> it</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//好看一些，Groovy规定，如果方法的最后一个参数是闭包，可以放到方法外面</span></span><br><span class="line">numList.<span class="keyword">each</span>()&#123;</span><br><span class="line">    <span class="keyword">println</span> it</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//然后方法可以省略，就变成我们经常看到的啦</span></span><br><span class="line">numList.<span class="keyword">each</span> &#123;</span><br><span class="line">    <span class="keyword">println</span> it</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>了解了这个演进方式，你再看到类似的这样的写法就明白了，原来是一个方法调用，以此类推，你也知道怎么定义一个方法，让别人这么调用。</p>
<h2 id="JavaBean">JavaBean</h2><p>JavaBean是一个非常好的概念，你现在看到的组件化、插件化、配置集成等都是基于JavaBean。在Java中为了访问和修改JavaBean的属性，我们不得不重复的生成getter/setter方法，并且使用他们，太麻烦，太繁琐，这在Groovy中得到很大的改善。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">task helloJavaBean &lt;&lt; &#123;</span><br><span class="line">    Person p = <span class="keyword">new</span> Person()</span><br><span class="line">   </span><br><span class="line">    println <span class="string">"名字是：<span class="subst">$&#123;p.name&#125;</span>"</span></span><br><span class="line">    p.name = <span class="string">"张三"</span></span><br><span class="line">    println <span class="string">"名字是：<span class="subst">$&#123;p.name&#125;</span>"</span></span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    private <span class="built_in">String</span> name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在没有给name属性赋值的时候，输出是null，赋值后，输出的就是“张三”了，通过上面例子，我们发现，我们在Groovy可以非常容易的访问和修改JavaBean的属性值，而不用借助getter/setter方法，这是因为Groovy都帮我们搞定了。</p>
<p>在Groovy中，并不是一定要定义成员变量，才能作为类的属性访问，我们直接getter/setter方法，也一样可以当做属性访问。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> helloJavaBean &lt;&lt; &#123;</span><br><span class="line">    Person p = <span class="keyword">new</span> Person()</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">println</span> <span class="string">"名字是：$&#123;p.name&#125;"</span></span><br><span class="line">    p.name = <span class="string">"张三"</span></span><br><span class="line">    <span class="keyword">println</span> <span class="string">"名字是：$&#123;p.name&#125;"</span></span><br><span class="line">    <span class="keyword">println</span> <span class="string">"年龄是：$&#123;p.age&#125;"</span></span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">    <span class="keyword">private</span> String name</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> getAge()&#123;</span><br><span class="line">        <span class="number">12</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上面的例子我们可以发现，我并没有定义一个age的成员变量，但是我一样可以通过p.age获取到该值，这是因为我们定义了getAge()方法。那么这时候我们能不能修改age的值呢？答案是不能的，因为我们没有为其定义setter方法。</p>
<p>在Gradle中你会见到很多这种写法，你开始以为这是该对象的一个属性，其实只是因为该对象里定义了相应的getter/setter方法而已。</p>
<h2 id="闭包">闭包</h2><p>闭包是Groovy的一个非常重要的特性，可以说他是DSL的基础。闭包不是Groovy的首创，但是它支持这一重要特性，这就使用我们的代码灵活、轻量、可复用，再也不用像Java一样动不动就要搞一个类了，虽然Java后来有了匿名内部类，但是一样冗余不灵活。</p>
<h3 id="初识闭包">初识闭包</h3><p>前面我们讲过，闭包其实就是一段代码块，下面我们就一步步实现自己的闭包，了解闭包的it变量的由来。集合的each方法我们已经非常熟悉了，我们就以其为例，实现一个类似的闭包功能。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> helloClosure &lt;&lt; &#123;</span><br><span class="line">    <span class="comment">//使用我们自定义的闭包</span></span><br><span class="line">    customEach &#123;</span><br><span class="line">        <span class="keyword">println</span> it</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">def</span> customEach(closure)&#123;</span><br><span class="line">    <span class="comment">//模拟一个有10个元素的集合，开始迭代</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i in <span class="number">1</span>..<span class="number">10</span>)&#123;</span><br><span class="line">        closure(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的例子中我们定义了一个方法customEach，它只有一个参数，用于接收一个闭包（代码块），那么这个闭包如何执行呢？很简单，跟一对括号就是执行了，会JavaScript的朋友是不是觉得很熟悉，把它当做一个方法调用，括号里的参数就是该闭包接收的参数，如果只有一个参数，那么就是我们的it变量了。</p>
<h3 id="向闭包传递参数">向闭包传递参数</h3><p>上一节我们讲了，当闭包有一个参数时，默认就是it；当有多个参数是，it就不能表示了，我们需要把参数一一列出。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> helloClosure &lt;&lt; &#123;</span><br><span class="line">    <span class="comment">//多个参数</span></span><br><span class="line">    eachMap &#123;k,v -&gt;</span><br><span class="line">        <span class="keyword">println</span> <span class="string">"$&#123;k&#125; is $&#123;v&#125;"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">def</span> eachMap(closure)&#123;</span><br><span class="line">    <span class="keyword">def</span> map1 = [<span class="string">"name"</span>:<span class="string">"张三"</span>,<span class="string">"age"</span>:<span class="number">18</span>]</span><br><span class="line">    map1.<span class="keyword">each</span> &#123;</span><br><span class="line">        closure(it.key,it.value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从例子中我们可以看到，我们为闭包传递了两个参数，一个key，一个value，便于我们演示。这是我们我们就不能使用it了，必须要显式的声明出来，如例子中的k，v，符号-&gt;用于把闭包的参数和主体区分开来。</p>
<h3 id="闭包委托">闭包委托</h3><p>Groovy闭包的强大之处在于它支持闭包方法的委托。Groovy的闭包有thisObject、owner、delegate三个属性，当你在闭包内调用方法时，由他们来确定使用哪个对象来处理。默认情况下delegate和owner是相等的，但是delegate是可以被修改的，这个功能是非常强大的，Gradle中的很闭包的很多功能都是通过修改delegate实现的。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> helloDelegate &lt;&lt; &#123;</span><br><span class="line">    <span class="keyword">new</span> Delegate().test &#123;</span><br><span class="line">        <span class="keyword">println</span> <span class="string">"thisObject:$&#123;thisObject.getClass()&#125;"</span></span><br><span class="line">        <span class="keyword">println</span> <span class="string">"owner:$&#123;owner.getClass()&#125;"</span></span><br><span class="line">        <span class="keyword">println</span> <span class="string">"delegate:$&#123;delegate.getClass()&#125;"</span></span><br><span class="line">        method1()</span><br><span class="line">        it.method1()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">def</span> method1()&#123;</span><br><span class="line">    <span class="keyword">println</span> <span class="string">"Context this:$&#123;this.getClass()&#125; in root"</span></span><br><span class="line">    <span class="keyword">println</span> <span class="string">"method1 in root"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> Delegate &#123;</span><br><span class="line">    <span class="keyword">def</span> method1()&#123;</span><br><span class="line">        <span class="keyword">println</span> <span class="string">"Delegate this:$&#123;this.getClass()&#125; in Delegate"</span></span><br><span class="line">        <span class="keyword">println</span> <span class="string">"method1 in Delegate"</span></span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">def</span> test(Closure&lt;Delegate&gt; closure)&#123;</span><br><span class="line">        closure(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行我们可以看到输出：</p>
<figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">thisObject:<span class="keyword"><span class="keyword">class</span> <span class="title">build_e27c427w88bo0afju9niqltzf</span></span></span><br><span class="line"><span class="literal">owner</span>:<span class="keyword"><span class="keyword">class</span> <span class="title">build_e27c427w88bo0afju9niqltzf</span>$<span class="title">_run_closure2</span></span></span><br><span class="line">delegate:<span class="keyword"><span class="keyword">class</span> <span class="title">build_e27c427w88bo0afju9niqltzf</span>$<span class="title">_run_closure2</span></span></span><br><span class="line">this:<span class="keyword"><span class="keyword">class</span> <span class="title">build_e27c427w88bo0afju9niqltzf</span> <span class="title">in</span> <span class="title">root</span></span></span><br><span class="line">method1 <span class="keyword">in</span> <span class="literal">root</span></span><br><span class="line">this:<span class="keyword"><span class="keyword">class</span> <span class="title">Delegate</span> <span class="title">in</span> <span class="title">Delegate</span></span></span><br><span class="line">method1 <span class="keyword">in</span> <span class="constant">Delegate</span></span><br></pre></td></tr></table></figure>
<p>通过上面的例子我们发现，thisObject的优先级最高，默认情况下，优先使用thisObject来处理闭包中调用的方法，如果有则执行。从输出中我们也可以看到这个thisObject其实就是这个构建脚本的上下文，他和脚本中的this对象是相等的。</p>
<p>从例子中也证明了delegate和owner是相等的，他们两个的优先级是owner要比delegate高，所以对于闭包内方法的处理顺序是thisObject&gt;owner&gt;delegate。</p>
<p>在DSL中，比如Gradle，我们一般会指定delegate为当前的it，这样我们在闭包内就可以对该it进行配置，或者调用其方法。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">task</span> configClosure &lt;&lt; &#123;</span><br><span class="line">    person &#123;</span><br><span class="line">        personName = <span class="string">"张三"</span></span><br><span class="line">        personAge = <span class="number">20</span></span><br><span class="line">        dumpPerson()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class">   </span><br><span class="line"><span class="keyword">class</span> <span class="type">Person</span> &#123;</span><br><span class="line">    <span class="type">String</span> personName</span><br><span class="line">    int personAge</span><br><span class="line">   </span><br><span class="line">    def dumpPerson<span class="container">()</span>&#123;</span><br><span class="line">        println "name is $&#123;personName&#125;,age is $&#123;personAge&#125;"</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line">def person<span class="container">(<span class="type">Closure</span>&lt;<span class="type">Person</span>&gt; <span class="title">closure</span>)</span>&#123;</span><br><span class="line">    <span class="type">Person</span> p = new <span class="type">Person</span><span class="container">()</span>;</span><br><span class="line">    closure.delegate = p</span><br><span class="line">    //委托模式优先</span><br><span class="line">    closure.setResolveStrategy<span class="container">(<span class="type">Closure</span>.<span class="type">DELEGATE_FIRST</span>)</span>;</span><br><span class="line">    closure<span class="container">(<span class="title">p</span>)</span></span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p>例子中我们设置了委托对象为当前创建的Person实例，并且设置了委托模式优先，所以我们在试用person方法创建一个Person的实例时，可以在闭包里直接对该Person实例配置，有没有发现和我们在Gradle试用task创建一个Task的用法很像，其实在Gradle中有很多类似的用法，在Gradle也基本上都是使用delegate的方式使用闭包进行配置等操作。</p>
<h2 id="DSL">DSL</h2><p> DSL(Domain Specific Language),领域特定语言，说白了就是专门关注某一领域专门语言，在于专，而不是全，所以才叫领域特定的，而不是像Java这种通用全面的语言。</p>
<p>Gradle就是一门DSL，他是基于Groovy的，专门解决自动化构建的DSL。自动化构建太复杂、太麻烦、太专业，我们理解不了，没问题，专家们就开发了DSL—Gradle，我们作为开发者只要按照Gradle DSL定义的，书写相应的Gradle脚本就可以达到我们自动化构建的目的，这也是DSL的初衷。</p>
<p>DSL涉及的东西还有很多，这里我们简单的提一下概念，让大家有个了解，关于这方便更详细的可以阅读世界级软件开发大师Martin Fowler的《领域特定语言》，这本书介绍的非常详细。</p>
<p>以上内容节选自《Android Gradle权威指南》，更多关于《Android Gradle权威指南》的内容请参见<a href="http://yuedu.baidu.com/ebook/14a722970740be1e640e9a3e" target="_blank" rel="external">http://yuedu.baidu.com/ebook/14a722970740be1e640e9a3e</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>以下内容节选自《Android Gradle权威指南》，更多关于《Android Gradle权威指南》的内容请参见<a href="http://yuedu.baidu.com/ebook/14a722970740be1e640e9a3e" target="_blank"]]>
    </summary>
    
      <category term="Android" scheme="http://www.flysnow.org/tags/Android/"/>
    
      <category term="Gradle" scheme="http://www.flysnow.org/tags/Gradle/"/>
    
      <category term="Android" scheme="http://www.flysnow.org/categories/Android/"/>
    
      <category term="Gradle" scheme="http://www.flysnow.org/categories/Android/Gradle/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android Gradle 入门]]></title>
    <link href="http://www.flysnow.org/2016/04/11/android-gradle-getting-started.html"/>
    <id>http://www.flysnow.org/2016/04/11/android-gradle-getting-started.html</id>
    <published>2016-04-11T13:49:50.000Z</published>
    <updated>2016-05-22T10:35:10.144Z</updated>
    <content type="html"><![CDATA[<p> Gradle是一款非常优秀的构建系统工具,它的DSL基于Groovy实现,可以让你很方便的通过代码控制这些DSL来达到你构建的目的，其构建的大部分功能都是通过插件的方式来实现，所以非常灵活方便，如果内置插件不能满足你的需求你可以自定义自己的插件。</p>
<p>本章我们就介绍Gradle的入门，在介绍之前，我们先假定读者已经具备以下前提：</p>
<ol>
<li>了解并且会使用Java，精通最好</li>
<li>会自己的独立的搭建Java开发环境</li>
<li>最好会使用Linux操作系统，比如Ubuntu</li>
</ol>
<p>为什么会有这样的假定呢，因为这本书是介绍Android Gradle开发构建的书，所以不会花章节去讲Java的基本知识，能希望读者会用Linux操作系统的原因，是因为作者该书的所有脚本、代码、IDE等都是基于Ubuntu完成的，当然比如涉及到Gradle安装还会介绍一下Window的安装步骤，但是不会太多涉及到Window的东西，这个关于本书一章里有提到，所以呢，还是希望读者们在阅读本书前已经掌握了这些知识，Linux操作系统非必须，因为涉及到的都是Linux很基本的东西，大家很容易就看得懂。</p>
<h3 id="配置Gradle环境">配置Gradle环境</h3><p>安装之前确保已经安装配置好Java环境，要求JDK 6以上，并且在环境变量里配置了JAVA_HOME,查看java版本可以在终端输入如下命令：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure></p>
<p>我这里使用的是open jdk 1.7.0_79。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flysnow@flysnow:~$ java -version&#10;java version &#34;1.7.0_79&#34;&#10;OpenJDK Runtime Environment (IcedTea 2.5.6) (7u79-2.5.6-0ubuntu1.15.04.1)&#10;OpenJDK 64-Bit Server VM (build 24.79-b02, mixed mode)</span><br></pre></td></tr></table></figure></p>
<h4 id="Linux下搭建Gradle构建环境">Linux下搭建Gradle构建环境</h4><p>这里以Ubuntu 15.04发行版为例介绍如何在Linux搭建Gradle构建环境，其他注入CentOS大同小异，参考下就可以了。</p>
<p>我们这里以Gradle 2.5版本为准进行介绍，先到Gradle官网 <a href="http://gradle.org/下载好Gradle" target="_blank" rel="external">http://gradle.org/下载好Gradle</a> SDK，直接下载地址为 <a href="https://downloads.gradle.org/distributions/gradle-2.5-all.zip，我们下载的是all版本，也就是说，里面包含了Gradle" target="_blank" rel="external">https://downloads.gradle.org/distributions/gradle-2.5-all.zip，我们下载的是all版本，也就是说，里面包含了Gradle</a> SDK所有相关的内容，包括源代码、文档、示例等。下载之后进行解压，我们可以得到如何目录清单：</p>
<ol>
<li>docs——API、DSL、指南等文档</li>
<li>getting-started.html——入门链接</li>
<li>init.d——gradle的初始化脚本目录</li>
<li>lib——相关库</li>
<li>LICENSE</li>
<li>media——一些icon资源</li>
<li>NOTICE</li>
<li>samples——示例</li>
<li>src——源文件</li>
</ol>
<p>要运行Gradle，必须把GRADLE_HOME/bin目录添加到你的环境变量PATH的路径里才可以。在Linux下，如果你只想为你当前登陆的用户配置可以运行Gradle，那么可以编辑～/.bashrc文件添加以下内容：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#&#36825;&#37324;&#26159;&#20316;&#32773;&#30340;Gradle&#30446;&#24405;&#12290;&#35201;&#25442;&#25104;&#20320;&#33258;&#24049;&#30340;&#10;GRADLE_HOME=/home/flysnow/frame/gradle&#10;          &#10;PATH=$&#123;PATH&#125;:$&#123;GRADLE_HOME&#125;/bin&#10;exportGRADLE_HOME PATH</span><br></pre></td></tr></table></figure></p>
<p>上面GRADLE_HOME是我的Gradle解压后的目录，这里要换成你自己的。以上添加后保存，然后在终端输入source ~/.bashrc回车执行让刚刚的配置生效。</p>
<p>如果你想让所有用户都可以使用gradle，那么你就需要在/etc/profile中添加以上内容，在这里添加后，对所有用户都生效，这种方式的添加，必须要重启电脑才可以。</p>
<p>好了，现在我们已经配置好了，要进行验证我们的配置是否正确，是否可以运行gradle，我们只需要打开终端，输入gradle -v命令查看即可，如果能正确显示gradle版本号、Groovy版本号、JVM等相关信息，那么说明你已经配置成功了，这里以我的为例：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gradle -v&#10;          &#10;------------------------------------------------------------&#10;Gradle 2.5&#10;------------------------------------------------------------&#10;           &#10;Build time:   2015-07-08 07:38:37 UTC&#10;Build number: none&#10;Revision:     093765bccd3ee722ed5310583e5ed140688a8c2b&#10;           &#10;Groovy:       2.3.10&#10;Ant:          Apache Ant(TM) version 1.9.3 compiled on December 23 2013&#10;JVM:          1.7.0_79 (Oracle Corporation 24.79-b02)&#10;OS:           Linux 3.19.0-28-generic amd64</span><br></pre></td></tr></table></figure></p>
<h4 id="Window下搭建Gradle构建环境">Window下搭建Gradle构建环境</h4><p>Window下搭建Gradle环境和Linux非常相似，只不过方式不同。我们通过右击我的电脑，打开属性面板，然后找到环境变量配置项，添加GRADLE_HOME环境变量，然后把GRADLE_HOME\bin添加到PATH系统变量里保存即可。完成后打开CMD运行gradle -v来进行验证，整体和Linux差不多，这里就不在一一详述。</p>
<h3 id="Gradle版Hello_World">Gradle版Hello World</h3><p>环境搭建好了，那么我们就开始写一个Hello World版的Gradle脚本吧。</p>
<p>新建好一个目录，我这里是android-gradle-book-code，然后在该目录下创建一个名为build.gradle的文件，打开编辑该文件，输入以下内容：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">task hello&#123;</span><br><span class="line">    doLast&#123;</span><br><span class="line">        println<span class="string">'Hello World!'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>打开终端，然后移动到android-gradle-book-code下，使用gradle -q hello命令来执行构建脚本：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gradle -q hello&#10;Hello World!</span><br></pre></td></tr></table></figure></p>
<p>好了，如愿以偿的打印出来我们想要的结果，下面我们一步步分析结果产生的步骤和原因。build.gradle是Gradle默认的构建脚本文件，执行Gradle命令的时候，会默认加载当前目录下的build.gradle脚本文件，熟悉Ant的同学感觉和build.xml差不多，当然你也可以通过 -b 参数指定想要加载执行的文件。</p>
<p>这个构建脚本定义一个任务（Task），任务名字叫hello，并且给任务hello添加了一个动作，官方名字是Action，阅读Gradle源代码你会到处见到它，其实他就是一段Groovy语言实现的闭包，在这里我觉得叫业务代码逻辑或者回调实现更贴切一些，因为doLast就意味着在Task执行完毕之后要回调doLast的这部分闭包的代码实现。</p>
<p>熟悉Ant的读者，会觉得任务(Task)和Ant里的Target(目标)非常相似，其实没错，现在可以认为他们基本上相同。</p>
<p>再看gradle -q hello这段运行命令，意思是要执行build.gradle脚本中定义的名为hello的Task，-q参数用于控制gradle输出的日志级别，哪些日志可以输出被看到。</p>
<p>看到println ‘Hello World!’了吗，他会输出Hello World!，通过名字相信大家已经猜出来了，它其实就是System.out.println(“Hello World!”)的简写方式。Gradle可以识别它，是因为Groovy已经把println()这个方法添加到iava.lang.Object，而在Groovy中，方法的调用可以省略签名中的括号，以一个空格分开即可，所以就有了上面的写法。还有一点要说明的就是在Groovy中，单引号和双引号所包含的内容都是字符串，不像Java中，单引号是字符，双引号才是字符串。</p>
<h3 id="Gradle_Wrapper">Gradle Wrapper</h3><p>Wrapper，顾名思义，其实就是对Gradle的一层包装，便于在团队开发过程中统一Gradle构建的版本，这样大家都可以使用统一的Gradle版本进行构建，避免因为Gradle版本不统一带来的不必要的问题。</p>
<p>在这里特别介绍的目的是因为我们在项目开发过程中，用的都是wrapper这种方式，而不是我们在1.1里介绍的自己下载ZIP压缩包，配置Gradle的环境的方式。Wrapper在Window下是一个批处理脚本，在Linux下是一个shell脚本，当你使用wrapper启动Gradle的时候，wrapper会检查gradle有没有被下载关联，如果没有将会从配置的地址（一般是Gradle官方库）进行下载并运行构建。这对我们每个开发人员是非常方便的，因为你不用去专门的配置环境了，只要执行wrapper命令，它会帮你搞定一切，这样方式也方便我们在服务器上做持续集成(CI)，因为我们不用在服务器上配置Gradle环境。</p>
<h4 id="生成wrapper">生成wrapper</h4><p>Gradle提供了内置的wrapper task帮助我们自动生成wrapper所需的目录文件，在一个项目的根目录，输入gradle wrapper即可生成。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gradle wrapper&#10;:wrapper&#10;        &#10;BUILD SUCCESSFUL&#10;        &#10;Total time: 2.804 secs&#10;        &#10;This build could be faster, please consider using the Gradle Daemon: http://gradle.org/docs/2.5/userguide/gradle_daemon.html</span><br></pre></td></tr></table></figure></p>
<p>生成的文件如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#9500;&#9472;&#9472; gradle&#10;&#9474;   &#9492;&#9472;&#9472; wrapper&#10;&#9474;       &#9500;&#9472;&#9472; gradle-wrapper.jar&#10;&#9474;       &#9492;&#9472;&#9472; gradle-wrapper.properties&#10;&#9500;&#9472;&#9472; gradlew&#10;&#9492;&#9472;&#9472; gradlew.bat</span><br></pre></td></tr></table></figure></p>
<p>gradlew和gradlew.bat分别是Linux和Window下的可执行脚本，他们的用法和gradle原生命令是一样的，gradle怎么用，他们也就可以怎么用。gradle-wrapper.jar是具体业务逻辑实现的jar包，gradlew最终还是使用java执行的这个jar包来执行相关gradle操作。gradle-wrapper.properties是配置文件，用于配置使用哪个版本的gradle等，稍后会详细讲解。</p>
<p>这些生成的wrapper文件可以作为你项目工程的一部分提交到代码版本控制系统里(git)，这样其他开发人员就会使用这里配置好的统一的gradle进行构建开发。</p>
<h4 id="wrapper配置">wrapper配置</h4><p>当我们在终端执行gradle wrapper生成相关文件的时候，可以为其指定一些参数，来控制wrapper的生成，比如依赖的版本等。</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>—gradle-version</td>
<td>用于指定使用的gradle版本</td>
</tr>
<tr>
<td>—gradle-distribution-url</td>
<td>用于指定下载gradle发行版的url地址</td>
</tr>
</tbody>
</table>
<p>使用方法如gradle wrapper —gradle-version 2.4这样，这样就意味着我们配置wrapper使用2.4版本的gradle，它会影响gradle-wrapper.properties中的distributionUrl的值，该值的规则是http\://services.gradle.org/distributions/gradle-${gradleVersion}-bin.zip</p>
<p>如果我们在调用gradle wrapper的时候不添加任何参数呢，那么就会使用你当前Gradle的版本作为生成的wrapper的gradle version。例如你当前安装的gradle是2.5版本的，那么生成的wrapper也是2.5版本的。</p>
<h4 id="gradle-wrapper-properties">gradle-wrapper.properties</h4><p>该配置文件是gradle wrapper的相关配置文件，我们上面执行该任务的任何配置都会被写进该文件中，现在我们来看看该文件的配置字段：</p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>distributionBase</td>
<td>下载的gradle压缩包解压后存储的主目录</td>
</tr>
<tr>
<td>distributionPath</td>
<td>相对于distributionBase的解压后的gradle压缩包的路径</td>
</tr>
<tr>
<td>zipStoreBase</td>
<td>同distributionBase，只不过是存放zip压缩包的</td>
</tr>
<tr>
<td>zipStorePath</td>
<td>同distributionPath，只不过是存放zip压缩包的</td>
</tr>
<tr>
<td>distributionUrl</td>
<td>gradle发行版压缩包的下载地址</td>
</tr>
</tbody>
</table>
<p>我们比较关注的就是distributionUrl这个字段了，这个决定你的gradle wrapper依赖哪个gradle版本，一般生成的都是这样的https\://services.gradle.org/distributions/gradle-2.5-bin.zip，我通常都会把bin改为all，这样在开发过程中，就可以看到gradle的源代码了。</p>
<p>基于Gradle 2.5默认生成的gradle-wrapper.properties如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#Wed Sep 16 23:14:52 CST 2015&#10;distributionBase=GRADLE_USER_HOME&#10;distributionPath=wrapper/dists&#10;zipStoreBase=GRADLE_USER_HOME&#10;zipStorePath=wrapper/dists&#10;distributionUrl=https\://services.gradle.org/distributions/gradle-2.5-bin.zip</span><br></pre></td></tr></table></figure></p>
<p>distributionUrl是下载gradle的路径，如果运行./gradlew的时候一直卡着不动，可能是因为官方的gradle地址被墙了，建议使用翻墙工具试试，或者把该地址换成别的镜像地址。</p>
<h4 id="自定义Wrapper_Task">自定义Wrapper Task</h4><p>前面我们讲了，gradle-wrapper.properties是由wrapper task生成的，那么我们是否可以自定义配置该Wrapper task来达到我们配置gradle-wrapper.properties的目的呢，答案是肯定的。我们在我们的build.gradle构建文件中录入如下脚本：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">task wrapper(<span class="string">type:</span> Wrapper) &#123;</span><br><span class="line">    gradleVersion = <span class="string">'2.4'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样我们再执行gradle wrapper的时候，就会默认生成2.4版本的wrapper了，而不用使用—gradle-version 2.4进行指定了。同样你也可以配置其他参数：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">task wrapper(<span class="string">type:</span> Wrapper) &#123;</span><br><span class="line">    gradleVersion = <span class="string">'2.4'</span></span><br><span class="line">    archiveBase = <span class="string">'GRADLE_USER_HOME'</span></span><br><span class="line">    archivePath = <span class="string">'wrapper/dists'</span></span><br><span class="line">    distributionBase = <span class="string">'GRADLE_USER_HOME'</span></span><br><span class="line">    distributionPath = <span class="string">'wrapper/dists'</span></span><br><span class="line">    distributionUrl = <span class="string">'http\://services.gradle.org/distributions/gradle-2.4-all.zip'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以上是我自己配置的一些值，也可以修改生你自己的。</p>
<h3 id="Gradle日志">Gradle日志</h3><p>在这里介绍单独介绍Gradle日志的目的是为了便于我们在遇到问题的时候，能够根据日志信息分析和解决问题。Gradle的日志和我们自己Java、Android差不多，也分一些级别，用于分类显示日志信息，这样我们只需根据不同的情况显示不同类别的信息，不至于被大量的日志搞的晕头转向。</p>
<h4 id="日志级别">日志级别</h4><p>上面提了Gradle的日志级别和大部分我们使用的语言的差不多，除了这些通用的之外，Gradle又增加了QUIET和LIFECYCLE两个级别，用于标记重要以及进度级别的日志信息。</p>
<table>
<thead>
<tr>
<th>级别</th>
<th>用于</th>
</tr>
</thead>
<tbody>
<tr>
<td>ERROR</td>
<td>错误消息</td>
</tr>
<tr>
<td>QUIET</td>
<td>重要消息</td>
</tr>
<tr>
<td>WARNING</td>
<td>警告消息</td>
</tr>
<tr>
<td>LIFECYCLE</td>
<td>进度消息</td>
</tr>
<tr>
<td>INFO</td>
<td>信息消息</td>
</tr>
<tr>
<td>DEBUG</td>
<td>调试信息</td>
</tr>
</tbody>
</table>
<p>上面的表列明确的列出了6种日志级别以及他们的作用，那么现在我们就看下怎么样使用他们。要使用他们，显示我们想要显示级别的日志，就要通过命令行选项中的日志开关来控制。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#&#36755;&#20986;QUIET&#32423;&#21035;&#21450;&#20854;&#20043;&#19978;&#30340;&#26085;&#24535;&#20449;&#24687;&#10;$ gradle -q tasks&#10;#&#36755;&#20986;INFO&#32423;&#21035;&#21450;&#20854;&#20043;&#19978;&#30340;&#26085;&#24535;&#20449;&#24687;&#10;$ gradle -i tasks</span><br></pre></td></tr></table></figure></p>
<p>以下列出所有通过命令行开关选项可以控制的级别级别，在命令行里只需加上这些选项即可控制使用。</p>
<table>
<thead>
<tr>
<th>开关选项</th>
<th>输出的日志级别</th>
</tr>
</thead>
<tbody>
<tr>
<td>无选项</td>
<td>LIFECYCLE及其更高级别</td>
</tr>
<tr>
<td>-q或者 —quiet</td>
<td>QUIET及其更高级别</td>
</tr>
<tr>
<td>-i 或者 —info</td>
<td>INFO及其更高级别</td>
</tr>
<tr>
<td>-d or —debug</td>
<td>DEBUG及其更高级别，这一般会输出所有日志</td>
</tr>
</tbody>
</table>
<h4 id="输出错误堆栈信息">输出错误堆栈信息</h4><p>在使用Gradle构建的时候，难免会有这样或者那样的问题导致你的构建失败，这时就需要你根据日志分析解决问题。除了以上的日志信息之外，Gradle还提供了堆栈信息的打印，用过Java语言的相信大家都会很熟悉错误堆栈信息，他能帮助我们很好的定位和分析问题。</p>
<p>默认情况下，堆栈信息的输出是关闭的，需要我们通过命令行的堆栈信息开关打开它，这样在我们构建失败的时候，Gradle才会输出错误堆栈信息，便于我们定位分析和解决问题。</p>
<table>
<thead>
<tr>
<th>命令行选项</th>
<th>用于</th>
</tr>
</thead>
<tbody>
<tr>
<td>无选项</td>
<td>没有堆栈信息输出</td>
</tr>
<tr>
<td>-s 或者 —stacktrace</td>
<td>输出关键性的堆栈信息</td>
</tr>
<tr>
<td>-S 或者—full-stacktrace</td>
<td>输出全部堆栈信息</td>
</tr>
</tbody>
</table>
<p>一般推荐使用-s而不是-S，因为-S输出的堆栈太多太长，非常不好看，而-s反而比较精简，可以定位解决我们大部分的问题。</p>
<h4 id="自己使用日志信息调试">自己使用日志信息调试</h4><p>在编写Gradle脚本的过程中，我们有时候需要输出一些日志，来验证我们的逻辑或者一些变量的值是否正确，这时候我们就可以使用Gradle提供的日志功能。</p>
<p>通常情况下我们一般都是使用print系列方法，把日志信息输出到标准的控制台输出流（它被Gradle定向为QUIET级别日志）。<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println<span class="string">'输出一段日志信息'</span></span><br></pre></td></tr></table></figure></p>
<p>除了print系列方法之外，你也可以使用内置的logger更灵活的控制输出不同级别的日志信息。<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">logger.quiet(<span class="string">'quiet日志信息.'</span>)</span><br><span class="line">logger.error(<span class="string">'error日志信息.'</span>)</span><br><span class="line">logger.warn(<span class="string">'warn日志信息.'</span>)</span><br><span class="line">logger.lifecycle(<span class="string">'lifecycle日志信息.'</span>)</span><br><span class="line">logger.info(<span class="string">'info日志信息.'</span>)</span><br><span class="line">logger.debug(<span class="string">'debug日志信息.'</span>)</span><br></pre></td></tr></table></figure></p>
<p>logger说是内置，这里其实是调用的Project的getLogger()方法获取的Logger对象的实例。</p>
<h3 id="Gradle命令行">Gradle命令行</h3><p>Gradle命令行单独抽出来一小结的目的是想提倡大家尽可能的使用命令行，而不要太依赖于各种IDE，虽然IDE很方便，但是如果你换了一家公司，不适用这个IDE呢？如果让你做自动构建呢？可是没有IDE给你用的，全部都是基于命令行的。这个就像我们第一次学习变成语言时老师没说让你用IDE，而是直接用记事本或者其他文本工具写，目的就是让我们不要太依赖第三方工具，这种才能不变应万变。那么IDE该不该用，有没有必要，这个是肯定的，一定要用，因为他能提高你工作效率，但是用之前你要知道不借助IDE如果做一件事件，比如执行Gradle一个Task，在Android Studio下很简单，双击那个Task就可以执行了，但是如果没有Android Studio，你也要知道如何在命令行下如何运行它。我们要知其所以然，不然你再做几年也是这样啦。</p>
<h4 id="记得使用帮助">记得使用帮助</h4><p>命令行下的工具都有命令，刚开始我们不会用或者不知道有什么命令或者参数，这没事，但是我们可以通过帮助来了解，基本上所有的命令行工具都有帮助，查看帮助的方式也很简单，基本上都是在命令后跟-h或者—help，有的时候会有-?,以Gradle Wrapper为例：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gradlew -?&#10;./gradlew -h&#10;./gradlew --help</span><br></pre></td></tr></table></figure></p>
<h4 id="查看所有可执行的Tasks">查看所有可执行的Tasks</h4><p>有时候我们不知道如何构建一个功能，不知道执行哪个Task，这时候就需要查看哪些Task可执行，都具备什么功能，通过运行./gradlew tasks命令，输出如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:tasks&#10;     &#10;------------------------------------------------------------&#10;All tasks runnable from root project&#10;------------------------------------------------------------&#10;     &#10;Build Setup tasks&#10;-----------------&#10;init - Initializes a new Gradle build. [incubating]&#10;wrapper - Generates Gradle wrapper files. [incubating]&#10;     &#10;Help tasks&#10;----------&#10;components - Displays the components produced by root project &#39;flysnow&#39;. [incubating]&#10;dependencies - Displays all dependencies declared in root project &#39;flysnow&#39;.&#10;dependencyInsight - Displays the insight into a specific dependency in root project &#39;flysnow&#39;.&#10;help - Displays a help message.&#10;model - Displays the configuration model of root project &#39;flysnow&#39;. [incubating]&#10;projects - Displays the sub-projects of root project &#39;flysnow&#39;.&#10;properties - Displays the properties of root project &#39;flysnow&#39;.&#10;tasks - Displays the tasks runnable from root project &#39;flysnow&#39;.&#10;     &#10;To see all tasks and more detail, run gradle tasks --all&#10;     &#10;To see more detail about a task, run gradle help --task &#60;task&#62;&#10;     &#10;BUILD SUCCESSFUL&#10;     &#10;Total time: 2.321 secs&#10;     &#10;This build could be faster, please consider using the Gradle Daemon: http://gradle.org/docs/2.5/userguide/gradle_daemon.html</span><br></pre></td></tr></table></figure></p>
<p>从输出我们可以看到，Gradle会以分组的方式列出Task列表，比如构建类的有init，wrapper；帮助类的有help、tasks等。</p>
<h4 id="gradle_help_任务">gradle help 任务</h4><p>除了上面我们说的每个命令行都有帮助外，Gradle还内置了一个help task，这个help可以让我们了解每一个task的使用帮助，用法是 ./gradlew help —task <task name="">，比如 ./gradlew help —task tasks，就可以显示tasks任务的帮助信息：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:help&#10;Detailed task information for tasks&#10;    &#10;Path&#10;     :tasks&#10;    &#10;Type&#10;     TaskReportTask (org.gradle.api.tasks.diagnostics.TaskReportTask)&#10;    &#10;Options&#10;     --all     Show additional tasks and detail.&#10;    &#10;Description&#10;     Displays the tasks runnable from root project &#39;android-gradle-book-code&#39; (some of the displayed tasks may belong to subprojects).&#10;    &#10;Group&#10;     help&#10;    &#10;BUILD SUCCESSFUL</span><br></pre></td></tr></table></figure></task></p>
<p>从帮助信息我们可以看到这个task有什么用，他是什么类型，属于哪个分组，有哪些可以使用的参数，比如这里就有—all参数，可以查看很多额外的详细信息。</p>
<h4 id="强制刷新依赖">强制刷新依赖</h4><p>我们一个功能不可避免的会依赖很多第三方库，像Maven这类工具都是有缓存的，因为不可能每次编译的时候都要重新下载第三方库，缓存就是这个目的，先使用缓存，没有再下载。默认情况下Maven这类工具会控制缓存的更新，但是也有例外，比如Version一样，但是里面的代码变了；还有就是联调测试时使用的snapshot版本。上两种情况我们在实际项目中都遇到过，最后就是通过强制刷新解决的。强制刷新很简单，只要在命令行运行的时候加上—refresh-dependencies参数就可以，这是IDE很难做到的（需要你了解配置），所以命令行的优势就体现出来了，非常简单。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gradlew --refresh-dependencies assemble</span><br></pre></td></tr></table></figure></p>
<p>其他还有很多有用的命令、参数以及Tasks，就不一一介绍了，大家可以通过上面讲的两种帮助方法来了解熟悉。</p>
<h4 id="多任务调用">多任务调用</h4><p>有时候我们需要同事运行多个任务，比如在执行Jar之前先进行clean，那么我们就需要先执行clean对class文件清理，然后再执行jar生成一个jar包。通过命令行执行多个任务非常简单，只需要按顺序以空格分开即可，比如./gradlew clean jar，这样就可以了，有更多的任务时，可以继续添加。</p>
<h4 id="通过任务名字缩写执行执行">通过任务名字缩写执行执行</h4><p>有的时候我们的任务名字很长，如果在执行的时候全部写一遍也挺费时间，为此Gradle提供了基于驼峰命名法的缩写调用，比如connectCheck，我们执行的时候可以使用./gradlew connectCheck,也可以使用./gradlew cc这样的方式来执行。</p>
<p>以上内容节选自《Android Gradle权威指南》，更多关于《Android Gradle权威指南》的内容请参见<a href="http://yuedu.baidu.com/ebook/14a722970740be1e640e9a3e" target="_blank" rel="external">http://yuedu.baidu.com/ebook/14a722970740be1e640e9a3e</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p> Gradle是一款非常优秀的构建系统工具,它的DSL基于Groovy实现,可以让你很方便的通过代码控制这些DSL来达到你构建的目的，其构建的大部分功能都是通过插件的方式来实现，所以非常灵活方便，如果内置插件不能满足你的需求你可以自定义自己的插件。</p>
<p>本章我们就]]>
    </summary>
    
      <category term="Android" scheme="http://www.flysnow.org/tags/Android/"/>
    
      <category term="Gradle" scheme="http://www.flysnow.org/tags/Gradle/"/>
    
      <category term="Android" scheme="http://www.flysnow.org/categories/Android/"/>
    
      <category term="Gradle" scheme="http://www.flysnow.org/categories/Android/Gradle/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android注解支持(Support Annotations)]]></title>
    <link href="http://www.flysnow.org/2015/08/13/android-tech-docs-support-annotations.html"/>
    <id>http://www.flysnow.org/2015/08/13/android-tech-docs-support-annotations.html</id>
    <published>2015-08-13T14:16:50.000Z</published>
    <updated>2016-05-22T10:14:57.302Z</updated>
    <content type="html"><![CDATA[<p>以下内容由<a href="http://www.flysnow.org" target="_blank" rel="external">http://www.flysnow.org</a>(飞雪无情)提供翻译</p>
<p>原文地址 <a href="http://tools.android.com/tech-docs/support-annotations" target="_blank" rel="external">http://tools.android.com/tech-docs/support-annotations</a></p>
<p>更多翻译的Android技术文档请参考：<a href="https://github.com/rujews/android-tech-docs" target="_blank" rel="external">https://github.com/rujews/android-tech-docs</a></p>
<h3 id="注解支持(Support_Annotations)">注解支持(Support Annotations)</h3><p>Android support library从19.1版本开始引入了一个新的注解库，它包含很多有用的元注解，你能用它们修饰你的代码，帮助你发现bug。Support library自己本身也用到了这些注解，所以作为support library的用户，Android Studio已经基于这些注解校验了你的代码并且标注其中潜在的问题。Support library 22.2版本又新增了13个新的注解以供使用。</p>
<h3 id="使用注解库">使用注解库</h3><p>注解默认是没有包含的；他们被包装成一个独立的库。（support library现在由一些更小的库组成：v4-support, appcompat, gridlayout, mediarouter等等）</p>
<p>(如果你正在使用appcompat库，那么你已经可以使用这些注解了，因为appcomat它自己也依赖它。)</p>
<p>添加使用注解最简单的方式就是打开Project Structure对话框。首先在左边选中module，然后在右边选中Dependencies标签页，点击面板底部的<code>+</code>按钮，选择Library Dependency，假设你已经把Android Support Repository安装到你的SDK中了，那么注解库将会出现在列表中，你只需点击选中它即可(这里是列表中的第一个):<br><img src="/uploads/2015/08/add-dependency.png" alt="添加依赖"></p>
<p>点击OK完成Project Structure的编辑。这会修改你的build.gradle文件，当然你也可以手动编辑它：</p>
<pre><code><span class="keyword">dependencies</span> {
    <span class="keyword">compile</span> <span class="string">'com.android.support:support-annotations:22.2.0'</span>
}
</code></pre><p>对于Android application和Android library这两个类型的module(你应用了<code>com.android.application</code>或者<code>com.android.library</code>插件的)来说，你需要做的已经都做好了。如果你想只在Java module使用这些注解，那么你就明确的包含SDK仓库了，因为support libraries不能从jcenter获得(Android Gradle插件会自动的包含这些依赖，但是Java插件却没有。)</p>
<pre><code><span class="xml">repositories </span><span class="expression">{
   <span class="variable">jcenter</span>()
   <span class="variable">maven</span> { <span class="variable">url</span> '&lt;<span class="variable">your-SDK-path</span>&gt;<span class="end-block">/extras</span><span class="end-block">/android</span><span class="end-block">/m</span>2<span class="variable">repository</span>' }</span><span class="xml">
}</span>
</code></pre><h3 id="执行注解">执行注解</h3><p>当你用Android Studio和IntelliJ的时候，如果给标注了这些注解的方法传递错误类型的参数，那么IDE就会实时标记出来。</p>
<p>从Gradle插件1.3.0-beta1版本开始，并且安装了Android M Preview平台工具的情况下，通过命令行调用gradle的<code>lint</code>任务就可以执行这些检查。如果你想把标记问题作为持续集成的一部分，那么这种方式是非常有用的。说明：这并不包含nullness注解。本文中所介绍的其他注解都可以通过lint执行检查。</p>
<h3 id="Nullness_Annotations">Nullness Annotations</h3><p>@Nullable注解能被用来标注给定的参数或者返回值可以为null。<br>类似的，@NonNull注解能被用来标注给定的参数或者返回值不能为null。</p>
<p>如果一个本地变量的值为null(比如因为过早的代码检查它是否为null)，而你又把它作为参数传递给了一个方法，并且该方法的参数又被@NonNull标注，那么IDE会提醒你，你有一个潜在的崩溃问题。</p>
<pre><code>v4 support <span class="keyword">library</span>中的FragmentActivity的示例代码：

import android.support.annotation.NonNull;
import android.support.annotation.Nullable;
<span class="keyword">...</span>

/**
 * Add support <span class="keyword">for</span> inflating the &amp;lt;fragment&gt; tag.
 */
@Nullable
@Override
public View onCreateView(String name, @NonNull Context context, @NonNull AttributeSet attrs) {
<span class="keyword">...</span>
</code></pre><p>(如果你执行Analyze &gt; Infer Nullity，或者你在键入时把@NonNull替换成了@NotNull，那么IDE可能会提供附加的IntelliJ注解。参考底部的“IntelliJ Annotations”段落了解更多)</p>
<p>注意@NonNull和@Nullable并不是对立的：还有第三种可能：未指定。当你没有指定@NonNull或者@Nullable的时候，工具就不能确定，所以这个API也就不起作用。</p>
<p>最初，我们在findViewById方法上标注@Nullable，从技术上说，这是正确的：findViewById可以返回null。但是如果你知道你在做什么的时候(如果你传递给他一个存在的id)他是不会返回null的。当我们使用@Nullable注解它的时候，就意味着源代码编辑器中会有大量的代码出现高亮警告。如果你已经意识到每次使用该方法都应该明确的进行null检查，那么就只能用@Nullable标注返回值。有个经验规则：看现有的“好的代码”(比如审查产品代码)，看看这些API是怎么被使用的。如果该代码为null检查结果，你应该为方法注解@Nullable。</p>
<h3 id="资源类型注解">资源类型注解</h3><p>Android的资源值通常都是使用整型传递。这意味着获取一个drawable使用的参数，也能很容易的传递给一个获取string的方法；因为他们都是int类型，编译器很难区分。</p>
<p>资源类型注解可以在这种情况下提供类型检查。比如一个被@StringRes住进诶的int类型参数，如果传递一个不是R.string类型的引用将会被IDE标注：<br><img src="/uploads/2015/08/image00.png" alt="资源类型注解"><br>以ActionBar为例:</p>
<pre><code>import android.support.annotation.StringRes;
<span class="keyword">...</span>
public abstract void setTitle(@StringRes int resId);
</code></pre><p>有很多不同资源类型的注解：如下的每一个Android资源类型：<br>@StringRes, @DrawableRes, @ColorRes, @InterpolatorRes,等等。一般情况下，如果有一个<code>foo</code>类型的资源，那么它的相应的资源类型注解就是FooRes.</p>
<p>除此之外，还有一个名为@AnyRes特殊的资源类型注解。它被用来标注一个未知的特殊类型的资源，但是它必须是一个资源类型。比如在框架中，它被用在<code>Resources#getResourceName(@AnyRes int resId)</code>上，使用的时候，你可以这样<code>getResources().getResourceName(R.drawable.icon)</code>用，也可以<code>getResources().getResourceName(R.string.app_name)</code>这样用，但是却不能这样<code>getResources().getResourceName(42)</code>用。</p>
<p>请注意，如果你的API支持多个资源类型，你可以使用多个注解来标注你的参数。</p>
<h3 id="IntDef/StringDef:_类型定义注解">IntDef/StringDef: 类型定义注解</h3><p>整型除了可以作为资源的引用之外，也可以用作“枚举”类型使用。</p>
<p>@IntDef和”typedef”作用非常类似，你可以创建另外一个注解，然后用@IntDef指定一个你期望的整型常量值列表，最后你就可以用这个定义好的注解修饰你的API了。</p>
<p>appcompat库里的一个例子：</p>
<pre><code><span class="keyword">import</span> android.support.annotation.IntDef;
...
<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ActionBar</span> </span>{
...
<span class="annotation">@IntDef</span>({NAVIGATION_MODE_STANDARD, NAVIGATION_MODE_LIST, NAVIGATION_MODE_TABS})
<span class="annotation">@Retention</span>(RetentionPolicy.SOURCE)
<span class="keyword">public</span> <span class="annotation">@interface</span> NavigationMode {}

<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NAVIGATION_MODE_STANDARD = <span class="number">0</span>;
<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NAVIGATION_MODE_LIST = <span class="number">1</span>;
<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NAVIGATION_MODE_TABS = <span class="number">2</span>;

<span class="annotation">@NavigationMode</span>
<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">getNavigationMode</span><span class="params">()</span></span>;

<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">setNavigationMode</span><span class="params">(@NavigationMode <span class="keyword">int</span> mode)</span></span>;
</code></pre><p>上面非注解的部分是现有的API。我们创建了一个新的注解(NavigationMode)并且用@IntDef标注它,通过@IntDef我们为返回值或者参数指定了可用的常量值。我们还添加了<code>@Retention(RetentionPolicy.SOURCE)</code>告诉编译器这个新定义的注解不需要被记录在生成的.class文件中(译者注：源代码级别的，生成class文件的时候这个注解就被编译器自动去掉了)。</p>
<p>使用这个注解后，如果你传递的参数或者返回值不在指定的常量值中的话，IDE将会标记出这种情况。<br><img src="/uploads/2015/08/image06.png" alt="类型定义注解"></p>
<p>你也可以指定一个整型是一个标记性质的类型；这样客户端代码就通过|，&amp;等操作符同时传递多个常量了：</p>
<pre><code><span class="variable">@IntDef</span>(flag=true, value={
        DISPLAY_USE_LOGO,
        DISPLAY_SHOW_HOME,
        DISPLAY_HOME_AS_UP,
        DISPLAY_SHOW_TITLE,
        DISPLAY_SHOW_CUSTOM
})
<span class="variable">@Retention</span>(RetentionPolicy.SOURCE)
public <span class="variable">@interface</span> DisplayOptions {}
</code></pre><p>最后，还有一个字符串版本的注解，就是@StringDef，它和@IntDef的作用基本上是一样，所不同的是它是针对字符串的。该注解一般不常用，但是有的时候非常有用，比如在限定向Activity#getSystemService方法传递的参数范围的时候。</p>
<p>要了解关于类型注解的更多详细信息，请参考<br><a href="https://developer.android.com/tools/debugging/annotations.html#enum-annotations" target="_blank" rel="external">https://developer.android.com/tools/debugging/annotations.html#enum-annotations</a></p>
<p>(这些都是建立在IntelliJ’s MagicConstant注解的基础上，你可以在这里找到该注解的详细信息：<a href="http://blog.jetbrains.com/idea/2012/02/new-magic-constant-inspection/" target="_blank" rel="external">http://blog.jetbrains.com/idea/2012/02/new-magic-constant-inspection/</a>)</p>
<h3 id="线程注解:_@UiThread,_@WorkerThread,_…">线程注解: @UiThread, @WorkerThread, …</h3><p>(Support library 22.2及其之后版本支持.)</p>
<p>如果你的方法只能在指定的线程类型中被调用，那么你就可以使用以下4个注解来标注它：</p>
<ul>
<li>@UiThread</li>
<li>@MainThread</li>
<li>@WorkerThread</li>
<li>@BinderThread</li>
</ul>
<p>如果一个类中的所有方法都有相同的线程需求，那么你可以注解类本身。比如android.view.View，就被用@UiThread标注。</p>
<p>关于线程注解使用的一个很好的例子就是AsyncTask：</p>
<pre><code><span class="annotation">@WorkerThread</span>
<span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="function">Result <span class="title">doInBackground</span><span class="params">(Params... params)</span></span>;

<span class="annotation">@MainThread</span>
<span class="keyword">protected</span> <span class="function"><span class="keyword">void</span> <span class="title">onProgressUpdate</span><span class="params">(Progress... values)</span> </span>{
}
</code></pre><p>如果你在重写的doInBackground方法里尝试调用onProgressUpdate方法或者View的任何方法，IDE工具就会马上把它标记为一个错误：<br><img src="/uploads/2015/08/image04.png" alt="线程注解"></p>
<p>@UiThread还是@MainThread?</p>
<p>在进程里只有一个主线程。这个就是@MainThread。同时这个线程也是一个@UiThread。比如activity的主要窗口就运行在这个线程上。然而它也有能力为应用创建其他线程。这很少见，一般具备这样功能的都是系统进程。通常是把和生命周期有关的用@MainThread标注，和View层级结构相关的用@UiThread标注。但是由于@MainThread本质上是一个@UiThread，而大部分情况下@UiThread又是一个@MainThread，所以工具(lint ,Android Studio,等等)可以把他们互换，所以你能在一个可以调用@MainThread方法的地方也能调用@UiThread方法，反之亦然。</p>
<h3 id="RGB颜色整型">RGB颜色整型</h3><p>当你的API期望一个颜色资源的时候，可以用@ColorRes标注，但是当你有一个相反的使用场景时，这种用法就不可用了，因为你并不是期望一个颜色资源id，而是一个真实的RGB或者ARGB的颜色值。</p>
<p>在这种情况下，你可以使用@ColorInt注解，表示你期望的是一个代表颜色的整数值：</p>
<pre><code><span class="keyword">public</span> <span class="keyword">void</span> setTextColor(<span class="annotation">@ColorInt</span> <span class="keyword">int</span> color)
</code></pre><p>有了这个，当你传递一个颜色id而不是颜色值的时候，lint就会标记出这段不正确的代码：<br><img src="/uploads/2015/08/image05.png" alt="颜色值注解"></p>
<h3 id="值约束:_@Size,_@IntRange,_@FloatRange">值约束: @Size, @IntRange, @FloatRange</h3><p>如果你的参数是一个float或者double类型，并且一定要在某个范围内，你可以使用@FloatRange注解：</p>
<pre><code><span class="tag">public</span> <span class="tag">void</span> <span class="tag">setAlpha</span>(<span class="variable">@FloatRange</span>(from=<span class="number">0.0</span>, to=<span class="number">1.0</span>) float alpha) {
</code></pre><p>如果有人使用该API的时候传递一个0-255的值，比如尝试调用setAlpha(128)，那么工具就会捕获这一问题：</p>
<p><img src="/uploads/2015/08/image08.png" alt="值约束注解"></p>
<p>(你也可以指定是否包括起始值。)</p>
<p>同样的，如果你的参数是一个int或者long类型，你可以使用@IntRange注解约束其值在一个特定的范围内：</p>
<pre><code><span class="tag">public</span> <span class="tag">void</span> <span class="tag">setAlpha</span>(<span class="variable">@IntRange</span>(from=<span class="number">0</span>,to=<span class="number">255</span>) int alpha) { … }
</code></pre><p>把这些注解应用到参数上是非常有用的，因为用户很有可能会提供错误范围的参数，比如上面的setAlpha例子，有的API是采用0-255的方式，而有的是采用0-1的float值的方式。</p>
<p>最后，对于数据、集合以及字符串，你可以用@Size注解参数来限定集合的大小(当参数是字符串的时候，可以限定字符串的长度)。</p>
<p>举几个例子</p>
<ul>
<li>集合不能为空: @Size(min=1)</li>
<li>字符串最大只能有23个字符: @Size(max=23)</li>
<li>数组只能有2个元素: @Size(2)</li>
<li>数组的大小必须是2的倍数 (例如图形API中获取位置的x/y坐标数组: @Size(multiple=2)</li>
</ul>
<p><img src="/uploads/2015/08/image03.png" alt="值约束注解"></p>
<h3 id="权限注解:_@RequiresPermission">权限注解: @RequiresPermission</h3><p>如果你的方法的调用需要调用者有特定的权限，你可以使用@RequiresPermission注解：</p>
<pre><code><span class="annotation">@RequiresPermission</span>(Manifest.permission.SET_WALLPAPER)
<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="function"><span class="keyword">void</span> <span class="title">setWallpaper</span><span class="params">(Bitmap bitmap)</span> <span class="keyword">throws</span> IOException</span>;
</code></pre><p>如果你至少需要权限集合中的一个，你可以使用anyOf属性：</p>
<pre><code><span class="annotation">@RequiresPermission</span>(anyOf = {
    Manifest.permission.ACCESS_COARSE_LOCATION,
    Manifest.permission.ACCESS_FINE_LOCATION})
<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="function">Location <span class="title">getLastKnownLocation</span><span class="params">(String provider)</span></span>;
</code></pre><p>如果你同时需要多个权限，你可以用allOf属性：</p>
<pre><code><span class="annotation">@RequiresPermission</span>(allOf = {
    Manifest.permission.READ_HISTORY_BOOKMARKS,
    Manifest.permission.WRITE_HISTORY_BOOKMARKS})
<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="function"><span class="keyword">void</span> <span class="title">updateVisitedHistory</span><span class="params">(ContentResolver cr, String url, <span class="keyword">boolean</span> real)</span> </span>{
</code></pre><p>对于intents的权限，可以直接在定义的intent常量字符串字段上标注权限需求(他们通常都已经被@SdkConstant注解标注过了):</p>
<pre><code><span class="annotation">@RequiresPermission</span>(android.Manifest.permission.BLUETOOTH)
<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ACTION_REQUEST_DISCOVERABLE =
        <span class="string">"android.bluetooth.adapter.action.REQUEST_DISCOVERABLE"</span>;
</code></pre><p>对于content providers的权限，你可能需要单独的标注读和写的权限访问，所以可以用@Read或者@Write标注每一个权限需求：</p>
<pre><code><span class="variable">@RequiresPermission</span>.<span class="function">Read</span>(<span class="variable">@RequiresPermission</span>(READ_HISTORY_BOOKMARKS))
<span class="variable">@RequiresPermission</span>.<span class="function">Write</span>(<span class="variable">@RequiresPermission</span>(WRITE_HISTORY_BOOKMARKS))
public static final Uri BOOKMARKS_URI = Uri.<span class="function">parse</span>(<span class="string">"content://browser/bookmarks"</span>);
</code></pre><p><img src="/uploads/2015/08/image01.png" alt="权限注解"></p>
<h3 id="方法重写:_@CallSuper">方法重写: @CallSuper</h3><p>如果你的API允许使用者重写你的方法，但是呢，你又需要你自己的方法(父方法)在重写的时候也被调用，这时候你可以使用@CallSuper标注：</p>
<pre><code><span class="variable">@CallSuper</span>
protected void <span class="function">onCreate</span>(<span class="variable">@Nullable</span> Bundle savedInstanceState) {
</code></pre><p>用了这个后，当重写的方法没有调用父方法时，工具就会给予标记提示：</p>
<p><img src="/uploads/2015/08/image02.png" alt="方法重写"></p>
<p>(Android Studio 1.3 Preview 1的lint检查有个关于这个注解的bug，这个bug就是即使是对的重写也会报错，这个bug已经在Preview 2版本修改，可以通过canary channel更新到Preview 2版本。)</p>
<h3 id="返回值:_@CheckResult">返回值: @CheckResult</h3><p>如果你的方法返回一个值，你期望调用者用这个值做些事情，那么你可以使用@CheckResult注解标注这个方法。</p>
<p>你并不需要微每个非空方法都进行标注。它主要的目的是帮助哪些容易被混淆，难以被理解的API的使用者。</p>
<p>比如，可能很多开发者都对String.trim()一知半解，认为调用了这个方法，就可以让字符串改变以去掉空白字符。如果这个方法被@CheckResult标注，工具就会对那些没有使用trim()返回结果的调用者发出警告。</p>
<p>Android中，Context#checkPermission这个方法已经被@CheckResult标注了：</p>
<pre><code>@(suggest=<span class="string">"#enforcePermission(String,int,int,String)"</span>)
<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="function"><span class="keyword">int</span> <span class="title">checkPermission</span><span class="params">(@NonNull String permission, <span class="keyword">int</span> pid, <span class="keyword">int</span> uid)</span></span>;
</code></pre><p>这是非常重要的，因为有些使用context.checkPermission的开发者认为他们已经执行了一个权限 —-但其实这个方法仅仅只做了检查并且反馈一个是否成功的值而已。如果开发者使用了这个方法，但是又不用其返回值，那么这个开发者真正想调用的可能是这个Context#enforcePermission方法，而不是checkPermission。</p>
<p><img src="/uploads/2015/08/image07.png" alt="返回值"></p>
<h3 id="@VisibleForTesting">@VisibleForTesting</h3><p>你可以把这个注解标注到类、方法或者字段上，以便你在测试的时候可以使用他们。</p>
<h3 id="@Keep">@Keep</h3><p>我们还在注解库里添加了@Keep注解，但是Gradle插件还支持（尽管已经在进行中）。被这个注解标注的类和方法在混淆的时候将不会被混淆。</p>
<h3 id="在你自己的库中使用注解">在你自己的库中使用注解</h3><p>如果你在你自己的库中使用了这些注解，并且是通过Gradle构建生成aar包，那么在构建的时候Android Gradle插件会提取注解信息放在AAR文件中供引用你的库的客户端使用。在AAR文件中你可以看到一个名为annotations.zip的文件，这个文件记录的就是注解信息，使用的是IntelliJ的扩展注解XML格式。这是必须的，因为.class文件不能包含足够的要处理以上@IntDef注解的信息；注意我们只需记录该常量的一个引用，而不是它的值。当且仅当你的工程依赖注解库的时候，Android Gradle插件会把提取注解的任务作为构建的一部分执行它。(说明：只有源保留注解被放置在.aar文件中；class级别的会被放在classes.jar里。)</p>
<h3 id="IntelliJ注解">IntelliJ注解</h3><p>IntelliJ，Android Studio就是基于它开发的，IntelliJ有一套它自己的注解；IntDef分析其实重用的是MagicConstant分析的代码，IntelliJ null分析其实用的是一组配置好的null注解。如果你执行Analyze &gt; Infer Nullity…，它会试图找出所有的null约束并添加他们。这个检查有时会插入IntelliJ注解。你可以通过搜索,替换为Android注解库的注解，或者你也可以直接用IntelliJ注解。在build.gradle里或者通过Project Structure对话框的Dependencies面板都可以添加如下依赖：</p>
<pre><code><span class="keyword">dependencies</span> {
    <span class="keyword">compile</span> <span class="string">'com.intellij:annotations:12.0'</span>
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>以下内容由<a href="http://www.flysnow.org" target="_blank" rel="external">http://www.flysnow.org</a>(飞雪无情)提供翻译</p>
<p>原文地址 <a href="http://too]]>
    </summary>
    
      <category term="Android" scheme="http://www.flysnow.org/tags/Android/"/>
    
      <category term="Android" scheme="http://www.flysnow.org/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android技术文档翻译--工具属性(Tools Attributes)]]></title>
    <link href="http://www.flysnow.org/2015/08/06/android-tech-docs-tools-attributes.html"/>
    <id>http://www.flysnow.org/2015/08/06/android-tech-docs-tools-attributes.html</id>
    <published>2015-08-06T08:54:05.000Z</published>
    <updated>2016-05-22T10:14:57.302Z</updated>
    <content type="html"><![CDATA[<p>以下内容由<a href="http://www.flysnow.org" target="_blank" rel="external">http://www.flysnow.org</a>(飞雪无情)提供翻译</p>
<p>原文地址 <a href="http://tools.android.com/tech-docs/tools-attributes" target="_blank" rel="external">http://tools.android.com/tech-docs/tools-attributes</a></p>
<p>更多翻译的Android技术文档请参考：<a href="https://github.com/rujews/android-tech-docs" target="_blank" rel="external">https://github.com/rujews/android-tech-docs</a></p>
<h2 id="Tools_属性">Tools 属性</h2><p>为了在XML文件中记录一些信息，Android专门定义了名为tools的XML命名空间。在应用打包的时候这些信息会被自动去掉，所以不会影响运行和下载的包大小。命名空间的URI是<code>http://schemas.android.com/tools</code>，一般以tools作为前缀：</p>
<pre><code>&lt;FrameLayout xmlns:<span class="variable">android=</span><span class="string">"http://schemas.android.com/apk/res/android"</span>
    xmlns:<span class="variable">tools=</span><span class="string">"http://schemas.android.com/tools"</span>
    android:<span class="variable">layout_width=</span><span class="string">"match_parent"</span>
    android:<span class="variable">layout_height=</span><span class="string">"match_parent"</span> &gt;
....
</code></pre><p>该文档记录了我们当前tools属性的用法.(<strong> 注意：这可能会随时改变 </strong>)</p>
<h3 id="tools:ignore">tools:ignore</h3><p>这个属性可以在任何XML元素上设置，其值是一个lint问题ID的逗号分割的列表，设置后该XML元素以及其子元素都将被递归的忽略。</p>
<pre><code>&lt;<span class="type">string</span> <span class="property">name</span>=<span class="string">"show_all_apps"</span> tools:ignore=<span class="string">"MissingTranslation"</span>&gt;All&lt;/<span class="type">string</span>&gt;
</code></pre><p>用途: Lint</p>
<h3 id="tools:targetApi">tools:targetApi</h3><p>该属性和Java类里的 <code>@TargetApi</code> 注解的作用是一样的：它可以让你指定元素使用的API的级别，其值既可以是整数也可以是代号名称</p>
<pre><code><span class="tag">&lt;<span class="title">GridLayout</span> <span class="attribute">tools:targetApi</span>=<span class="value">"ICE_CREAM_SANDWICH"</span> &gt;</span>
</code></pre><p>用途: Lint</p>
<h3 id="tools:locale">tools:locale</h3><p>该属性可以在资源文件的根元素上设置，可以设置一个合适的语言以及一个可选的地区。这样可以让tools知道资源文件里的字符串应用的是什么语言。比如，<code>values/strings.xml</code> 可以有如下根元素：</p>
<pre><code>&lt;resources <span class="string">xmlns:</span>tools=<span class="string">"http://schemas.android.com/tools"</span> <span class="string">tools:</span>locale=<span class="string">"es"</span>&gt;
</code></pre><p>现在我们知道，默认values文件里的字符串使用的是西班牙语，而不是英语。<br>用途: Lint, Studio (可以在非英语的资源文件中禁用拼写检查)</p>
<h3 id="tools:context">tools:context</h3><p>该属性通常被设置在布局文件的根元素上，记录布局文件所关联的Activity（设计时，一个布局可能会被多个部门引用）。这可以用来让布局编辑器知道其默认的主题，因为主题一般都是在清单文件里和与之关联的Activity里定义，而不是在布局文件里。和在清单文件中指定activity的类一样，你也可以使用.开头设置。</p>
<pre><code>&lt;android.support.v7.widget.GridLayout
    xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span>
    xmlns:tools=<span class="string">"http://schemas.android.com/tools"</span>
    tools:context=<span class="string">".MainActivity"</span> <span class="keyword">...</span> &gt;
</code></pre><p>用途：Studio &amp; Eclipse中的布局编辑器以及Lint。</p>
<h4 id="tools:layout">tools:layout</h4><p>此属性通常设置在&lt;fragment&gt;标签中，用来记录在设计时，你想看到的呈现的布局（运行时，将会由标签中给出的fragment类来决定）。</p>
<pre><code>&lt;fragment android:<span class="variable">name=</span><span class="string">"com.example.master.ItemListFragment"</span>
    tools:<span class="variable">layout=</span><span class="string">"@android:layout/list_content"</span> /&gt;
</code></pre><p>用途: Studio &amp; Eclipse的布局编辑器</p>
<h3 id="tools:listitem_/_listheader_/_listfooter">tools:listitem / listheader / listfooter</h3><p>这些属性可以被用在一个&lt;ListView&gt;(或者&lt;GridView&gt;，&lt;ExpandableListView&gt;这些AdapterView的子View)上，用于在设计时指定list元素、list头、list底的布局。工具就会填充一些虚拟的数据显示一个有代表性内容的列表。</p>
<pre><code>&lt;ListView
    android:<span class="variable">id=</span><span class="string">"@android:id/list"</span>
    android:<span class="variable">layout_width=</span><span class="string">"match_parent"</span>
    android:<span class="variable">layout_height=</span><span class="string">"match_parent"</span>
    tools:<span class="variable">listitem=</span><span class="string">"@android:layout/simple_list_item_2"</span> /&gt;
</code></pre><p>用途: Studio &amp; Eclipse的布局编辑器</p>
<h3 id="tools:showIn">tools:showIn</h3><p>该属性需要设置在被另外一个布局包含的一个布局的根元素中。允许你设置包含该布局的布局文件，并且在设计时，这个被包含的布局将会在其外部的布局里渲染呈现。这允许你在上下文里查看和编辑布局。需要Studio 0.5.8及其以后版本支持。更多信息请参考<a href="http://tools.android.com/recent/androidstudio058released" target="_blank" rel="external">发布公告</a></p>
<pre><code><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span>
<span class="tag">&lt;<span class="title">TextView</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span>
    <span class="attribute">xmlns:tools</span>=<span class="value">"http://schemas.android.com/tools"</span>
    <span class="attribute">android:text</span>=<span class="value">"@string/hello_world"</span>
    <span class="attribute">android:layout_width</span>=<span class="value">"wrap_content"</span>
    <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span>
    <span class="attribute">tools:showIn</span>=<span class="value">"@layout/activity_main"</span> /&gt;</span>
</code></pre><p>用途: Studio布局编辑器</p>
<h3 id="tools:menu">tools:menu</h3><p>该属性设置在布局的根元素上，作用是配置在Action Bar显示的菜单。Android Studio通过和该布局关联的Activity（通过tools:context找到）的onCreateOptionsMenu()方法尝试找出在Action Bar使用的菜单。者允许你覆盖搜索和已确认状态的菜单。该属性值是一个逗号分割的id列表(不需要@id和其他任何前缀)。你也可以用不带.xml扩展名的xml菜单的文件名。必须是0.8.0及其之后的Studio版本才支持。</p>
<pre><code><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span>
<span class="tag">&lt;<span class="title">LinearLayout</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span>
    <span class="attribute">xmlns:tools</span>=<span class="value">"http://schemas.android.com/tools"</span>
    <span class="attribute">android:orientation</span>=<span class="value">"vertical"</span>
    <span class="attribute">android:layout_width</span>=<span class="value">"match_parent"</span>
    <span class="attribute">android:layout_height</span>=<span class="value">"match_parent"</span>
    <span class="attribute">tools:menu</span>=<span class="value">"menu1,menu2"</span> /&gt;</span>
</code></pre><p>用途: Studio布局编辑器</p>
<h3 id="tools:actionBarNavMode">tools:actionBarNavMode</h3><p>概述行设置在布局的根元素上，以配置Action Bar的导航模式。有”standard”, “list” 以及 “tabs”这三个值可供选择，需要0.8.0及其之后的Studio版本支持。</p>
<pre><code><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span>
<span class="tag">&lt;<span class="title">LinearLayout</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span>
    <span class="attribute">xmlns:tools</span>=<span class="value">"http://schemas.android.com/tools"</span>
    <span class="attribute">android:orientation</span>=<span class="value">"vertical"</span>
    <span class="attribute">android:layout_width</span>=<span class="value">"match_parent"</span>
    <span class="attribute">android:layout_height</span>=<span class="value">"match_parent"</span>
    <span class="attribute">tools:actionBarNavMode</span>=<span class="value">"tabs"</span> /&gt;</span>
</code></pre><p>用途: Studio布局编辑器</p>
<h3 id="其他:_设计时属性">其他: 设计时属性</h3><p>在布局中，任何一个属性都有一个与之对应的内置的Android属性。比如，你能设置一个只在设计时显示的替代文本，但是在实际运行的时候却不显示。要了解更多相信，请参考<a href="http://tools.android.com/tips/layout-designtime-attributes" target="_blank" rel="external">设计时布局属性</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>以下内容由<a href="http://www.flysnow.org" target="_blank" rel="external">http://www.flysnow.org</a>(飞雪无情)提供翻译</p>
<p>原文地址 <a href="http://too]]>
    </summary>
    
      <category term="Android" scheme="http://www.flysnow.org/tags/Android/"/>
    
      <category term="Android" scheme="http://www.flysnow.org/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[android技术文档翻译--ant任务]]></title>
    <link href="http://www.flysnow.org/2015/08/03/android-tech-docs-ant-tasks.html"/>
    <id>http://www.flysnow.org/2015/08/03/android-tech-docs-ant-tasks.html</id>
    <published>2015-08-03T14:07:29.000Z</published>
    <updated>2016-05-22T10:14:57.302Z</updated>
    <content type="html"><![CDATA[<p>以下内容由<a href="http://www.flysnow.org" target="_blank" rel="external">http://www.flysnow.org</a>(飞雪无情)提供翻译</p>
<p>原文地址 <a href="http://tools.android.com/tech-docs/ant-tasks" target="_blank" rel="external">http://tools.android.com/tech-docs/ant-tasks</a></p>
<p>更多翻译的Android技术文档请参考：<a href="https://github.com/rujews/android-tech-docs" target="_blank" rel="external">https://github.com/rujews/android-tech-docs</a></p>
<h2 id="Ant任务">Ant任务</h2><p>此功能还在积极开发过程中，可以到ADT-dev中讨论</p>
<p>当前自定义的任务列表：</p>
<ul>
<li>AaptExecTask</li>
<li>AidlExecTask</li>
<li>ApkBuilderTask</li>
<li>BuildConfigTask</li>
<li>DexExecTask</li>
<li>IfElseTask</li>
<li>PropertyByReplaceTask</li>
<li>RenderScriptTask</li>
<li>SignApkTask</li>
<li>XPathTask</li>
<li>ZipAlignTask</li>
</ul>
<p>r20版本新增的任务：</p>
<ul>
<li>CheckEnvTask</li>
<li>ComputeDependencyTask</li>
<li>ComputeProjectClasspathTask</li>
<li>GetEmmaFilterTask</li>
<li>GetLibraryListTask</li>
<li>GetTargetTask</li>
<li>GetTypeTask</li>
<li>ManifestMergerTask</li>
</ul>
<p>被以上主要任务所使用的一些基本任务：</p>
<ul>
<li>BuildTypedTask</li>
<li>MultiFilesTask</li>
<li>SingleDependencyTask</li>
<li>SingleInputOutputTask</li>
</ul>
<h3 id="com-android-ant-CheckEnvTask:&lt;checkenv&gt;">com.android.ant.CheckEnvTask:&lt;checkenv&gt;</h3><p>对如下的环境信息作一些简单的校验:</p>
<ul>
<li>Ant的版本</li>
<li>Android SDK里的platform-tool文件夹是否存在</li>
</ul>
<p>该任务没有属性可配置</p>
<h3 id="com-android-ant-GetTypeTask_&lt;gettype&gt;">com.android.ant.GetTypeTask &lt;gettype&gt;</h3><p>获取项目工程的类型，其取值可能是：</p>
<ul>
<li>“app”</li>
<li>“library”</li>
<li>“test”</li>
<li>“test-app”</li>
</ul>
<table>
<thead>
<tr>
<th>属性名</th>
<th>描述</th>
<th>是否必须</th>
</tr>
</thead>
<tbody>
<tr>
<td>projectTypeOut</td>
<td>用于存储获得的项目类型</td>
<td>是</td>
</tr>
</tbody>
</table>
<h3 id="com-android-ant-GetTargetTask_&lt;gettarget&gt;">com.android.ant.GetTargetTask &lt;gettarget&gt;</h3><p>解析项目target，返回构建所必需依赖的target的值</p>
<table>
<thead>
<tr>
<th>属性名</th>
<th>描述</th>
<th>是否必须</th>
</tr>
</thead>
<tbody>
<tr>
<td>androidJarFileOut</td>
<td>存储获得的构建工程的target android.jar位置</td>
<td>是</td>
</tr>
<tr>
<td>androidAidlFileOut</td>
<td>存储获得的构建工程的target framework.aidl位置</td>
<td>是</td>
</tr>
<tr>
<td>bootClassPathOut</td>
<td>存储获得的一个Path对象，该对象包含所有启动jar(android.jar + add-on APIs)</td>
<td>是</td>
</tr>
<tr>
<td>targetApiOut</td>
<td>存储获得的构建工程的target API级别</td>
<td>是</td>
</tr>
<tr>
<td>minSdkVersionOut</td>
<td>存储获得的应用的minSdkVersion的值</td>
<td>是</td>
</tr>
</tbody>
</table>
<h3 id="com-android-ant-GetLibraryListTask_&lt;getlibs&gt;">com.android.ant.GetLibraryListTask &lt;getlibs&gt;</h3><p>统计工程所依赖的所有库工程的列表。该列表包含所有直接和间接的依赖，并且按指定的顺序排列。</p>
<table>
<thead>
<tr>
<th>属性名</th>
<th>描述</th>
<th>是否必须</th>
</tr>
</thead>
<tbody>
<tr>
<td>libraryFolderPathOut</td>
<td>存储获得的一个Path对象，该对象包含所有的库工程文件夹，并且以编译顺序排序</td>
<td>是</td>
</tr>
</tbody>
</table>
<h3 id="com-android-ant-ComputeDependencyTask_&lt;dependency&gt;">com.android.ant.ComputeDependencyTask &lt;dependency&gt;</h3><p>统计工程的依赖。主要是关于库工程相关的细节，当然也包括和主工程和它的库工程有关的所有jar库。<br>它会使用 <a href="http://tools.android.com/recent/dealingwithdependenciesinandroidprojects" target="_blank" rel="external">这里</a> 提到的依赖方案进行处理。</p>
<table>
<thead>
<tr>
<th>属性名</th>
<th>描述</th>
<th>是否必须</th>
</tr>
</thead>
<tbody>
<tr>
<td>libraryFolderPathOut</td>
<td>存储获得的一个Path对象，该对象包含所有的库工程文件夹，并且以编译顺序排序</td>
<td>是</td>
</tr>
<tr>
<td>libraryPackagesOut</td>
<td>存储获得的所有库工程的包名，并且以逗号分割</td>
<td>是</td>
</tr>
<tr>
<td>libraryManifestFilePathOut</td>
<td>存储获得的一个Path对象，该对象包含所有库工程的Manifest文件</td>
<td>是</td>
</tr>
<tr>
<td>libraryResFolderPathOut</td>
<td>存储获得的一个Path对象，该对象包含所有库工程的资源文件夹。<br 它="">使用aapt的顺序排序，正好和libraryFolderPathOut的顺序相反</td>
<td>是</td>
</tr>
<tr>
<td>libraryNativeFolderPathOut</td>
<td>存储获得的一个Path对象，该对象包含所有的库工程本地文件夹</td>
<td>是</td>
</tr>
<tr>
<td>jarLibraryPathOut</td>
<td>存储获得的一个Path对象，该对象包含所有构建所需的jar库</td>
<td>是</td>
</tr>
<tr>
<td>targetApi</td>
<td>项目构建的target API级别</td>
<td>是</td>
</tr>
<tr>
<td>verbose</td>
<td>项目构建显示的明细级别</td>
<td>否</td>
</tr>
</tbody>
</table>
<h3 id="其他的任务将在以后引入补充">其他的任务将在以后引入补充</h3>]]></content>
    <summary type="html">
    <![CDATA[<p>以下内容由<a href="http://www.flysnow.org" target="_blank" rel="external">http://www.flysnow.org</a>(飞雪无情)提供翻译</p>
<p>原文地址 <a href="http://too]]>
    </summary>
    
      <category term="Android" scheme="http://www.flysnow.org/tags/Android/"/>
    
      <category term="Ant" scheme="http://www.flysnow.org/tags/Ant/"/>
    
      <category term="Android" scheme="http://www.flysnow.org/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用Gradle管理你的Android Studio工程]]></title>
    <link href="http://www.flysnow.org/2015/03/30/manage-your-android-project-with-gradle.html"/>
    <id>http://www.flysnow.org/2015/03/30/manage-your-android-project-with-gradle.html</id>
    <published>2015-03-30T13:49:22.000Z</published>
    <updated>2016-05-22T10:14:57.302Z</updated>
    <content type="html"><![CDATA[<h1 id="Gradle简介">Gradle简介</h1><p><strong>Gradle</strong> 是一个基于Ant和Maven概念的项目自动化建构工具。它使用一种基于Groovy的特定领域语言(DSL)来声明项目设置，这比我们的ANT使用XML构建配置要灵活的多。在编写配置时，你可以像编程一样灵活，Gradle是基于Groovy的DSL语言，完全兼容JAVA</p>
<h1 id="Gradle入门">Gradle入门</h1><p>projects 和 tasks是Gradle中最重要的两个概念，任何一个Gradle构建都是由一个或者多个project组成，每个project可以是一个jar包，一个web应用，或者一个android app等，每个project又由多个task构成，一个task其实就是构建过程中一个原子性的操作，比如编译、拷贝等。</p>
<p>一个build.gradle文件是一个构建脚本，当运行gradle命令的时候会从当前目录查找build.gradle文件来执行构建。下面我们来看下gradle的Hello World。在build.gradle构建文件中输入以下构建脚本：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">task hello &#123;</span><br><span class="line">    doLast &#123;</span><br><span class="line">        println <span class="string">'Hello world!'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>task定义了一个任务，这个任务名字是hello。doLast是Task的方法，意思是在该hello任务执行之后作的事情，可以用一个闭包配置它,这里是输出Hello world!字符串。我们在终端里执行如下命令运行查看结果：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$gradle</span> hello -q</span><br><span class="line">Hello world!</span><br></pre></td></tr></table></figure></p>
<p>其他关于Gradle的更多介绍请参考<a href="https://gradle.org/docs/current/userguide/userguide" target="_blank" rel="external">Gradle使用指南</a></p>
<h1 id="Android_Studio入门">Android Studio入门</h1><p>使用Android Studio新建一个工程之后，其目录结构是这样的：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">├── app <span class="comment">#Android App目录</span></span><br><span class="line">│   ├── app.iml</span><br><span class="line">│   ├── build <span class="comment">#构建输出目录</span></span><br><span class="line">│   ├── build.gradle <span class="comment">#构建脚本</span></span><br><span class="line">│   ├── libs <span class="comment">#so相关库</span></span><br><span class="line">│   ├── proguard-rules.pro <span class="comment">#proguard混淆配置</span></span><br><span class="line">│   └── src <span class="comment">#源代码，资源等</span></span><br><span class="line">├── build</span><br><span class="line">│   └── intermediates</span><br><span class="line">├── build.gradle <span class="comment">#工程构建文件</span></span><br><span class="line">├── gradle</span><br><span class="line">│   └── wrapper</span><br><span class="line">├── gradle.properties <span class="comment">#gradle的配置</span></span><br><span class="line">├── gradlew <span class="comment">#gradle wrapper linux shell脚本</span></span><br><span class="line">├── gradlew.bat</span><br><span class="line">├── LibSqlite.iml</span><br><span class="line">├── local.properties <span class="comment">#配置Androod SDK位置文件</span></span><br><span class="line">└── settings.gradle <span class="comment">#工程配置</span></span><br></pre></td></tr></table></figure>
<p>settings.gradle用于配置project，标明其下有几个module，比如这里包含一个:app module</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include <span class="string">':app'</span></span><br></pre></td></tr></table></figure>
<p>和settings.gradle在同一目录下的build.gradle是一个顶级的build配置文件，在这里可以为所有project以及module配置一些常用的配置。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// Top-level build file <span class="built_in">where</span> you can add configuration options common to all sub-projects/modules.</span><br><span class="line"></span><br><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        jcenter()//使用jcenter库</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        // 依赖android提供的<span class="number">1.1</span>.<span class="number">0</span>的gradle build</span><br><span class="line">        classpath <span class="string">'com.android.tools.build:gradle:1.1.0'</span></span><br><span class="line"></span><br><span class="line">        // NOTE: Do not place your application dependencies here; they belong</span><br><span class="line">        // <span class="keyword">in</span> the individual module build.gradle files</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//为所有的工程的repositories配置为jcenters</span><br><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Android_Gradle基本配置">Android Gradle基本配置</h1><p>下面着重说一下Android的Gradle，毕竟对Android开发来说，这才是重中之重。这里以初始化好的build.gradle为例。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: <span class="string">'com.android.application'</span></span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">    compileSdkVersion <span class="number">21</span></span><br><span class="line">    buildToolsVersion <span class="string">"22.0.1"</span></span><br><span class="line"></span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        applicationId <span class="string">"org.flysnow.demo"</span></span><br><span class="line">        minSdkVersion <span class="number">9</span></span><br><span class="line">        targetSdkVersion <span class="number">21</span></span><br><span class="line">        versionCode <span class="number">1</span></span><br><span class="line">        versionName <span class="string">"1.0"</span></span><br><span class="line">    &#125;</span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            minifyEnabled <span class="literal">false</span></span><br><span class="line">            proguardFiles getDefaultProguardFile(<span class="string">'proguard-android.txt'</span>), <span class="string">'proguard-rules.pro'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile fileTree(dir: <span class="string">'libs'</span>, include: [<span class="string">'*.jar'</span>])</span><br><span class="line">    compile <span class="string">'com.android.support:appcompat-v7:22.0.0'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>开头第一行apply plugin: ‘com.android.application’，这表示该module是一个app module，应用了com.android.application插件，如果是一个android library，那么这里的是apply plugin: ‘com.android.library’。</p>
<p>其次是基于哪个SDK编译，这里是API LEVEL，是21，buildToolsVersion是基于哪个构建工具版本进行构建的。defaultConfig是默认配置，如果没有其他的配置覆盖，就会使用这里的。看其属性的名字就可以知道其作用，比如applicationId是配置包名的，versionCode是版本号，versionName是版本名称等。</p>
<p>buildTypes是构建类型，常用的有release和debug两种，可以在这里面启用混淆，启用zipAlign以及配置签名信息等。</p>
<p>dependencies就不属于Android专有的配置了，它定义了该module需要依赖的jar，aar，jcenter库信息。</p>
<h1 id="配置应用的签名信息">配置应用的签名信息</h1><p>在android.signingConfigs{}下定义一个或者多个签名信息，然后在buildTypes{}配置使用即可。比如这里</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line"></span><br><span class="line">    signingConfigs &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            storeFile file(<span class="string">"release.keystore"</span>)</span><br><span class="line">            keyAlias <span class="string">"release"</span></span><br><span class="line">            keyPassword <span class="string">"123456"</span></span><br><span class="line">            storePassword <span class="string">"123456"</span></span><br><span class="line">        &#125;</span><br><span class="line">        debug &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            signingConfig signingConfigs.release</span><br><span class="line">        &#125;</span><br><span class="line">        debug &#123;</span><br><span class="line">            signingConfig signingConfigs.debug</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>storeFile是签名证书文件，keyAlias是别名，keyPassword是key的密码，storePassword是证书的密码。配好好相关信息即可在buildTypes配置使用。</p>
<h1 id="启用proguard混淆">启用proguard混淆</h1><p>我们可以为不同的buildTypes选择是否启用混淆，一般release发布版本是需要启用混淆的，这样别人反编译之后就很难分析你的代码，而我们自己开发调试的时候是不需要混淆的，所以debug不启用混淆。对release启用混淆的配置如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line"></span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            minifyEnabled <span class="literal">true</span></span><br><span class="line">            proguardFile <span class="string">'proguard.cfg'</span></span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>minifyEnabled为true表示启用混淆，proguardFile是混淆使用的配置文件，这里是module根目录下的proguard.cfg文件</p>
<h1 id="启用zipAlign">启用zipAlign</h1><p>这个也是比较简单的，同样也是在buildTypes里配置，可以为不用的buildTypes选择时候开启zipAlign<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line"></span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            zipAlignEnabled <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="多渠道打包">多渠道打包</h1><p>东西到了国内就变了，做什么都是一窝蜂，比如Android App市场就是，所以才有了多渠道打包，每次发版几十个渠道包。还好Android Gradle给我们提供了productFlavors，让我们可以对生成的APK包进行定制，所以就有了多渠道。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">android  &#123;</span><br><span class="line">    productFlavors &#123;</span><br><span class="line">        dev&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        google&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        baidu&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样当我们运行assembleRelease的时候就会生成3个release包，分别是dev、google以及baidu的。目前看这三个包除了文件名没有什么不一样，因为我们还没有定制，使用的都是defaultConfig配置。这里的flavor和defaultConfig是一样的，可以自定义其applicationId、versionCode以及versionName等信息，比如区分不同包名：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">android  &#123;</span><br><span class="line">    productFlavors &#123;</span><br><span class="line">        dev&#123;</span><br><span class="line">            applicationId <span class="string">"org.flysnow.demo.dev"</span></span><br><span class="line">        &#125;</span><br><span class="line">        google&#123;</span><br><span class="line">            applicationId <span class="string">"org.flysnow.demo.google"</span></span><br><span class="line">        &#125;</span><br><span class="line">        baidu&#123;</span><br><span class="line">            applicationId <span class="string">"org.flysnow.demo.baidu"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="批量修改生成的apk文件名">批量修改生成的apk文件名</h1><p>在我们打包发版的时候，一次性打几十个包，这时候我们就想让生成的apk文件名有区分，比如一眼就能看出这个apk是哪个版本的，哪个渠道的，是哪天打的包等等，这就需要我们在生成apk文件的时候动态修改生成的apk文件名达到这一目的。这里以我们的产品随手记为例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">def <span class="function"><span class="title">buildTime</span></span>() &#123;</span><br><span class="line">    def date = new Date()</span><br><span class="line">    def formattedDate = date.format(<span class="string">'yyyyMMdd'</span>)</span><br><span class="line">    <span class="built_in">return</span> formattedDate</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            applicationVariants.all &#123; variant -&gt;</span><br><span class="line">                variant.outputs.each &#123; output -&gt;</span><br><span class="line">                    <span class="keyword">if</span> (output.outputFile != null &amp;&amp; output.outputFile.name.endsWith(<span class="string">'.apk'</span>)</span><br><span class="line">                        &amp;&amp;<span class="string">'release'</span>.equals(variant.buildType.name)) &#123;</span><br><span class="line">                        def apkFile = new File(</span><br><span class="line">                                output.outputFile.getParent(),</span><br><span class="line">                                <span class="string">"Mymoney_<span class="variable">$&#123;variant.flavorName&#125;</span>_v<span class="variable">$&#123;variant.versionName&#125;</span>_<span class="variable">$&#123;buildTime()&#125;</span>.apk"</span>)</span><br><span class="line">                        output.outputFile = apkFile</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以baidu渠道为例，以上的代码会生成一个名字为Mymoney_baidu_v9.5.2.6_20150330.apk安装包。下面我们分析一下，Android Gradle任务比较复杂，它的很多任务都是自动生成的，为了可以更灵活的控制，Android Gradle提供了applicationVariants、libraryVariants以及testVariants，他们分别适用于app、library、app和library都适用。</p>
<p>这里是循环处理每个applicationVariant，当他们的输出文件名以apk结尾并且buildType是release时，重新设置新的输出文件名，这样就达到了我们批量修改生成的文件名的目的。</p>
<h1 id="AndroidManifest里的占位符">AndroidManifest里的占位符</h1><p>AndroidManifest.xml这是一个很重要的文件，我们的很多配置都在这里定义。有时候我们的一些配置信息，比如一个第三方应用的key，第三方统计分析的渠道号等也要在这里进行配置。这里以友盟统计分析平台为例，演示这一功能的使用。在友盟统计分析中，我们需要根据渠道进行统计，比如google，百度，应用宝等渠道的活跃新增等，友盟的SDK是在AndroidManifest里配置一个name为UMENG_CHANNEL的meta-data，这样这个meta-data的值就表示这个apk是哪个渠道，我们版本发布有几十个渠道，以前ant打包的时候是采用文字替换的办法，现在Gradle有更好的处理办法，那就是manifestPlaceholders，它允许我们动态替换我们在AndroidManifest文件里定义的占位符。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">meta-data</span> <span class="attribute">android:value</span>=<span class="value">"$&#123;UMENG_CHANNEL_VALUE&#125;"</span> <span class="attribute">android:name</span>=<span class="value">"UMENG_CHANNEL"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>如上${UMENG_CHANNEL_VALUE}就是一个占位符，然后我们在gradle的defaultConfig；里这样定义脚本：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        manifestPlaceholders = [UMENG_CHANNEL_VALUE: <span class="string">'dev'</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以前的意思就是我们的默认配置里AndroidManifest的${UMENG_CHANNEL_VALUE}占位符会被dev这个字符串所替换，也就说默认运行的版本是一个开发板。以此类推，我们其他渠道的版本就可以这样定义：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">android  &#123;</span><br><span class="line">    productFlavors &#123;</span><br><span class="line">        google&#123;</span><br><span class="line">            applicationId <span class="string">"org.flysnow.demo.google"</span></span><br><span class="line">            manifestPlaceholders.put(<span class="string">"UMENG_CHANNEL_VALUE"</span>,<span class="string">'google'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        baidu&#123;</span><br><span class="line">            applicationId <span class="string">"org.flysnow.demo.baidu"</span></span><br><span class="line">            manifestPlaceholders.put(<span class="string">"UMENG_CHANNEL_VALUE"</span>,<span class="string">'baidu'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样有多少个渠道就做多少次这样的定义，即可完成分渠道统计。但是如果上百个渠道，这样一个个写的确太累，很麻烦，我们继续研究，同学们有没有发现，我们的渠道名字和我们的flavorName一样，我们用这个flavorName作为UMENG_CHANNEL_VALUE不就好了吗，可以批量的替换吗？当然可以，这又体现了我们Gradle的强大和灵活之处。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">productFlavors.all &#123; flavor -&gt;</span><br><span class="line">        manifestPlaceholders.put(<span class="string">"UMENG_CHANNEL_VALUE"</span>,name)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>循环每个flavor，并把他们的UMENG_CHANNEL_VALUE设置为他们自己的name名字，ok，搞定。</p>
<h1 id="自定义你的BuildConfig">自定义你的BuildConfig</h1><p>BuildConfig.java是Android Gradle自动生成的一个java类文件，无法手动编译，但是可以通过Gradle控制，也就是说他是动态可配置的，有了这个功能就很好玩了，这里以生产环境和测试环境为例来说明该功能的使用。</p>
<p>我们在开发App的时候免不了要和服务器进行通信，我们的服务器一般都有生产和测试环境，当我们处理开发和测试的时候使用测试环境进行调试，正式发布的时候使用生成环境。以前的时候我们通过把不同的配置文件打包进APK中来控制，现在不一样了，我们有更简便的方法，这就是buildConfigField。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        buildConfigField <span class="string">'String'</span>,<span class="string">'API_SERVER_URL'</span>,<span class="string">'"http://test.flysnow.org/"'</span></span><br><span class="line">    &#125;</span><br><span class="line">    productFlavors &#123;</span><br><span class="line">        google&#123;</span><br><span class="line">            buildConfigField <span class="string">'String'</span>,<span class="string">'API_SERVER_URL'</span>,<span class="string">'"http://www.flysnow.org/"'</span></span><br><span class="line">        &#125;</span><br><span class="line">        baidu&#123;</span><br><span class="line">            buildConfigField <span class="string">'String'</span>,<span class="string">'API_SERVER_URL'</span>,<span class="string">'"http://www.flysnow.org/"'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>buildConfigField 一共有3个参数，第一个是数据类型，就是你定义的常量值是一个什么类型，和Java的类型是对等的，这里是String。第二个参数是常量名，这里是API_SERVER_URL。第三个参数是常量值。如此定义之后，就会在BuildConfig.java中生成一个常量名为API_SERVER_URL的常量定义。默认配置的生成是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String API_SERVER_URL = <span class="string">"http://test.flysnow.org/"</span></span><br></pre></td></tr></table></figure>
<p>当是baidu和google渠道的时候生成的就是<code>http://www.flysnow.org/</code>了。这个常量可以在我们编码中引用。在我们进行打包的时候会根据Gradle配置动态替换。</p>
<p>我们发现一般渠道版本都是用来发布的，肯定用的是生产服务器，所以我们可以使用批处理来搞定这个事情，而不用在一个个渠道里写这些配置。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">productFlavors.all &#123; flavor -&gt;</span><br><span class="line">        buildConfigField <span class="string">'String'</span>,<span class="string">'API_SERVER_URL'</span>,<span class="string">'"http://www.flysnow.org/"'</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>此外，比如Gradle的resValue，也是和buildConfigField，只不过它控制生成的是资源，比如我们在android的values.xml定义生成的字符串。可以用它来动态生成我们想要的字符串，比如应用的名字，可能一些渠道会不一样，这样就可以很灵活的控制自动生成，关于resValue详细介绍请参考相关文档，这里不再举例说明。</p>
<h1 id="插装测试覆盖率代码">插装测试覆盖率代码</h1><p>代码覆盖率现在已经成为检验单元测试是否覆盖到的一种手段，Android Gradle提供了原生的用于单元测试的代码覆盖率，这个就是jacoco。今天我们不谈这个，我想要的是在我们生成的APK包中已经包含了检测代码覆盖率的代码，这样当我们安装APK后运行进行一些测试的时候，这些检测代码覆盖率的代码就会被执行到，这样最后我们导出一份代码测试覆盖率的文件，然后生成查看测试覆盖率报告看哪些覆盖到，哪些没有覆盖到。这种场景在检测测试工程师测试功能以及Android UI自动化测试是否完全覆盖尤为有效。这里代码覆盖率框架我选择的是emma，一来这个在Ant打包的时候一直在用，二来它具有很方便的插装功能。</p>
<p>emma插装的是class文件，所以我们只能在编译完java文件生成class文件后进行插装，这是我们进行覆盖率代码插装的最好时机。找到了时机，那么具体对应在Gradle脚本上是哪呢？还记不记得我们上面讲的applicationVariants，每一个applicationVariant都有一个javaCompile属性，javaCompile是一个JavaCompile类型的Task，这个就是负责编译java代码的。是Task就有doLast方法，就是在这个任务本身完成之后要做的事情，我们就是在这个方法里进行我们的代码覆盖率的安装。一般我们这个插装只是在特性情况下，那么我们新增一个特殊的flavor好了，专门做这个使用，这里我姑且叫feature。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">applicationVariants.all &#123; variant -&gt;</span><br><span class="line">    //为feature 版本加上代码覆盖率</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">'feature'</span>.equals(variant.flavorName))&#123;</span><br><span class="line">        variant.javaCompile.doLast &#123;</span><br><span class="line">            def coverageFile=file(<span class="string">'out/coverage.em'</span>)</span><br><span class="line">            <span class="keyword">if</span>(coverageFile.exists())&#123;</span><br><span class="line">                coverageFile.delete()</span><br><span class="line">            &#125;</span><br><span class="line">            javaexec &#123;</span><br><span class="line">                main <span class="string">'emma'</span></span><br><span class="line">                args <span class="string">'instr'</span>,<span class="string">'-ip'</span>,variant.javaCompile.destinationDir,<span class="string">'-m'</span>,<span class="string">'overwrite'</span>,<span class="string">'-out'</span>,<span class="string">'out/coverage.em'</span></span><br><span class="line">                classpath files(new File(getSdkDirectory(),<span class="string">'tools/lib/emma.jar'</span>))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>非常简单，我们使用javaexec命令执行java应用程序进程插装，插装模式使用的是overwrite，就是插装后覆盖源文件。getSdkDirectory()函数获取你电脑上的Android SDK目录，这里我们使用SDK自带的emma，保持每个人的统一。另外注意进行代码覆盖率插装的APK不能进行代码混淆，这个很简单，为feature flavor指定不混淆的proguardFile覆盖默认的proguardFile即可。最后该APK需要emma的框架代码，所以要配置feature flavor的特殊依赖信息。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compile fileTree(dir: <span class="string">'libs'</span>, include: <span class="string">'*.jar'</span>)</span><br><span class="line">    featureCompile files(new File(android.getSdkDirectory(),<span class="string">'tools/lib/emma_device.jar'</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="dexOptions_javaMaxHeapSize">dexOptions javaMaxHeapSize</h1><p>在Gradle 进行dex的可能会遇到内存不够用的情况，错误信息大概是java.lang.OutOfMemoryError: GC overhead limit exceeded。这个时候只需要配置dexOptions的javaMaxHeapSize大小即可，我这里配置4g：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dexOptions &#123;</span><br><span class="line">    javaMaxHeapSize <span class="string">"4g"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="结束语">结束语</h1><p>到这里Android Gradle在项目中的大概使用就着一些了，当然不用的项目可以定制的程度不一样，关于更详细和更深入的介绍可以参考我之前翻译的官方文档 <a href="https://github.com/rujews/android-tech-docs/blob/master/new-build-system/user-guide/README.md" target="_blank" rel="external">https://github.com/rujews/android-tech-docs/blob/master/new-build-system/user-guide/README.md</a> ，也可以在博客下方留言交流。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Gradle简介">Gradle简介</h1><p><strong>Gradle</strong> 是一个基于Ant和Maven概念的项目自动化建构工具。它使用一种基于Groovy的特定领域语言(DSL)来声明项目设置，这比我们的ANT使用XML构建配置要灵活的多]]>
    </summary>
    
      <category term="Android" scheme="http://www.flysnow.org/tags/Android/"/>
    
      <category term="Gradle" scheme="http://www.flysnow.org/tags/Gradle/"/>
    
      <category term="Android" scheme="http://www.flysnow.org/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android多进程的数据库访问问题]]></title>
    <link href="http://www.flysnow.org/2015/03/19/android-process-application-init-databases-problem.html"/>
    <id>http://www.flysnow.org/2015/03/19/android-process-application-init-databases-problem.html</id>
    <published>2015-03-19T13:58:45.000Z</published>
    <updated>2016-05-22T10:14:57.302Z</updated>
    <content type="html"><![CDATA[<p>在Android开发中，我们可能会使用单独的进程来做一些事情，比如推送服务，心跳服务等，这些不需要主应用启动，只需要一个独立的进程即可。这时候我们一般都会采用启动一个后台Service，这个Service运行在一个独立的进程中，比如在Androidmainfest.xml中配置Service的android:process=”:push”指定该Service运行在:push进程中。</p>
<p>一般情况下这样做是没有任何问题的，但是如果你在你的Application的onCreate方法里有对数据库的操作，或者该Service里有对数据库的操作，就会有可能会有两个进程同时操作一个数据库的情况，一个是你的主应用的进程，进程名为你的包名例如org.flysnow;一个是你的Service所在的进程，进程名为你的包名+”:push”,即org.flysnow:push。这两个进程可能在同一时间访问同一个数据，同一个配置文件等。这就可能造成资源的竞争访问，造成的问题就不可预料了，比如数据库损坏，数据丢失等。</p>
<p>多进程其实和多线程一样，并发访问的时候产生的问题很难预料，在多线程的时候我们有锁等机制控制资源的访问，但是在多进程中比较难，虽然有文件锁、排队等机制，但是在Android里很难实现，毕竟在Android里一个进程就是一个VM虚拟机，底层的东西控制不了，Java层又没有办法控制，所以在多进程中一定不要有并发增删改文件的操作。</p>
<p>解决问题的核心就是不并发访问同一个文件，多线程时就使用Lock机制；多进程的时候就避免进行数据库的访问，比如只做一些心跳、激活、消息抓取等操作，涉及到把消息存储到数据库，访问配置文件等操作还是调用主进程进程操作。还一个要注意的就是Application的oncreate方法里要避免多进程访问同一文件，因为没一个进程初始化都会执行该方法，可以在一些进程初始化的时候不需要文件操作的时候不要进行文件操作，比如在onCreate里获取当前的进程，不等于包名的就不进行文件的访问操作，获取进程可以使用android.os.Process.myUid()方法。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在Android开发中，我们可能会使用单独的进程来做一些事情，比如推送服务，心跳服务等，这些不需要主应用启动，只需要一个独立的进程即可。这时候我们一般都会采用启动一个后台Service，这个Service运行在一个独立的进程中，比如在Androidmainfest.xml中]]>
    </summary>
    
      <category term="Android" scheme="http://www.flysnow.org/tags/Android/"/>
    
      <category term="数据库" scheme="http://www.flysnow.org/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Android" scheme="http://www.flysnow.org/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用Hexo在Github上搭建自己的博客]]></title>
    <link href="http://www.flysnow.org/2015/03/10/github-page-with-hexo.html"/>
    <id>http://www.flysnow.org/2015/03/10/github-page-with-hexo.html</id>
    <published>2015-03-10T14:30:04.000Z</published>
    <updated>2016-05-22T10:14:57.302Z</updated>
    <content type="html"><![CDATA[<p>以前的博客是使用Jekyll托管在github上，后来用着越来越不方便，比如没有自动生成post，不能一键部署，文件结构和配置也是比较繁琐，更重要的是有时候用markdown写一篇文章，生成的静态文件很乱，应该是有些字符解析的问题。现在下决心换成了hexo</p>
<h1 id="Nodejs安装">Nodejs安装</h1><p>因为hexo是基于nodejs的应用，所以要先安装nodejs才可以。我这里以ubuntu为例，因为我自己一直在使用ubuntu。使用如下命令即可：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install nodejs</span><br><span class="line">sudo apt-get install npm</span><br></pre></td></tr></table></figure>
<h1 id="Hexo安装">Hexo安装</h1><p><a href="https://github.com/hexojs/hexo/" title="Hexo" target="_blank" rel="external">Hexo</a> 是一个功能强大的静态网站生成系统，快速、简洁、高效。Hexo 支持 GitHub Flavored Markdown 的所有功能，甚至可以整合 Octopress 的大多数插件。可以一键部署到github，还有丰富的插件和主题,还支持热部署哦。执行如下命令进行安装。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo npm install hexo-cli -g</span><br></pre></td></tr></table></figure>
<h1 id="快速开始">快速开始</h1><p>安装Hexo安成后，使用如下命令快速新建一个博客系统，然后运行它</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo init blog</span><br><span class="line"><span class="built_in">cd</span> blog</span><br><span class="line">npm install</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure>
<p>如果npm安装失败，请使用sudo安装。运行成功后，访问<a href="http://0.0.0.0:4000/就可以看到博客的样子的，对就是我现在的博客这个样子，o(∩∩)o...哈哈。" target="_blank" rel="external">http://0.0.0.0:4000/就可以看到博客的样子的，对就是我现在的博客这个样子，o(∩∩)o...哈哈。</a></p>
<p>现在我们来看看Hexo 生成博客的目录结构</p>
<pre><code>.
├── _config<span class="class">.yml</span>
├── db<span class="class">.json</span>
├── node_modules
├── package<span class="class">.json</span>
├── public
├── scaffolds
├── source
└── themes
</code></pre><p>其中_config.yml是配置站点的文件，public是hexo生成的静态站点文件夹，scaffolds是模板文件夹，source是存在用户资源的文件夹，themes是主题文件夹。</p>
<h1 id="站点配置">站点配置</h1><p>找到title，subtitle，author参数配置，分别配置站点的标题、副标题和作者,比如我这里是：</p>
<pre><code><span class="label">title:</span> 飞雪无情的博客
<span class="label">subtitle:</span> 专注于Android、Java、移动互联网、项目管理、软件架构
<span class="label">description:</span>
<span class="label">author:</span> 飞雪无情
<span class="label">language:</span> <span class="built_in">zh</span>-CN
</code></pre><p>然后配置站点的url和permalink，这两个分别是你的站点的url host地址以及文章的永久连接，我这里是：</p>
<pre><code><span class="string">url:</span> <span class="string">http:</span><span class="comment">//www.flysnow.org</span>
<span class="string">root:</span> /
<span class="string">permalink:</span> :year<span class="regexp">/:month/</span>:day/:title.html
<span class="string">permalink_defaults:</span>
</code></pre><p>permalink 我配置的是年月日以及title，后缀是html，便于搜索收录。permalink详情参见： <a href="http://hexo.io/zh-cn/docs/permalinks.html" target="_blank" rel="external">http://hexo.io/zh-cn/docs/permalinks.html</a></p>
<h1 id="新增一篇文章">新增一篇文章</h1><p>使用如下命令即可新增一篇md格式的文章</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new <span class="string">'github-page-with-hexo'</span></span><br></pre></td></tr></table></figure>
<p>然后就会在sources/_posts生成一篇文件名为github-page-with-hexo.md的markdown文件。编辑该文件就可以写博客了。这里有一些Front-matter需要介绍，可以配置文章使用的模板、所属的分类和tag等。</p>
<p>Front-matter 是文件最上方以 —- 分隔的区域，用于指定个别文件的变量，举例来说：</p>
<pre><code>title: "使用Hexo在Github上搭建自己的博客"
date: 2015-03-10 22:30:04
tags:
<span class="bullet">- </span>Hexo
<span class="bullet">- </span>Github
categories:
<span class="header">- Hexo
---</span>
</code></pre><p>请注意，目前的categories只能有一个一级分类，如果填写多个，第二个会被解析为二级分类，以及类推。tags可以允许有多个。更多关于Front-matter请参考 <a href="http://hexo.io/zh-cn/docs/front-matter.html" target="_blank" rel="external">http://hexo.io/zh-cn/docs/front-matter.html</a></p>
<h1 id="发布到github_page">发布到github page</h1><p>首先你已经创建好了你的github page对应的git库，没有创建的可以google相关博客。然后新建一个hexo分支，存放你现在hexo的所有文件。然后执行如下命令清理并生成发布的静态站点文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo generate</span><br></pre></td></tr></table></figure>
<p>然后把生成的public目录下的文件放到你的master分支下即可。git commit后把这两个分支推送到你的github上。git库结构可以参见我的github page库 <a href="https://github.com/rujews/rujews.github.io" title="https://github.com/rujews/rujews.github.io" target="_blank" rel="external">https://github.com/rujews/rujews.github.io</a></p>
<h1 id="最后">最后</h1><p>然后等个几分钟，访问你的域名就可以看到你的网站了。如<a href="http://www.flysnow.org/" title="http://www.flysnow.org/" target="_blank" rel="external">http://www.flysnow.org/</a> 。关于更多的Hexo请参考官方文档，以后有时间也会介绍 <a href="http://hexo.io/zh-cn/docs/" target="_blank" rel="external">http://hexo.io/zh-cn/docs/</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>以前的博客是使用Jekyll托管在github上，后来用着越来越不方便，比如没有自动生成post，不能一键部署，文件结构和配置也是比较繁琐，更重要的是有时候用markdown写一篇文章，生成的静态文件很乱，应该是有些字符解析的问题。现在下决心换成了hexo</p>
<h1 ]]>
    </summary>
    
      <category term="Github" scheme="http://www.flysnow.org/tags/Github/"/>
    
      <category term="Hexo" scheme="http://www.flysnow.org/tags/Hexo/"/>
    
      <category term="Hexo" scheme="http://www.flysnow.org/categories/Hexo/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android Gradle插件中文指南]]></title>
    <link href="http://www.flysnow.org/2015/01/12/android-gradle-plugin-translate-done.html"/>
    <id>http://www.flysnow.org/2015/01/12/android-gradle-plugin-translate-done.html</id>
    <published>2015-01-12T07:33:16.000Z</published>
    <updated>2016-05-22T10:14:57.302Z</updated>
    <content type="html"><![CDATA[<p>最近想把Android项目从Eclipse迁到Android Studio上。原因呢，Eclipse太慢了，而且经常卡死，Android Studio由于Android的大力支持，已经有很多Eclipse没有的功能，比如AAR包，并且可以使用Gradle这个强大灵活的构建工具。</p>
<p>要迁入到Android Studio上，Gradle打包要搞懂，最近看了下Android Gradle插件指南，并且抽时间做了翻译，托管在github上。大家访问</p>
<p><a href="https://github.com/rujews/android-tech-docs/blob/master/new-build-system/user-guide/README.md" target="_blank" rel="external">https://github.com/rujews/android-tech-docs/blob/master/new-build-system/user-guide/README.md</a></p>
<p>随时查看，翻译错误的地方也请多指正。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近想把Android项目从Eclipse迁到Android Studio上。原因呢，Eclipse太慢了，而且经常卡死，Android Studio由于Android的大力支持，已经有很多Eclipse没有的功能，比如AAR包，并且可以使用Gradle这个强大灵活的构建工]]>
    </summary>
    
      <category term="Android" scheme="http://www.flysnow.org/tags/Android/"/>
    
      <category term="Gradle" scheme="http://www.flysnow.org/tags/Gradle/"/>
    
      <category term="翻译" scheme="http://www.flysnow.org/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="Android" scheme="http://www.flysnow.org/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[高效能程序员的修炼]]></title>
    <link href="http://www.flysnow.org/2014/07/13/effective-programming-more-than-writing-code.html"/>
    <id>http://www.flysnow.org/2014/07/13/effective-programming-more-than-writing-code.html</id>
    <published>2014-07-13T14:33:15.000Z</published>
    <updated>2016-05-22T10:14:57.302Z</updated>
    <content type="html"><![CDATA[<h2 id="入门须知">入门须知</h2><ul>
<li>你想成为一个程序员</li>
<li>程序员的八种境界</li>
<li>如何培养写作习惯</li>
</ul>
<h2 id="把一堆烂事搞定的艺术">把一堆烂事搞定的艺术</h2><ul>
<li>学海无边</li>
<li>磨刀不误砍柴工</li>
<li>一路向前冲</li>
<li>关于多任务的神话</li>
</ul>
<h2 id="高效编程之原则">高效编程之原则</h2><ul>
<li>第一条法则：永远都是你的错</li>
<li>大道至简</li>
<li>避免写注释</li>
<li>学会读源代码</li>
<li>像橡皮鸭求助</li>
<li>创新以人为本</li>
<li>你的团队能通过电梯测试吗</li>
<li>性能制胜</li>
</ul>
<h2 id="招聘程序员须得其法">招聘程序员须得其法</h2><ul>
<li>为什么程序员不会编程</li>
<li>怎样招聘程序员</li>
<li>如何做好电话面试筛选</li>
<li>工作经验数年之神话</li>
<li>与程序员面谈</li>
<li>史上最难的面试谜题</li>
</ul>
<h2 id="促使团队紧密协作">促使团队紧密协作</h2><ul>
<li>不管怎么说，那总是人的问题</li>
<li>领导需以身作则</li>
<li>程序员与系统管理员的黑夜传说</li>
<li>结对编程与代码评审</li>
<li>会议是浪费工作时间的最佳去处</li>
<li>处理坏苹果</li>
<li>坏苹果是团队的毒药</li>
<li>关于远程办公</li>
</ul>
<h2 id="蝙蝠洞：程序员的高效工作场所">蝙蝠洞：程序员的高效工作场所</h2><ul>
<li>程序员的《权利法案》</li>
<li>电脑工作站的人体工程学</li>
<li>多显示器能提高生产力吗</li>
<li>购置优质的电脑椅</li>
<li>背景光的功效</li>
</ul>
<h2 id="设计时要把用户放在心上">设计时要把用户放在心上</h2><ul>
<li>你永远不会有足够的奶酪</li>
<li>细节决定成败</li>
<li>用户界面代表了软件</li>
<li>用户界面须优先设计</li>
<li>分页显示该休矣</li>
<li>对待弱视的用户</li>
<li>再谈浏览器底栏</li>
<li>费茨定律与无限宽度</li>
<li>单元测试的终极失败</li>
<li>第一版做的不好，但照样发布</li>
</ul>
<h2 id="安全基础：保护用户数据">安全基础：保护用户数据</h2><ul>
<li>所有的网络通信都因该加密码</li>
<li>防范字典式攻击</li>
<li>快速哈希</li>
<li>关于网络密码的可怕真相</li>
</ul>
<h2 id="加强代码测试，别让它太差劲">加强代码测试，别让它太差劲</h2><ul>
<li>与客户患难与共</li>
<li>结交 “混世魔猴”</li>
<li>代码评审：说做就做</li>
<li>加大测试力度</li>
<li>我同情那些不写单元测试的傻瓜</li>
<li>单元测试与Beta测试的对比</li>
<li>低保真的可用性测试</li>
<li>比程序崩溃更糟糕的是什么</li>
</ul>
<h2 id="创建并管理社区，同时从中受益">创建并管理社区，同时从中受益</h2><ul>
<li>倾听社区的声音，但是别被它们牵着鼻子走</li>
<li>我重申：别盲目听从你的用户</li>
<li>游戏化</li>
<li>暂停、禁止、或者打入地狱</li>
</ul>
<h2 id="揭露营销伎俩，以及如何规避">揭露营销伎俩，以及如何规避</h2><ul>
<li>谨防九种营销诡计</li>
<li>网络广告该休矣</li>
<li>从《偷天情缘》看A/B测试的问题</li>
<li>如果流于俗套，请即刻改变</li>
<li>软件定价：我们深谙其道吗</li>
</ul>
<h2 id="轻重缓急，了然于心">轻重缓急，了然于心</h2><ul>
<li>程序员，你幸福吗</li>
<li>来也匆匆，去也匆匆，到头来两手空空</li>
</ul>
<h2 id="程序员必读之书">程序员必读之书</h2><ul>
<li>代码大全</li>
<li>人月神话</li>
<li>Don’t Make Me Think</li>
<li>快速软件开发</li>
<li>人件</li>
<li>设计心理学</li>
<li>About Face 3:交互设计精髓</li>
<li>交互设计之路—让高科技产品回归人性</li>
<li>GUI设计禁忌</li>
<li>编程珠玑</li>
<li>程序员修炼之道：从小工到专家</li>
<li>Web可用性设计</li>
<li>精通正则表达式</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="入门须知">入门须知</h2><ul>
<li>你想成为一个程序员</li>
<li>程序员的八种境界</li>
<li>如何培养写作习惯</li>
</ul>
<h2 id="把一堆烂事搞定的艺术">把一堆烂事搞定的艺术</h2><ul>
<li>学海无边</l]]>
    </summary>
    
      <category term="软件开发" scheme="http://www.flysnow.org/tags/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
      <category term="软件开发" scheme="http://www.flysnow.org/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[android新建大分辨率模拟器不能启动的问题]]></title>
    <link href="http://www.flysnow.org/2014/03/22/android-avd-not-launcher.html"/>
    <id>http://www.flysnow.org/2014/03/22/android-avd-not-launcher.html</id>
    <published>2014-03-22T05:29:02.000Z</published>
    <updated>2016-05-22T10:14:57.302Z</updated>
    <content type="html"><![CDATA[<p>新建的Android模拟器的分辨率超过一定大小的时候,就无法启动,比如超过1920<em>1080,就启动不了啦,更别说现在的2560</em>1440了.这时候只需要在新建AVD的时候,选择Use Host GPU选项然后即可正常启动..已经新建好的AVD也可以点击编辑,然后勾选Use Host GPU即可</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>新建的Android模拟器的分辨率超过一定大小的时候,就无法启动,比如超过1920<em>1080,就启动不了啦,更别说现在的2560</em>1440了.这时候只需要在新建AVD的时候,选择Use Host GPU选项然后即可正常启动..已经新建好的AVD也可以点击编辑,]]>
    </summary>
    
      <category term="Android" scheme="http://www.flysnow.org/tags/Android/"/>
    
      <category term="Android" scheme="http://www.flysnow.org/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[android覆盖式引导]]></title>
    <link href="http://www.flysnow.org/2014/02/20/android-overlay-guide.html"/>
    <id>http://www.flysnow.org/2014/02/20/android-overlay-guide.html</id>
    <published>2014-02-20T06:14:29.000Z</published>
    <updated>2016-05-22T10:14:57.302Z</updated>
    <content type="html"><![CDATA[<p>我们在开发产品的时候,每次发版可能会有一些新的功能需要引导用户使用,以前大部分都是使用截图,然后让设计师把引导的问题修饰好放到图上,现在这张图片就是引导图片,我们只需要用这张图片放到界面上,这样基本上就可以满足引导的作用.</p>
<p>但是这样的情况有个缺点,那就是,手机的分辨率太多,我们不可能每个分辨率都做一张图片,这样图片就会变形,有些引导操作的位置可能就不准确了,而且使用绘图的方式绘制在图片上的文字也会模糊不清.</p>
<p>基于如上的方式,我们可以使用另外一种方式来做引导,这样方式就是使用覆盖式的方式,主要的实现方式是</p>
<ol>
<li>使用一个透明并且全屏的PopuWindow,这样我们就有一个可以显示向导</li>
</ol>
<ol>
<li>获取需要引导的View元素在屏幕上的位置,这样我们就可以准确的给这个View绘制引导信息</li>
</ol>
<ol>
<li>然后让PopuWindow显示出来,这样就可以看到我们的引导正好指向需要引导的位置</li>
</ol>
<p>可以看下如下图的效果,这是实现的示例图.</p>
<p><a href="/uploads/2014/02/device-2014-02-20-213148.png"><img src="/uploads/2014/02/device-2014-02-20-213148-500x209.png" alt=""></a></p>
<p>可以看到,”查看帮助,了解更多”正好指向我们?图片操作按钮,位置很准确,文字也很清晰,并且这种方式实现的在所有分辨率上的手机上位置都是准确的,因为我们准确的获得了目标View的位置.</p>
<p>从上面的描述和效果图中我们也看到了一些关键点,比如全屏背景透明的PopuWindow,这个相信比较简单,宽高FILL_PARENT,背景设置为透明背景就好了.第二个就是目标View的位置,这个是比较难的,一般的引导我们都会在用户打开界面的时候显示,按说在Activity onCreate方法里调用最合适,但是这个时候我们的ContentVIew还没有测量绘制,所以我们根本不知道目标的位置.另外一个办法就是监听View层级的变化.</p>
<pre><code>ViewTreeObserver <span class="function">observer view.<span class="title">getViewTreeObserver</span><span class="params">()</span></span>;
observer.addOnGlobalLayoutListener(<span class="keyword">new</span> ViewTreeObserver.OnGlobalLayoutListener(){
    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onGlobalLayout</span><span class="params">()</span></span>{
    <span class="comment">//开始显示向导</span>
  }
});
</code></pre><p>注册监听后,就可以在收到通知后进行显示向导,这时候每个View都已经测量布局好,可以获得他们的准确位置,获取View在屏幕上的位置通过public void getLocationOnScreen (int[] location)获取其在屏幕上的位置.</p>
<p>获取到这些VIew的位置后,就需要显示我们的引导了,PopuWindow可以设置一个ContentView,我们可以AbsoluteLayout作为ContentView,在这里绝对布局是最好的选择,因为我们获取的目标View的位置都是绝对的,所以使用绝对位置,通过x,y坐标就可以确定引导的位置.</p>
<p>接下来的事情就简单了,我们只需要显示PopuWindow就可以啦,然后控制好事件,比如用户点击的时候收起该引导,让用户继续正常使用产品.引导不能无休止的显示,我们可以通过配置来控制引导是否显示以及显示的次数等等.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>我们在开发产品的时候,每次发版可能会有一些新的功能需要引导用户使用,以前大部分都是使用截图,然后让设计师把引导的问题修饰好放到图上,现在这张图片就是引导图片,我们只需要用这张图片放到界面上,这样基本上就可以满足引导的作用.</p>
<p>但是这样的情况有个缺点,那就是,手机]]>
    </summary>
    
      <category term="Android" scheme="http://www.flysnow.org/tags/Android/"/>
    
      <category term="Android" scheme="http://www.flysnow.org/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用Nginx搭建PHP服务器]]></title>
    <link href="http://www.flysnow.org/2013/12/27/linux-php-server-with-nginx.html"/>
    <id>http://www.flysnow.org/2013/12/27/linux-php-server-with-nginx.html</id>
    <published>2013-12-27T04:59:13.000Z</published>
    <updated>2016-05-22T10:14:57.302Z</updated>
    <content type="html"><![CDATA[<p>一般我们都是采用Apache 作为PHP的解析服务器，这次则是采用Nginx这个强大的反向代理服务器来搭建PHP服务器。下面就以Linux发行版Ubuntu为例搭建一个Nginx的PHP服务器。</p>
<p>首先下载安装Nginx</p>
<pre><code>sudo apt-<span class="keyword">get</span> install nginx
</code></pre><p>安装完成后，启动Nginx</p>
<pre><code>sudo /etc/init.d/nginx <span class="built_in">start</span>
</code></pre><p>这时候打开浏览器里输入<a href="http://localhost/就可以看到Welcome" target="_blank" rel="external">http://localhost/就可以看到Welcome</a> to nginx!的页面了，说明我们的Nginx服务器安装成功</p>
<p>接下来安装PHP5</p>
<pre><code>sudo apt-<span class="keyword">get</span> install php5-fpm
</code></pre><p>安装成功后，我们要修改Nginx的虚拟机配置，让浏览器请求的php文件可以被php cgi解析。编辑Nginx虚拟机配置文件/etc/nginx/sites-available/default</p>
<pre><code>sudo vim <span class="regexp">/etc/</span>nginx<span class="regexp">/sites-available/</span><span class="keyword">default</span>
</code></pre><p>然后把里面的配置修改为如下配置内容：</p>
<pre><code><span class="comment"># You may add here your</span>
<span class="comment"># server {</span>
<span class="comment">#    ...</span>
<span class="comment"># }</span>
<span class="comment"># statements for each of your virtual hosts to this file</span>

<span class="comment">##</span>
<span class="comment"># You should look at the following URL's in order to grasp a solid understanding</span>
<span class="comment"># of Nginx configuration files in order to fully unleash the power of Nginx.</span>
<span class="comment"># http://wiki.nginx.org/Pitfalls</span>
<span class="comment"># http://wiki.nginx.org/QuickStart</span>
<span class="comment"># http://wiki.nginx.org/Configuration</span>
<span class="comment">#</span>
<span class="comment"># Generally, you will want to move this file somewhere, and start with a clean</span>
<span class="comment"># file but keep this around for reference. Or just disable in sites-enabled.</span>
<span class="comment">#</span>
<span class="comment"># Please see /usr/share/doc/nginx-doc/examples/ for more detailed examples.</span>
<span class="comment">##</span>

<span class="title">server</span> {
    <span class="title">listen</span>   <span class="number">80</span>; <span class="comment">## listen for ipv4; this line is default and implied</span>
    <span class="comment">#listen   [::]:80 default ipv6only=on; ## listen for ipv6</span>

    <span class="title">root</span> /usr/share/nginx/www;
    <span class="title">index</span> index.html index.htm index.php;

    <span class="comment"># Make site accessible from http://localhost/</span>
    <span class="title">server_name</span> localhost;

    <span class="title">location</span> / {
        <span class="comment"># First attempt to serve request as file, then</span>
        <span class="comment"># as directory, then fall back to index.html</span>
        <span class="title">try_files</span> <span class="variable">$uri</span> <span class="variable">$uri</span>/ /index.html;
        <span class="comment"># Uncomment to enable naxsi on this location</span>
        <span class="comment"># include /etc/nginx/naxsi.rules</span>
    }

    <span class="title">location</span> /doc/ {
        <span class="title">alias</span> /usr/share/doc/;
        <span class="title">autoindex</span> <span class="built_in">on</span>;
        <span class="title">allow</span> <span class="number">127.0.0.1</span>;
        <span class="title">deny</span> all;
    }

    <span class="comment"># Only for nginx-naxsi : process denied requests</span>
    <span class="comment">#location /RequestDenied {</span>
        <span class="comment"># For example, return an error code</span>
        <span class="comment">#return 418;</span>
    <span class="comment"># }</span>

    <span class="title">error_page</span> <span class="number">404</span> /<span class="number">404</span>.html;

    <span class="comment"># redirect server error pages to the static page /50x.html</span>
    <span class="comment">#</span>
    <span class="title">error_page</span> <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span> /50x.html;
    <span class="title">location</span> = /50x.html {
        <span class="title">root</span> /usr/share/nginx/www;
    }

    <span class="comment"># pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span>
    <span class="comment">#</span>
    <span class="title">location</span> <span class="regexp">~ \.php$</span> {
        <span class="title">fastcgi_split_path_info</span><span class="regexp"> ^(.+\.php)(/.+)$</span>;
        <span class="comment"># NOTE: You should have "cgi.fix_pathinfo = 0;" in php.ini</span>

        <span class="comment"># With php5-cgi alone:</span>
        <span class="title">fastcgi_pass</span> <span class="number">127.0.0.1:9000</span>;
        <span class="comment"># With php5-fpm:</span>
        <span class="comment">#fastcgi_pass unix:/var/run/php5-fpm.sock;</span>
        <span class="title">fastcgi_index</span> index.php;
        <span class="title">include</span> fastcgi_params;
    }

    <span class="comment"># deny access to .htaccess files, if Apache's document root</span>
    <span class="comment"># concurs with nginx's one</span>
    <span class="comment">#</span>
    <span class="title">location</span> <span class="regexp">~ /\.ht</span> {
        <span class="title">deny</span> all;
    }
}

<span class="comment"># another virtual host using mix of IP-, name-, and port-based configuration</span>
<span class="comment">#</span>
<span class="comment">#server {</span>
<span class="comment">#    listen 8000;</span>
<span class="comment">#    listen somename:8080;</span>
<span class="comment">#    server_name somename alias another.alias;</span>
<span class="comment">#    root html;</span>
<span class="comment">#    index index.html index.htm;</span>
<span class="comment">#</span>
<span class="comment">#    location / {</span>
<span class="comment">#        try_files $uri $uri/ /index.html;</span>
<span class="comment">#    }</span>
<span class="comment"># }</span>

<span class="comment"># HTTPS server</span>
<span class="comment">#</span>
<span class="comment">#server {</span>
<span class="comment">#    listen 443;</span>
<span class="comment">#    server_name localhost;</span>
<span class="comment">#</span>
<span class="comment">#    root html;</span>
<span class="comment">#    index index.html index.htm;</span>
<span class="comment">#</span>
<span class="comment">#    ssl on;</span>
<span class="comment">#    ssl_certificate cert.pem;</span>
<span class="comment">#    ssl_certificate_key cert.key;</span>
<span class="comment">#</span>
<span class="comment">#    ssl_session_timeout 5m;</span>
<span class="comment">#</span>
<span class="comment">#    ssl_protocols SSLv3 TLSv1;</span>
<span class="comment">#    ssl_ciphers ALL:!ADH:!EXPORT56:RC4+RSA:+HIGH:+MEDIUM:+LOW:+SSLv3:+EXP;</span>
<span class="comment">#    ssl_prefer_server_ciphers on;</span>
<span class="comment">#</span>
<span class="comment">#    location / {</span>
<span class="comment">#        try_files $uri $uri/ /index.html;</span>
<span class="comment">#    }</span>
<span class="comment"># }</span>
</code></pre><p>重新加载我们刚刚更改的Nginx配置</p>
<pre><code>sudo <span class="regexp">/etc/i</span>nit.d<span class="regexp">/nginx reload</span>
</code></pre><p>然后我们在/usr/share/nginx/www/目录下新建一个phpinfo.php文件，可以查看php的配置和环境信息</p>
<pre><code>sudo vim <span class="regexp">/usr/</span>share<span class="regexp">/nginx/</span>www<span class="regexp">/phpinfo.php</span>
</code></pre><p>在phpinfo.php中录入如下内容:</p>
<pre><code><span class="php"><span class="preprocessor">&lt;?php</span>
  phpinfo();
<span class="preprocessor">?&gt;</span></span>
</code></pre><p>我们在浏览器里输入<a href="http://localhost/phpinfo.php就可以看到PHP的信息页了，有版本等信息。" target="_blank" rel="external">http://localhost/phpinfo.php就可以看到PHP的信息页了，有版本等信息。</a></p>
<p>PHP5还有很多支持的模块，如果需要的话可以选择安装，一般这些模块都是php5-开头，比如php5-mysql，在Ubuntu里安装他只需</p>
<pre><code>sudo apt-<span class="keyword">get</span> install php5-mysql
</code></pre><p>PHP的模块安装后别忘记重启PHP5哦，执行如下命令可以重启</p>
<pre><code>sudo <span class="regexp">/etc/i</span>nit.d<span class="regexp">/php5-fpm restart</span>
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>一般我们都是采用Apache 作为PHP的解析服务器，这次则是采用Nginx这个强大的反向代理服务器来搭建PHP服务器。下面就以Linux发行版Ubuntu为例搭建一个Nginx的PHP服务器。</p>
<p>首先下载安装Nginx</p>
<pre><code>sudo ]]>
    </summary>
    
      <category term="Apache" scheme="http://www.flysnow.org/tags/Apache/"/>
    
      <category term="Linux" scheme="http://www.flysnow.org/tags/Linux/"/>
    
      <category term="Nginx" scheme="http://www.flysnow.org/tags/Nginx/"/>
    
      <category term="PHP" scheme="http://www.flysnow.org/tags/PHP/"/>
    
      <category term="Ubuntu" scheme="http://www.flysnow.org/tags/Ubuntu/"/>
    
      <category term="Linux" scheme="http://www.flysnow.org/categories/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android产品开发中常用的一些开源项目]]></title>
    <link href="http://www.flysnow.org/2013/12/14/open-source-project-in-android-app.html"/>
    <id>http://www.flysnow.org/2013/12/14/open-source-project-in-android-app.html</id>
    <published>2013-12-14T07:35:36.000Z</published>
    <updated>2016-05-22T10:14:57.302Z</updated>
    <content type="html"><![CDATA[<p>你在工作中可能会遇到同时给你说不要重复发明轮子，其实这个说的就是第一：不要做重复的事情，第二：站在巨人的肩膀上。现在有了互联网以及开源的精神，我们的很多在产品中需要实现的功能组件都可以在互联网上找到，我们可以直接拿来用，这样我们就不用重复做东西了，这得益于开源奉献精神。像Google、Facebook这类的大公司都在使用很多的开源产品，比如我们常见的Apache系列、我们使用的Eclipse IDE等等。</p>
<p>在我自己的产品开发中，我也使用到了一些常用的开源项目，下面就介绍一下我使用的一些Android开源项目。</p>
<h3 id="1-android-wheel">1.android-wheel</h3><p>还记得iPhone上经典的日期选择滑轮组件吗?这个就是android版本的实现，记得当时这种选择方式很风靡，可以用于时间、分类等一些具有选择类型功能的开发实现，非常方便。</p>
<p>开源项目地址：<a href="https://code.google.com/p/android-wheel/" target="_blank" rel="external">https://code.google.com/p/android-wheel/</a></p>
<h3 id="2-achartengine"><a href="/uploads/2013/12/android-wheel-cities.png"><img src="/uploads/2013/12/android-wheel-cities.png" alt="android-wheel-cities"></a>2.achartengine</h3><p>这个是android上用于报表类的组件，可以实现条形图、饼图、柱状图、折线图等等。可以在产品中用于一些报表统计类的功能，通过这些图形报表给用户一个直观的统计，比如用户的收支走势图、分类支出对比图等等。</p>
<p>开源项目地址：<a href="https://code.google.com/p/achartengine/" target="_blank" rel="external">https://code.google.com/p/achartengine/</a></p>
<h3 id="3-Satellite_Menu"><a href="/uploads/2013/12/android-wheel-cities.png"><img src="/uploads/2013/12/android-wheel-cities.png" alt="android-wheel-cities"></a> <a href="/uploads/2013/12/combined_chart.png"><img src="/uploads/2013/12/combined_chart-300x500.png" alt="combined_chart"></a>3.Satellite Menu</h3><p>还记得Path的弧形弹出式菜单吗？当时太风靡了，大家都在抄啊，一时间市场上所有的App的功能和菜单键全被这个设计代替了。不多说，给出地址。</p>
<p>开源项目地址：<a href="https://github.com/siyamed/android-satellite-menu" target="_blank" rel="external">https://github.com/siyamed/android-satellite-menu</a></p>
<h3 id="4-drag-sort-listview"><a href="/uploads/2013/12/687474703a2f2f692e696d6775722e636f6d2f3049676b6b74642e706e67.png"><img src="/uploads/2013/12/687474703a2f2f692e696d6775722e636f6d2f3049676b6b74642e706e67-489x500.png" alt="687474703a2f2f692e696d6775722e636f6d2f3049676b6b74642e706e67"></a>4.drag-sort-listview</h3><p>Android产品中ListView相信大家都用的不少，用于展示用户的数据是很不错的，不过有的时候用户需要调整一下列表项的顺序，比如用户想把好听的因为放在上面，便于选择，这时候这个组件就派上用场了，可以让用户拖动着某一项进行上下排序。</p>
<p>开源项目地址：<a href="https://github.com/bauerca/drag-sort-listview" target="_blank" rel="external">https://github.com/bauerca/drag-sort-listview</a></p>
<h3 id="5-SlidingMenu">5.SlidingMenu</h3><p>不知道从什么时候起侧滑又成了App设计的一个风向标，一时间全是侧滑啊，就是感觉不用侧滑这个产品就不好意思发布似的。这是一个非常经典的侧滑开源项目，都多种方式、可以灵活配置和定制。</p>
<p>开源项目地址：<a href="https://github.com/jfeinstein10/SlidingMenu" target="_blank" rel="external">https://github.com/jfeinstein10/SlidingMenu</a></p>
<h3 id="6-NineOldAndroids"><a href="/uploads/2013/12/2012110712582439.png"><img src="/uploads/2013/12/2012110712582439.png" alt="2012110712582439"></a>6.NineOldAndroids</h3><p>Android3.0增加了一套属性动画的框架，让开发者能更容易的完成更复杂的动画，但是为了兼容低版本的手机，我们又不能把应用升级到Android3.0,不过幸好有NineOldAndroids，我们可以在低系统版本的手机上也可以使用属性动画</p>
<p>开源项目地址：<a href="https://github.com/JakeWharton/NineOldAndroids" target="_blank" rel="external">https://github.com/JakeWharton/NineOldAndroids</a></p>
<h3 id="7-Android-PullToRefresh">7.Android-PullToRefresh</h3><p>下拉列表刷新，上拉加载，下拉。。。，上下拉可以做很多事情，上下拉又成了时髦的设计。这是一个非常NB的组件，可以把任何View变成具有可上下拉功能的View，并且不会对原来的View造成污染。</p>
<p>开源项目地址：<a href="https://github.com/chrisbanes/Android-PullToRefresh" target="_blank" rel="external">https://github.com/chrisbanes/Android-PullToRefresh</a></p>
<h3 id="8-ActionBarSherlock"><a href="/uploads/2013/12/header_graphic.png"><img src="/uploads/2013/12/header_graphic-500x254.png" alt="header_graphic"></a>8.ActionBarSherlock</h3><p>从 Android3.0开始增加了ActionBar，它能帮助开发者定制菜单，导航等，非常方便，但是低版本的用不了，所以ActionBarSherlock就出世了，它能让我们在低版本的手机上也可以使用ActionBar</p>
<p>开源项目地址：<a href="https://github.com/JakeWharton/ActionBarSherlock" target="_blank" rel="external">https://github.com/JakeWharton/ActionBarSherlock</a></p>
<p><a href="/uploads/2013/12/687474703a2f2f616374696f6e626172736865726c6f636b2e636f6d2f7374617469632f666561747572652e706e67.png"><img src="/uploads/2013/12/687474703a2f2f616374696f6e626172736865726c6f636b2e636f6d2f7374617469632f666561747572652e706e67-500x236.png" alt="687474703a2f2f616374696f6e626172736865726c6f636b2e636f6d2f7374617469632f666561747572652e706e67"></a></p>
<p>开源项目林林总总很多，今天说的都是我常用的，多去一些注入GitHub，GoogleCode等网站，可以发现很多开源的优秀项目，这些我们可以先了解收集起来，等我们产品中有类似的功能了，可以拿来使用，帮你更快的完成工作。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>你在工作中可能会遇到同时给你说不要重复发明轮子，其实这个说的就是第一：不要做重复的事情，第二：站在巨人的肩膀上。现在有了互联网以及开源的精神，我们的很多在产品中需要实现的功能组件都可以在互联网上找到，我们可以直接拿来用，这样我们就不用重复做东西了，这得益于开源奉献精神。像G]]>
    </summary>
    
      <category term="Android" scheme="http://www.flysnow.org/tags/Android/"/>
    
      <category term="开源" scheme="http://www.flysnow.org/tags/%E5%BC%80%E6%BA%90/"/>
    
      <category term="Android" scheme="http://www.flysnow.org/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android HttpClient Session保持]]></title>
    <link href="http://www.flysnow.org/2013/11/21/android-httpclitent-session-keep.html"/>
    <id>http://www.flysnow.org/2013/11/21/android-httpclitent-session-keep.html</id>
    <published>2013-11-21T06:39:11.000Z</published>
    <updated>2016-05-22T10:14:57.302Z</updated>
    <content type="html"><![CDATA[<p>现在单机版本的App已经不多了，基本上都会和服务器进行通信。Android提供Http访问的方式有两种，一种是HttpClient，一种是UrlConnection.这里要说的是HttpClient。</p>
<p>在Http访问中，我们可能会遇到一些这样的场景，比如服务端要求几次Http请求组成一次完整的客户端服务器通信，比如同步。现在的App很多有有账号系统，会提供把用户数据备份的功能，那么这么在线备份功能就是这样的一个场景，它包括登陆、数据上传，结果返回、提交确认或者终止等这样的顺序步骤，每一步都是一次Http访问请求。服务器的设计(负载均衡等)需要要求客户端在这依次完整的数据备份的几次Http访问请求中保持同一个Session.便于服务器的协调和操作，就和用户用浏览器打开网页去完整一件事情一样，这就需要我们在每次Http请求的时候保持Session。</p>
<p>其实保持HttpClient的请求Session，就是保证在每次Http请求访问的请求头信息的Cookie参数中，携带同一个JSESSIONID，只要保证每次是一样的，服务器就认为是同一Session，这就保持了Seesion会话。那么这个JSESSIONID是怎么来的呢，是服务器通过响应头信息给的，服务器在给客户端设置Cookie时，会通过响应头信息中的Set-Cookie参数传递回来，只要有新设置的Cookie，就是通过这个传递过来，如果没有则是null，那么我们就可以在请求完之后返回的信息里读取这个Set-Cookie头信息，然后保存起来，在下次请求的时候给服务器发送过去，就实现了保持Seesion的目的。代码如下：</p>
<pre><code><span class="comment">//定义储存Cookie信息</span>
<span class="keyword">private</span> String cookies;

<span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">executeGet</span><span class="params">(String url)</span> <span class="keyword">throws</span> ClientProtocolException, IOException</span>{
    HttpClient httpClient=<span class="keyword">new</span> DefaultHttpClient();

    HttpGet httpGet=<span class="keyword">new</span> HttpGet(url);
    setRequestCookies(httpGet);

    HttpResponse response=httpClient.execute(httpGet);
    appendCookies(response);
}
<span class="javadoc">/**
 * 设置请求的Cookie头信息
 *<span class="javadoctag"> @param</span> reqMsg
 */</span>
<span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">setRequestCookies</span><span class="params">(HttpMessage reqMsg)</span> </span>{
    <span class="keyword">if</span>(!TextUtils.isEmpty(cookies)){
        reqMsg.setHeader(<span class="string">"Cookie"</span>, cookies);
    }
}
<span class="javadoc">/**
 * 把新的Cookie头信息附加到旧的Cookie后面
 * 用于下次Http请求发送
 *<span class="javadoctag"> @param</span> resMsg
 */</span>
<span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">appendCookies</span><span class="params">(HttpMessage resMsg)</span> </span>{
    Header setCookieHeader=resMsg.getFirstHeader(<span class="string">"Set-Cookie"</span>);
    <span class="keyword">if</span> (setCookieHeader != <span class="keyword">null</span>
            &amp;&amp; TextUtils.isEmpty(setCookieHeader.getValue())) {
        String setCookie=setCookieHeader.getValue();
        <span class="keyword">if</span>(TextUtils.isEmpty(cookies)){
            cookies=setCookie;
        }<span class="keyword">else</span>{
            cookies=cookies+<span class="string">"; "</span>+setCookie;
        }
    }
}
</code></pre><p>上面的代码就是一个简单的例子，我们在发送我们的请求之前，把现存的Cookie通过请求头信息发送给服务器，然后再服务器返回的头信息中解析，看是否有需要的更新的Cookie即可，这样我们就达到了保持Seession目的。</p>
<p>当我们需要重新设置Seesion的时候，请求我们保存的cookie即可，这样代码就会重新获取。如果都有个账号并发备份，那么一个账号分配一个cookie变量存储即可，也就是把上面的代码放到一个如HttpManager管理的类里，每个账号的备份都可以new个HttpManager实例，这样每个账号都可以单独处理自己的Cookie，互不干扰。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>现在单机版本的App已经不多了，基本上都会和服务器进行通信。Android提供Http访问的方式有两种，一种是HttpClient，一种是UrlConnection.这里要说的是HttpClient。</p>
<p>在Http访问中，我们可能会遇到一些这样的场景，比如服务端]]>
    </summary>
    
      <category term="Android" scheme="http://www.flysnow.org/tags/Android/"/>
    
      <category term="Http" scheme="http://www.flysnow.org/tags/Http/"/>
    
      <category term="HttpClitent" scheme="http://www.flysnow.org/tags/HttpClitent/"/>
    
      <category term="Android" scheme="http://www.flysnow.org/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[goagent 403  not have permiss]]></title>
    <link href="http://www.flysnow.org/2013/11/07/goagent-403-not-have-permiss.html"/>
    <id>http://www.flysnow.org/2013/11/07/goagent-403-not-have-permiss.html</id>
    <published>2013-11-07T06:48:52.000Z</published>
    <updated>2016-05-22T10:14:57.302Z</updated>
    <content type="html"><![CDATA[<p>今天上班，像往常一样打开Google，咦，竟然提示</p>
<blockquote>403. That’s an error.<br>Your client does not have permission to get URL /2 from this server. That’s all we know.</blockquote>


<p>奇怪了，因为我使用goagent翻墙上网，第一反应就是又被禁了。赶紧去<a href="https://code.google.com/p/goagent/" target="_blank" rel="external">goagent网站</a>去看，发现好多人反馈这个bug。看了一圈，发现有人给出了解决办法，修改goagent客户端中的proxy.ini里的profile 为 google_hk，以前的默认配置是profile = google_cn，现在改成profile = google_hk就好了。也就是换个配置。。改了后重启goagent，发现果然好了。。继续使用。</p>
<p>刚刚又去Goagent网站，发现发布了一则公布，这个倒没留意是什么时候发布的。公告如下</p>
<ol>
<li>403 情况请改成 profile = google_hk 或者更新到最新版(不需要上传服务端也可用） [2013-11-07 19:25 更新]。</li>
</ol>
<ol>
<li>速度慢的话，建议重新部署并使用新的 appid</li>
</ol>
<p>goagent是个好东西，翻墙必备，还可以看youtube视频，喜欢的朋友可以参考官网教程架设<a href="https://code.google.com/p/goagent/wiki/InstallGuide" target="_blank" rel="external">https://code.google.com/p/goagent/wiki/InstallGuide</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>今天上班，像往常一样打开Google，咦，竟然提示</p>
<blockquote>403. That’s an error.<br>Your client does not have permission to get URL /2 from this server. T]]>
    </summary>
    
      <category term="goagent" scheme="http://www.flysnow.org/tags/goagent/"/>
    
      <category term="代理" scheme="http://www.flysnow.org/tags/%E4%BB%A3%E7%90%86/"/>
    
      <category term="翻墙" scheme="http://www.flysnow.org/tags/%E7%BF%BB%E5%A2%99/"/>
    
      <category term="Linux" scheme="http://www.flysnow.org/categories/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[java.lang.UnsupportedOperationException android.view.GLES20Canvas.clipPath]]></title>
    <link href="http://www.flysnow.org/2013/11/07/unsupportedoperationexception-gles20canvas-clippath.html"/>
    <id>http://www.flysnow.org/2013/11/07/unsupportedoperationexception-gles20canvas-clippath.html</id>
    <published>2013-11-07T06:27:21.000Z</published>
    <updated>2016-05-22T10:14:57.302Z</updated>
    <content type="html"><![CDATA[<p>今天自定义控件使用Canvas绘图的时候遇到的这个错误，看错误的描述，是不支持这个clipPath方法的。而且在2.3的机器上没有问题，是一部4.0的机器报了这个问题。查看这个Canvas的子类实现GLES20Canvas，发现这是在开启硬件加速时使用的。看来还是和硬件加速有关。打开手机的开发者选项，发现硬件加速没有被开启，应用里也没有开启，有点奇怪了，可能是手机优化自动开启了硬件加速。</p>
<p>硬件加速这个特性是从API 11加入的，可以大大加快View的绘制，是个很不错的功能，所以我们不可能在我们的程序里直接关闭这个功能这样我们的应用就使用不了这个特性了，所以在Application标签里设置android:hardwareAccelerated=”false’不可行。所以可以在用到这个自定义View里的Activity里使用android:hardwareAccelerated=“false”来配置，这样其他的Activity可以继续使用同步加速的特性。不过你的自定义View用到的地方比较多，一个个Activity配置也不太方便，所以最好的办法是在你的自定义View里禁用View级别的硬件加速。可以通过以下代码来实现</p>
<pre><code><span class="keyword">if</span><span class="comment">(Build.VERSION.SDK_INT&gt;=Build.VERSION_CODES.HONEYCOMB)</span>{<span class="comment">//API 11及其之上</span>
    setLayerType<span class="comment">(LAYER_TYPE_SOFTWARE,null)</span>;<span class="comment">//禁用硬件加速</span>
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>今天自定义控件使用Canvas绘图的时候遇到的这个错误，看错误的描述，是不支持这个clipPath方法的。而且在2.3的机器上没有问题，是一部4.0的机器报了这个问题。查看这个Canvas的子类实现GLES20Canvas，发现这是在开启硬件加速时使用的。看来还是和硬件加速]]>
    </summary>
    
      <category term="API" scheme="http://www.flysnow.org/tags/API/"/>
    
      <category term="Android" scheme="http://www.flysnow.org/tags/Android/"/>
    
      <category term="Widget" scheme="http://www.flysnow.org/tags/Widget/"/>
    
      <category term="Android" scheme="http://www.flysnow.org/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用AlarmManager设置的定时服务在Android4.4上可能不准确了]]></title>
    <link href="http://www.flysnow.org/2013/11/02/android-4-4-alarm-manager-changed.html"/>
    <id>http://www.flysnow.org/2013/11/02/android-4-4-alarm-manager-changed.html</id>
    <published>2013-11-02T07:46:47.000Z</published>
    <updated>2016-05-22T10:14:57.302Z</updated>
    <content type="html"><![CDATA[<p>Android4.4在前天发布了，随着Android4.4的源代码的放出，相信会有更多的手机会慢慢的升级到Android4.4,作为苦逼的Android开发人员，我们需要保证我们的应用在Android4.4的兼容性，也就是可用性。现在这里就有一个比较大的更新会影响到我们的应用功能，他就是AlarmManager。</p>
<p>Android宣称为了电源的使用效率，在Android4.4上位所有应用的Alarm服务使用批量启动的方式来处理相似的时间以激活设备。</p>
<p>以前呢，是set一个Alarm，系统在到点的时候给你单独一个去激活设备启动你设置的服务;现在呢，不是这样了，而是按批的啦，一批激活那个时间点周围设置的差不多的Tigger Time的Alarm，比如你以前设置的是18：00准备自动备份数据，现在手机正好在18：05进行了一次批量的Alarm启动操作，而你设置的Alarm正好在这个时间点周围，那么你的Alarm也被启动了，比你预想的晚了5分钟。</p>
<p>很多人想，这太不合理了啊，那我们根本就没有使用到Android4.4的新东西，只是用户的手机是Android4.4的系统，不能这么武断的就这么处理吧。所以Android还是给了我们兼容的方案的，只要你的App的targetSdkVersion<19,那么你以前设置的alarm时间还是精准的，和以前一样使用。如果你想使用android4.4及其以后版本的新功能，必须把targetsdkversion设置成>=19,而又想要求Alarm的设置精准，那么怎么办呢，Android在4.4给我们提供了新的方法setExact来设置精准的时间。</19,那么你以前设置的alarm时间还是精准的，和以前一样使用。如果你想使用android4.4及其以后版本的新功能，必须把targetsdkversion设置成></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Android4.4在前天发布了，随着Android4.4的源代码的放出，相信会有更多的手机会慢慢的升级到Android4.4,作为苦逼的Android开发人员，我们需要保证我们的应用在Android4.4的兼容性，也就是可用性。现在这里就有一个比较大的更新会影响到我们的应]]>
    </summary>
    
      <category term="API" scheme="http://www.flysnow.org/tags/API/"/>
    
      <category term="Android" scheme="http://www.flysnow.org/tags/Android/"/>
    
      <category term="Android" scheme="http://www.flysnow.org/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android布尔型配置存储优化]]></title>
    <link href="http://www.flysnow.org/2013/10/11/android-bool-preferences-storage-optimization.html"/>
    <id>http://www.flysnow.org/2013/10/11/android-bool-preferences-storage-optimization.html</id>
    <published>2013-10-10T21:23:02.000Z</published>
    <updated>2016-05-22T10:14:57.302Z</updated>
    <content type="html"><![CDATA[<p>在Android开发的过程中，我们基本上都会遇到是否开启自动备份、是否保存账号、是否自动登陆、是否开启向导等这样的选项功能，对于这类功能，我们一般的做法是采用SharedPreferences类存储Boolean类型的配置文件来实现，比如是否第一次打开，我们会使用SharedPreferences存储Key为firset_time_open的Boolean值，在使用的时候我们取出该值进行判断即可。那么这么做有什么问题呢？问题就在于随着我们的Android产品越来越大，越来越复杂，你会发现我们使用了很多个这样的Boolean类型的配置，每一个配置对应一个key，会有很多个key值声明，并且存储的xml文件中也会有很多个bool的节点来保存我们的配置，这样一来我们会不太好维护，二来xml存储文件会越来越大，读写操作速度就会降低。</p>
<p>其实Boolean值对于计算机来说就是0或者1,所以我们储存的boolean值就可以用位来表示，0代表false，1代表true。这样一个Long型的值就可以表示63个Boolean类型值的存储，而如果使用Boolean就需要63个Key，使用Long存储只需要1个Key就可以搞定。下面让我们看下Long最大值的二进制表示：</p>
<pre><code><span class="comment">//最高位表示正负</span>
<span class="number">0111111111111111</span> <span class="number">1111111111111111</span>
<span class="number">1111111111111111</span> <span class="number">1111111111111111</span>
</code></pre><p>每一位无非是0或者1,也就是我们的false或者true，那么只要我们规定好每一位表示的是什么含义就好了。比如第1位表示是否是第一次打开，第2位表示是否保存账号，这样在使用的时候，我们只需获取这个存储的Long值，然后看下它的第1位是0还是1就可以知道用户是不是第一次打开了，同理通过第2位是0还是1也可以知道用户是不是选择了保存账号。以此类推，你可以位3-63位定义不同的含义来实现产品中的功能。</p>
<p>通过上面的分析，大家应该都已经了解了原理，也可能会看出关键的地方，就是我们怎么样设置每一位的值而又可以保证其他位的值不变呢，这是个关键。比如我们设置保存账号位true，那么你在设置的时候不能改变第1位是否第一次开发的值。想要实现这个功能，首先要设置好一个掩码(Mask),每一位都有自己的掩码，然后通过与或非操作来设置每一位的true或者false。这个掩码的规则就是：需要改变的那一位是1,其他位都0,这样才好进行设置等操作，比如第1位是否第一次打开和第2位是否保存账号的掩码就是：</p>
<pre><code><span class="comment">//第1位是否第一次打开掩码</span>
<span class="number">0000000000000000</span> <span class="number">0000000000000000</span> 
<span class="number">0000000000000000</span> <span class="number">0000000000000001</span>

<span class="comment">//第2位是否保存账号掩码</span>
<span class="number">0000000000000000</span> <span class="number">0000000000000000</span> 
<span class="number">0000000000000000</span> <span class="number">0000000000000010</span>




    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> MASK_FIRST_TIME_OPEN=<span class="number">1</span>;
    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> MASK_SAVE_ACCOUNT=<span class="number">1</span>&lt;&lt;<span class="number">1</span>;
    <span class="comment">//etc &lt;&lt;2\&lt;&lt;3.....&lt;&lt;62;</span>
</code></pre><p>这样我们设置第1位为1的时候只需要让第1位的掩码和当前值进行或(|)操作即可，设置第1位为0的时候只需要把第1位先取反(~)然后和当前值进行与(&amp;)操作即可：</p>
<pre><code><span class="comment">//设置第1位位1,或操作(|)</span>
<span class="number">0000000000000000</span> <span class="number">0000000000000000</span> 
<span class="number">0000000000000000</span> <span class="number">0000000000000001</span>
                                |<span class="comment">//或</span>
<span class="number">0000000000000000</span> <span class="number">0000000000000000</span> 
<span class="number">0000000000000000</span> <span class="number">0100000100000000</span>
                                =<span class="comment">//等于</span>
<span class="number">0000000000000000</span> <span class="number">0000000000000000</span> 
<span class="number">0000000000000000</span> <span class="number">0100000100000001</span>

<span class="comment">//设置第1位位0,掩码取反(~)后与操作(&amp;)</span>
<span class="number">0000000000000000</span> <span class="number">0000000000000000</span> 
<span class="number">0000000000000000</span> <span class="number">0000000000000001</span>
                                ~<span class="comment">//取反</span>
                                =<span class="comment">//等于</span>
<span class="number">1111111111111111</span> <span class="number">1111111111111111</span> 
<span class="number">1111111111111111</span> <span class="number">1111111111111110</span>
                                &amp;<span class="comment">//与操作</span>
<span class="number">0000000000000000</span> <span class="number">0000000000000000</span> 
<span class="number">0000000000000000</span> <span class="number">0100000100000000</span>
                                =<span class="comment">//等于</span>
<span class="number">0000000000000000</span> <span class="number">0000000000000000</span> 
<span class="number">0000000000000000</span> <span class="number">0100000100000000</span>




    <span class="javadoc">/**
     * 是否第一次打开
     *<span class="javadoctag"> @return</span>
     */</span>
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">boolean</span> <span class="title">isFirstTime</span><span class="params">()</span></span>{
        <span class="keyword">return</span> (getBooleanOneGroup()&amp;MASK_FIRST_TIME_OPEN)!=<span class="number">0</span>;
    }
    <span class="javadoc">/**
     * 设置是否第一次打开
     *<span class="javadoctag"> @param</span> value
     */</span>
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">setFirstTime</span><span class="params">(<span class="keyword">boolean</span> value)</span></span>{
        <span class="keyword">long</span> originValue=getBooleanOneGroup();
        setBooleanOneGroup(value?(MASK_FIRST_TIME_OPEN|originValue):(~MASK_FIRST_TIME_OPEN&amp;originValue));
    }
</code></pre><p>上面的代码是Android中实现获取是否第一次打开 ，以及设置是否第一次打开值的实现。设置的原理上面已经说了，或者的原理相比简单多了，只需要把当前值和掩码做与(&amp;)操作即可，结果不等于0就是true,等于0就是false。</p>
<p>以前是以第1位为例子说明的实现方法，对于每一组来说可以有63位可供存储，每一组都是一个Long类型的存储配置，现第一次使用如下方式进行存储：</p>
<pre><code><span class="comment">//每组最大移位62位,第1组63个位使用完，可以再定义第二组</span>
<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String KEY_BOOLEAN_ONE_GROUP=<span class="string">"boolean_one_group"</span>;
    <span class="comment">//下面是第一组的布尔型设置，用完了可以有第二组、第三组等等</span>
<span class="keyword">private</span> <span class="keyword">static</span> <span class="function"><span class="keyword">long</span> <span class="title">getBooleanOneGroup</span><span class="params">()</span></span>{
    <span class="function"><span class="keyword">return</span> SP.<span class="title">getLong</span><span class="params">(KEY_BOOLEAN_ONE_GROUP, <span class="number">0</span>)</span></span>;
}
<span class="keyword">private</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">setBooleanOneGroup</span><span class="params">(<span class="keyword">long</span> value)</span></span>{
    EDITOR.putLong(KEY_BOOLEAN_ONE_GROUP, value);
    EDITOR.commit();
}
</code></pre><p>上面是第一组的方式，第一组63个存储用完之后再按照相同结构定义第二组、第三组等等。下面给说第一组的第1位和第2位的完整代码实现，大家参照此格式进行扩充。</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BooleanPreferences</span> </span>{
    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> SharedPreferences SP=ApplicationContext.context.getSharedPreferences(<span class="string">"boolean_preferences"</span>, Context.MODE_PRIVATE);
    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Editor EDITOR=SP.edit();

    <span class="comment">//每组最大移位62位,第1组63个位使用完，可以再定义第二组</span>
    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String KEY_BOOLEAN_ONE_GROUP=<span class="string">"boolean_one_group"</span>;
    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> MASK_FIRST_TIME_OPEN=<span class="number">1</span>;
    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> MASK_SAVE_ACCOUNT=<span class="number">1</span>&lt;&lt;<span class="number">1</span>;
    <span class="comment">//etc &lt;&lt;2\&lt;&lt;3.....&lt;&lt;62;</span>

    <span class="javadoc">/**
     * 是否第一次打开
     *<span class="javadoctag"> @return</span>
     */</span>
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">boolean</span> <span class="title">isFirstTime</span><span class="params">()</span></span>{
        <span class="keyword">return</span> (getBooleanOneGroup()&amp;MASK_FIRST_TIME_OPEN)!=<span class="number">0</span>;
    }
    <span class="javadoc">/**
     * 设置是否第一次打开
     *<span class="javadoctag"> @param</span> value
     */</span>
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">setFirstTime</span><span class="params">(<span class="keyword">boolean</span> value)</span></span>{
        <span class="keyword">long</span> originValue=getBooleanOneGroup();
        setBooleanOneGroup(value?(MASK_FIRST_TIME_OPEN|originValue):(~MASK_FIRST_TIME_OPEN&amp;originValue));
    }
    <span class="javadoc">/**
     * 是否保存账号
     *<span class="javadoctag"> @return</span>
     */</span>
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">boolean</span> <span class="title">isSaveAccount</span><span class="params">()</span></span>{
        <span class="keyword">return</span> (getBooleanOneGroup()&amp;MASK_SAVE_ACCOUNT)!=<span class="number">0</span>;
    }
    <span class="javadoc">/**
     * 设置是否保存账号
     *<span class="javadoctag"> @param</span> value
     */</span>
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">setSaveAccount</span><span class="params">(<span class="keyword">boolean</span> value)</span></span>{
        <span class="keyword">long</span> originValue=getBooleanOneGroup();
        setBooleanOneGroup(value?(MASK_SAVE_ACCOUNT|originValue):(~MASK_SAVE_ACCOUNT&amp;originValue));
    }

    <span class="comment">//下面是第一组的布尔型设置，用完了可以有第二组、第三组等等</span>
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="function"><span class="keyword">long</span> <span class="title">getBooleanOneGroup</span><span class="params">()</span></span>{
        <span class="function"><span class="keyword">return</span> SP.<span class="title">getLong</span><span class="params">(KEY_BOOLEAN_ONE_GROUP, <span class="number">0</span>)</span></span>;
    }
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">setBooleanOneGroup</span><span class="params">(<span class="keyword">long</span> value)</span></span>{
        EDITOR.putLong(KEY_BOOLEAN_ONE_GROUP, value);
        EDITOR.commit();
    }
}
</code></pre><p>记住。每一位的Mask掩码不能重复，不然就会把其他位的值改变，影响程序的功能，所以要严格按照代码的规范顺序定义掩码，依次左移1位、左移2位、左移3位等等，一直到左移62位，然后开始定义第二组，再从1、左移1位、左移2位开始，依次类推。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在Android开发的过程中，我们基本上都会遇到是否开启自动备份、是否保存账号、是否自动登陆、是否开启向导等这样的选项功能，对于这类功能，我们一般的做法是采用SharedPreferences类存储Boolean类型的配置文件来实现，比如是否第一次打开，我们会使用Share]]>
    </summary>
    
      <category term="Android" scheme="http://www.flysnow.org/tags/Android/"/>
    
      <category term="Android" scheme="http://www.flysnow.org/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Ubuntu下使用搜狗拼音输入法]]></title>
    <link href="http://www.flysnow.org/2013/10/07/ubuntu-sougou-pinyin-input-method.html"/>
    <id>http://www.flysnow.org/2013/10/07/ubuntu-sougou-pinyin-input-method.html</id>
    <published>2013-10-06T18:24:25.000Z</published>
    <updated>2016-05-22T10:14:57.302Z</updated>
    <content type="html"><![CDATA[<p>对于经常使用Ubuntu操作系统并且不会使用五笔输入法的屌丝来说，选择一种好的拼音输入法能让你事半功倍。在window下我们都知道搜狗的输入法比较好用，更有一些用习惯了搜狗输入法的朋友想在Ubuntu等其他Linux发行版下也想使用搜狗输入法，这是完全可行的，通过Fcitx这个输入法框架就可以实现。</p>
<p>Fcitx [ˈfaɪtɪks] 是一个支持扩展的输入法框架。当前它支持 Linux 和 Unix 系统，例如 freebsd。它包括了三个内置的输入法引擎，拼音，区位和基于码表的输入法。详细介绍参见<a href="http://fcitx-im.org" target="_blank" rel="external">fcitx-im.org</a>。</p>
<p>下面以Ubuntu为例介绍如何安装Fcitx，并且配置使用搜狗输入法，其他的Linux发行版的安装可以参考Fcitx官方网站。</p>
<h2 id="添加Fcitx源">添加Fcitx源</h2><p>首先添加Fcitx的ppa源，使用如下命令添加：</p>
<pre><code>sudo<span class="instruction"> add-apt-repository </span>ppa:fcitx-team/nightly
</code></pre><p>然后更新apt</p>
<pre><code>sudo apt-<span class="built_in">get</span> <span class="keyword">update</span>
</code></pre><p>稍等一会就会提示更新完成。</p>
<h2 id="安装搜狗拼音输入法">安装搜狗拼音输入法</h2><p>源更新完成后就可以安装搜狗输入法了，使用如下命令安装：</p>
<pre><code>sudo apt-<span class="keyword">get</span> install fcitx-sogoupinyin
</code></pre><p>在终端中输入以上命令完后回车就开始下载安装包进行安装了，根据你的网速不同所需的事件也不太一样，一般几分钟就好了，稍等一下。安装完成后就可以切换到我们刚刚安装的fcitx输入法，然后卸载原来使用的ibus输入法：</p>
<pre><code><span class="preprocessor">#切换到Fcitx输入法</span>
im-<span class="keyword">switch</span> -s fcitx
<span class="preprocessor">#卸载原来的ibus输入法</span>
sudo apt-<span class="keyword">get</span> remove ibus
</code></pre><p>然后重启电脑即可。重启后就可以看到搜狗输入法了，如果没有看到可以使用如下命令重启fcitx:</p>
<pre><code><span class="title">sudo</span> fcitx -r
</code></pre><p>除此之外，你也可以安装google拼音输入法，步骤和搜狗的差不多，安装后可以在右上角的输入法管理那里切换输入法，也可以选择皮肤等等，fcitx是一个强大的输入法框架，有很多功能，自己可以尝试一下。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>对于经常使用Ubuntu操作系统并且不会使用五笔输入法的屌丝来说，选择一种好的拼音输入法能让你事半功倍。在window下我们都知道搜狗的输入法比较好用，更有一些用习惯了搜狗输入法的朋友想在Ubuntu等其他Linux发行版下也想使用搜狗输入法，这是完全可行的，通过Fcitx]]>
    </summary>
    
      <category term="Linux" scheme="http://www.flysnow.org/tags/Linux/"/>
    
      <category term="Ubuntu" scheme="http://www.flysnow.org/tags/Ubuntu/"/>
    
      <category term="Linux" scheme="http://www.flysnow.org/categories/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[解决Android SDK Manager不能更新的问题]]></title>
    <link href="http://www.flysnow.org/2013/10/06/resolve-android-sdk-manager-can-not-update.html"/>
    <id>http://www.flysnow.org/2013/10/06/resolve-android-sdk-manager-can-not-update.html</id>
    <published>2013-10-05T23:11:56.000Z</published>
    <updated>2016-05-22T10:14:57.302Z</updated>
    <content type="html"><![CDATA[<p>今天打算更新到Android4.3,看看里面的新的API，DOC什么的，但是打开Android SDK Manager后发现不能更新，fetching更新配置文件的时候，都不能获取最新的更新信息。以前还可以以呢，看来这个十一又屏蔽了google拉。</p>
<p>针对这个情况，我第一反应就是使用代理，我本机做的有goagent,想直接用。点击Android SDK Manager的Tools，选中Options，配置里面的代理ip和端口，然后重新启动打开，这时候可以正常fetch了，但是在下载的提示<em>SSL hostname in certificate didn’t match: <dl-ssl.google.com> != <www.google.com> OR <www.google.com></www.google.com></www.google.com></dl-ssl.google.com></em>，看说明提示是ssl证书的hostname不匹配，不能用，这个情况不知道是怎么回事，应该是本机里的证书匹配不上，又没有dl-ssl.google.com的证书，所以不能使用https下载。</p>
<p>不能使用https下载，我们还可以使用http下载。Android doc里也说了，如果使用https下载不了，可以选择使用http下载，只需要在Options里勾选Fore Https…那一个选项即可。。然后重新下载，发现还是下载不了。提示downloading interupt，下载被中断了，这个估计是google对goagent代理有些什么限制或者goagent配置的哪里不对。</p>
<p>最后不得已采取更改hosts的方式。打开终端，使用命令：</p>
<pre><code>sudo vim <span class="regexp">/etc/</span>hosts
</code></pre><p>然后输入 密码打开，把以前hosts配置粘贴上去保存即可。</p>
<pre><code><span class="number">203.208</span>.<span class="number">46.146</span> www<span class="class">.google</span><span class="class">.com</span>
#以前是两个android更新下载的地址
<span class="number">203.208</span>.<span class="number">46.146</span> <span class="tag">dl</span><span class="class">.google</span><span class="class">.com</span>
<span class="number">203.208</span>.<span class="number">46.146</span> dl-ssl<span class="class">.google</span><span class="class">.com</span>
</code></pre><p>以前配置后保存就可以正常更新下载android。其实更改hosts的方式可以解决很多被墙不能访问的网站，比如facebook等，需要的朋友可以在网站找下相关网站的hosts，然后参考以上配置记录。window系统的host在C:\WINDOWS\system32\drivers\etc目录下。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>今天打算更新到Android4.3,看看里面的新的API，DOC什么的，但是打开Android SDK Manager后发现不能更新，fetching更新配置文件的时候，都不能获取最新的更新信息。以前还可以以呢，看来这个十一又屏蔽了google拉。</p>
<p>针对这个情]]>
    </summary>
    
      <category term="Android" scheme="http://www.flysnow.org/tags/Android/"/>
    
      <category term="Linux" scheme="http://www.flysnow.org/tags/Linux/"/>
    
      <category term="Ubuntu" scheme="http://www.flysnow.org/tags/Ubuntu/"/>
    
      <category term="Android" scheme="http://www.flysnow.org/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ubuntu启动错误saned disabled edit /etc/default/saned checking battery state]]></title>
    <link href="http://www.flysnow.org/2013/03/29/ubuntu-saned-disabled.html"/>
    <id>http://www.flysnow.org/2013/03/29/ubuntu-saned-disabled.html</id>
    <published>2013-03-28T20:06:37.000Z</published>
    <updated>2016-05-22T10:14:57.302Z</updated>
    <content type="html"><![CDATA[<p>昨天Ubuntu 12.04LTS 64位版本升级内核后，发现图形界面启动不了。</p>
<p>然后重启，按上下键查看启动信息，发现卡在了saned disabled edit /etc/default/saned。。</p>
<p>Goole了一把，发现是没有gnome-shell.于是就使用CTRL+ALT+F1进入tty1，通过</p>
<p>sudo apt-get install gnome-shell安装，然后sudo reboot重启。</p>
<p>发现还是进入不了图形界面，再次查看日志，发现卡在了 checking battery state</p>
<p>这个原因是因为gdm的问题，安装gdm</p>
<p>sudo apt-get install gdm</p>
<p>在安装过程中会有配置选择，我们选择LightDM，</p>
<p>然后sudo reboot即可。。</p>
<p>然后就如愿的进入了图形界面。。。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>昨天Ubuntu 12.04LTS 64位版本升级内核后，发现图形界面启动不了。</p>
<p>然后重启，按上下键查看启动信息，发现卡在了saned disabled edit /etc/default/saned。。</p>
<p>Goole了一把，发现是没有gnome-]]>
    </summary>
    
      <category term="Ubuntu" scheme="http://www.flysnow.org/tags/Ubuntu/"/>
    
      <category term="Linux" scheme="http://www.flysnow.org/categories/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[关于Android的Holo主题]]></title>
    <link href="http://www.flysnow.org/2013/02/22/android-holo-theme-cts.html"/>
    <id>http://www.flysnow.org/2013/02/22/android-holo-theme-cts.html</id>
    <published>2013-02-22T07:47:39.000Z</published>
    <updated>2016-05-22T10:14:57.302Z</updated>
    <content type="html"><![CDATA[<pre><code>Android曾经为了优化用户体验，把原生的Holo主题作为Android CTS兼容性测试的一部分，这样每家手机厂商在生产手机的时候都将保留该主题，便于开发者开发出在各个分辨率和机型上兼容的应用。。
</code></pre><p>但是在我们最近产品的使用Holo主题的时候发现并非如此，有的用户的手机使用该主题后应用Crash，提示有个别资源找不到，还有的手机在使用后整个界面黑屏，还有的就是样式等搭配不合理无法使用。</p>
<ol>
<li>资源找不到Crash的情况，目前不知道这家厂商生产的手机怎么通过了CTS测试，要么就没有遵循此规则。</li>
</ol>
<ol>
<li>这个目前还不知道什么问题。</li>
</ol>
<ol>
<li>样式搭配不合理，这个是可以通过CTS测试的，因为你该有的都有，至于你使用的这个样式是否合理，</li>
</ol>
<p>CTS是不管的，所以就出现了很多背景和文字颜色一样的情况，导致完全看不到文字。。<br>最后说明的虽然Android要求了Holo主题作为CTS的一部分，不过还有很多手机对此支持不太好，所以还是尽量不要用该主题，如果需要该主题里的一些定义，最好是把该定义单独复制出来，作为当时默认主题的一部分来使用。。。</p>
<p>多说一点，现在的各种东西，只要进了国内，那就是百家齐放，各种各样，你这样作，它那样做，什么协议，什么规则，什么测试，全不顾了，赚钱才是王道，深圳很多更可恶的是改了别人的东西，说是自己开发的，完全不一样，又重新起了个名字就准备上市什么的拉。。还有国内的Android市场，看那个混乱的阿，各种恶意竞争，你搞我，我抓你，玩的不亦乐乎。。你们这么做，能活多久呢？什么时候能真正做出来自己的东西呢？</p>
]]></content>
    <summary type="html">
    <![CDATA[<pre><code>Android曾经为了优化用户体验，把原生的Holo主题作为Android CTS兼容性测试的一部分，这样每家手机厂商在生产手机的时候都将保留该主题，便于开发者开发出在各个分辨率和机型上兼容的应用。。
</code></pre><p>但是在我们最近产品的使用]]>
    </summary>
    
      <category term="Android" scheme="http://www.flysnow.org/tags/Android/"/>
    
      <category term="Android" scheme="http://www.flysnow.org/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android Layout的layout_height等属性为什么会不起作用？]]></title>
    <link href="http://www.flysnow.org/2013/01/28/android-layout-height-fail.html"/>
    <id>http://www.flysnow.org/2013/01/28/android-layout-height-fail.html</id>
    <published>2013-01-28T08:19:58.000Z</published>
    <updated>2016-05-22T10:14:57.302Z</updated>
    <content type="html"><![CDATA[<p>有的时候，我们配置好的布局文件，在加载完成添加到我们的Activity中后发现，并没有安装我们设置的属性来布局，比为我们设置了android:layout<em>marginTop=”100dip”，但是运行程序后发现一点作用都没有，相似的还有layout_height等以android:layout</em>开头的属性设置都没有作用，这类问题以我们使用Adapter的作为数据源的时候作用居多，因为Adapter里有一个方法是getView,这个返回的VIew是一个从XML布局里加载的，一般如下：</p>
<pre><code><span class="keyword">if</span>(convertView==<span class="keyword">null</span>){
convertView=LayoutInflater.<span class="keyword">from</span>(mContext).inflate(R.layout.main, <span class="keyword">null</span>);
}
<span class="keyword">return</span> convertView;
</code></pre><p>问题恰恰出在我们的LayoutInflater.from(mContext).inflate(R.layout.main, null);这句代码上，在使用inflate的时候，如果第二个参数(View root)为null,那么将不会加载你的布局文件里的最顶层的那个布局节点的布局相关配置（就是以android:layout_开头的属性）..我们可以看下该方法的实现来说明一下，通过查找源代码，inflate的实现都在这个public View inflate(XmlPullParser parser, ViewGroup root, boolean attachToRoot) 方法里定义。。其中一段：</p>
<pre><code><span class="keyword">if</span> (root != <span class="keyword">null</span>) {
   <span class="keyword">if</span> (DEBUG) {
      System.<span class="keyword">out</span>.println(<span class="string">"Creating params from root: "</span> +root);
   }
   <span class="comment">// Create layout params that match root, if supplied</span>
   <span class="keyword">params</span> = root.generateLayoutParams(attrs);
   <span class="keyword">if</span> (!attachToRoot) {
       <span class="comment">// Set the layout params for temp if we are not</span>
        <span class="comment">// attaching. (If we are, we use addView, below)</span>
        temp.setLayoutParams(<span class="keyword">params</span>);
    }
}
</code></pre><p>可以看到，当root为null的时候是不会执行params = root.generateLayoutParams(attrs);这段代码的，这段代码就是把xml里的布局配置转为LayoutParams,换句说就是加载我们配置的布局属性，以供布局类（FrameLayout等）在onLayout的时候控制View的大小、位置、对齐等等。。以FrameLayout为例，看下它的generateLayoutParams(attrs)方法。</p>
<pre><code><span class="keyword">public</span> <span class="function">LayoutParams <span class="title">generateLayoutParams</span><span class="params">(AttributeSet attrs)</span> </span>{
        <span class="keyword">return</span> <span class="keyword">new</span> FrameLayout.LayoutParams(getContext(), attrs);        
    }
</code></pre><p>很简单，构造了一个FrameLayout.LayoutParams类，该类集成了MarginParams，增加了一个gravity对其的属性配置。。。</p>
<p>在这里，如果要自定义自己的VIewroup，并且该ViewGroup有一些自定义控制布局的属性设置，就可以通过集成View.MarginParams来扩展布局配置，然后重写generateLayoutParams方法，这样系统框架就会自动使用该布局读取我们在xml中配置的布局属性来控制我们的VIew的位置。。</p>
<p>基于以上分析，我们在使用LayoutInflate的inflate方法的时候一定要保证root参数不能为null，其实这个root就是父View的意思，就是说你把xml转换为一个VIew的时候，该VIew的Parent是root，如果你不想把该View添加到该root里，那么让第三个参数 attachToRoot为false，如果要添加则为true.</p>
<p>说到这个问题了，其实还有一些布局，他们的参数配置要满足一定的条件才会起作用，比如FrameLayout里的View，你要想它的leftMargin生效，必须指定它的layout_gravity为left，同理right对应rightMargin.top和bottom也一样。。在使用时注意即可，多看看源代码。要不然就会莫名起名，不知道哪里的问题。</p>
<p>ViewGroup的三条线:</p>
<ol>
<li>onMeasure 测量View的大小</li>
<li>onLayout 对View的布局进行控制</li>
<li>draw绘制该View，drawChild绘制子VIew</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>有的时候，我们配置好的布局文件，在加载完成添加到我们的Activity中后发现，并没有安装我们设置的属性来布局，比为我们设置了android:layout<em>marginTop=”100dip”，但是运行程序后发现一点作用都没有，相似的还有layout_height等以]]>
    </summary>
    
      <category term="Android" scheme="http://www.flysnow.org/tags/Android/"/>
    
      <category term="Android" scheme="http://www.flysnow.org/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android ViewGroup.setDescendantFocusability函数]]></title>
    <link href="http://www.flysnow.org/2013/01/05/android-viewgroup-setdescendantfocusability.html"/>
    <id>http://www.flysnow.org/2013/01/05/android-viewgroup-setdescendantfocusability.html</id>
    <published>2013-01-04T20:15:14.000Z</published>
    <updated>2016-05-22T10:14:57.302Z</updated>
    <content type="html"><![CDATA[<p>这个函数是在ViewGroup里定义的，主要用于控制child View获取焦点的能力，比如是否阻止child View获取焦点。</p>
<p>他有三个常量可供设置</p>
<ol>
<li>FOCUS_BEFORE_DESCENDANTS ViewGroup本身先对焦点进行处理，如果没有处理则分发给child View进行处理</li>
</ol>
<ol>
<li>FOCUS_AFTER_DESCENDANTS 先分发给Child View进行处理，如果所有的Child View都没有处理，则自己再处理</li>
</ol>
<ol>
<li>FOCUS_BLOCK_DESCENDANTS ViewGroup本身进行处理，不管是否处理成功，都不会分发给ChildView进行处理</li>
</ol>
<pre><code>我们看下这个方法的实现







<span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">setDescendantFocusability</span><span class="params">(<span class="keyword">int</span> focusability)</span> </span>{
        <span class="keyword">switch</span> (focusability) {
            <span class="keyword">case</span> FOCUS_BEFORE_DESCENDANTS:
            <span class="keyword">case</span> FOCUS_AFTER_DESCENDANTS:
            <span class="keyword">case</span> FOCUS_BLOCK_DESCENDANTS:
                <span class="keyword">break</span>;
            <span class="keyword">default</span>:
                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"must be one of FOCUS_BEFORE_DESCENDANTS, "</span>
                        + <span class="string">"FOCUS_AFTER_DESCENDANTS, FOCUS_BLOCK_DESCENDANTS"</span>);
        }
        mGroupFlags &amp;= ~FLAG_MASK_FOCUSABILITY;
        mGroupFlags |= (focusability &amp; FLAG_MASK_FOCUSABILITY);
    }
</code></pre><p>可以看到，只有这三个常量可以设置，不是这三个常量会抛出异常的。</p>
<p>设置后，会在requestFocus(int direction, Rect previouslyFocusedRect) 方法里根据设置进行相应的处理。来看下实现</p>
<pre><code><span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">requestFocus</span><span class="params">(<span class="keyword">int</span> direction, Rect previouslyFocusedRect)</span> </span>{
        <span class="keyword">if</span> (DBG) {
            System.out.println(<span class="keyword">this</span> + <span class="string">" ViewGroup.requestFocus direction="</span>
                    + direction);
        }
        <span class="keyword">int</span> descendantFocusability = getDescendantFocusability();

        <span class="keyword">switch</span> (descendantFocusability) {
            <span class="keyword">case</span> FOCUS_BLOCK_DESCENDANTS:
                <span class="keyword">return</span> <span class="keyword">super</span>.requestFocus(direction, previouslyFocusedRect);
            <span class="keyword">case</span> FOCUS_BEFORE_DESCENDANTS: {
                <span class="keyword">final</span> <span class="keyword">boolean</span> took = <span class="keyword">super</span>.requestFocus(direction, previouslyFocusedRect);
                <span class="keyword">return</span> took ? took : onRequestFocusInDescendants(direction, previouslyFocusedRect);
            }
            <span class="keyword">case</span> FOCUS_AFTER_DESCENDANTS: {
                <span class="keyword">final</span> <span class="keyword">boolean</span> took = onRequestFocusInDescendants(direction, previouslyFocusedRect);
                <span class="keyword">return</span> took ? took : <span class="keyword">super</span>.requestFocus(direction, previouslyFocusedRect);
            }
            <span class="keyword">default</span>:
                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"descendant focusability must be "</span>
                        + <span class="string">"one of FOCUS_BEFORE_DESCENDANTS, FOCUS_AFTER_DESCENDANTS, FOCUS_BLOCK_DESCENDANTS "</span>
                        + <span class="string">"but is "</span> + descendantFocusability);
        }
    }
</code></pre><p>通过这里的实现可以看到上面定义的三个常量设置的意思。。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这个函数是在ViewGroup里定义的，主要用于控制child View获取焦点的能力，比如是否阻止child View获取焦点。</p>
<p>他有三个常量可供设置</p>
<ol>
<li>FOCUS_BEFORE_DESCENDANTS ViewGroup本身先对焦点]]>
    </summary>
    
      <category term="Android" scheme="http://www.flysnow.org/tags/Android/"/>
    
      <category term="Android" scheme="http://www.flysnow.org/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[基于Android的浮动组件，可以用于应用中的新功能展示等等。]]></title>
    <link href="http://www.flysnow.org/2011/12/10/android-float-widget.html"/>
    <id>http://www.flysnow.org/2011/12/10/android-float-widget.html</id>
    <published>2011-12-10T01:12:00.000Z</published>
    <updated>2016-05-22T10:14:57.302Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>在开发Android应用时,加新功能是必不可少的，我们加入了新的功能，有的一看界面就可以看出来，但是有的新功能就比较隐蔽，也就是用户很难知道你添加了这个新功能，这个时候就需要用户在打开我们的应用时给出一些提示，说明我们在哪里添加了新功能，点击哪里可以看到这个新功能。这时我们第一时间想到的可能是Toast，因为它用法简单，又不影响用户操作，但是它有个缺点，就是不能明确的指示是哪里添加了新功能，除非你用文字描述出来。为此，我基于Toast编写了一个小组件FloatTextToast（下面遇到的这个名字代替我写的这个组件），他和Toast的用法一样简单，并且弥补了Toast的缺点，也更显得更好看。</p>
<h2 id="效果图">效果图</h2><p><img src="http://hi.csdn.net/attachment/201112/10/0_13234942045Irb.gif" alt=""></p>
<h2 id="你可以学到">你可以学到</h2><ol>
<li>Toast的基本用法</li>
</ol>
<ol>
<li>Android的消息机制，如何创建自己的消息队列</li>
</ol>
<ol>
<li>怎样在Activity启动时获取一个View的width、height、top、left等属性</li>
</ol>
<h2 id="基本思路">基本思路</h2><ol>
<li>首先你要有一个处理好的9 PNG的图片，用于自适应文字显示，关于9 PNG处理可以参考Android Doc</li>
</ol>
<ol>
<li>要显示在哪个View的下面，就要知道这个目标View的位置</li>
</ol>
<ol>
<li>把要显示的文本放在一个TextView里，使用Toast的setView方法设置Toast要显示的View</li>
</ol>
<ol>
<li>根据得到的位置，最后就是使用Toast的setGravity方法把要显示的内容放到正确的位置显示出来即可。</li>
</ol>
<p>总的来说首先就是要知道目标View，根据targetView计算出要显示提示的位置，然后根据位置使用Toast把提示的文本显示出来。但是这里有几个难点，下面就一一解决</p>
<h2 id="Activity加载完成时获取targetVIew的宽高和位置属性">Activity加载完成时获取targetVIew的宽高和位置属性</h2><p>我们加入了新的功能提示，自然会在用户打开这个界面的时候就提示，但是在UI没有渲染完成绑定倒Window上的时候，是不能获取倒targetView的width、height和position的，那么我们怎么才能知道targetView的这些属性呢？Activity的onAttachedToWindow回调方法是不能用的，况且它是在API 5加上的，以前的API中并没有。不过我们还有一种方法，那就是在显示提示的时候获取targetView的属性，如果获取不到（为0）就一直获取，直到获取到为止，这其实是一个轮询。为了达到这一目的，我们在开发者调用FloatTextToast.show()的时候使用Android的Message机制轮询获取一个targetView的属性，如果获取到，就会显示提示文字了。在此之前先看下FloatTextToast构造函数，可以对它有个大概的了解，防止后面的代码中出现的成员变量不认识。</p>
<pre><code><span class="function"><span class="keyword">private</span> <span class="title">FloatTextToast</span><span class="params">(Context context,View targetView)</span> </span>{
        <span class="keyword">this</span>.mTargetView = targetView;
        <span class="keyword">this</span>.mContext= context;
        mToast=<span class="keyword">new</span> Toast(mContext);
        mContentView=<span class="keyword">new</span> TextView(mContext);
        mContentView.setBackgroundResource(R.drawable.float_text_toast_bg);
        mContentView.setTextColor(Color.BLACK);
        mContentView.setTextSize(TypedValue.COMPLEX_UNIT_DIP,<span class="number">16</span>);
        mToast.setView(mContentView);

        <span class="comment">//初始化一个Handler线程</span>
        mHandlerThread=<span class="keyword">new</span> HandlerThread(<span class="string">"FloatTextToast"</span>);
        mHandlerThread.start();
        mHandler=<span class="keyword">new</span> FloatTextToastHandler(mHandlerThread.getLooper());
    }
</code></pre><h2 id="自定义自己的消息循环机制">自定义自己的消息循环机制</h2><p>要想在一个自定义的组件中使用Message机制，一定要有自己的Looper机制，我们不能使用Activity的Looper，因为主Looper可能会有其他的Message需要处理，这就会导致我们的show方法会延迟调用，这样效果就不好了，所以要有一个专门的Looper来处理此Message。要声明自己的Looper，就需要HandlerThread这个类的配合了，这可是个好东西，使用它你会很容易的创建一个自己的线程用于处理你Message。使用方法很简单，如下代码：</p>
<pre><code><span class="comment">//初始化一个Handler线程</span>
        mHandlerThread=<span class="keyword">new</span> HandlerThread(<span class="string">"FloatTextToast"</span>);
        mHandlerThread.start();
        mHandler=<span class="keyword">new</span> FloatTextToastHandler(mHandlerThread.getLooper());
</code></pre><p>这样就声明了一个HandlerThread并且让它运行，运行之后我们就可以获取一个属于该Thread的Looper，然后把Message发送给这个Looper，那么这个线程就可以处理你发送的消息了。。看看我们的自定义Handler</p>
<pre><code><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">FloatTextToastHandler</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Handler</span>{</span>

        public <span class="type">FloatTextToastHandler</span>(<span class="type">Looper</span> looper) {
            <span class="keyword">super</span>(looper);
        }

        <span class="annotation">@Override</span>
        public void handleMessage(<span class="type">Message</span> msg) {
            switch(msg.what){
            <span class="keyword">case</span> <span class="type">WHAT_SHOW</span>:
                showInHandler();
            }
        }

    }
</code></pre><p>它需要传递一个Looper作为构造参数声明，意思就是使用这个Looper处理我发send的Message的意思。上面的代码</p>
<pre><code>mHandler=<span class="keyword">new</span> <span class="type">FloatTextToastHandler</span>(mHandlerThread.getLooper<span class="literal">()</span>);
</code></pre><p>正是我们使用自己开启的线程处理我们的Message的意思。下面看下我们的showInHandler()方法是怎么处理的。</p>
<pre><code>/**在<span class="type">Handler</span>调用的show方法，主要为了等待{@link #mTargetView}的位置*/
    <span class="keyword">private</span> void showInHandler<span class="literal">()</span>{
        <span class="built_in">int</span><span class="literal">[]</span> targetPos=getTargetViewPos<span class="literal">()</span>;
        <span class="keyword">if</span>(targetPos[<span class="number">0</span>]==<span class="number">0</span>&amp;&amp;targetPos[<span class="number">1</span>]==<span class="number">0</span>){
            mHandler.sendEmptyMessageDelayed(<span class="type">WHAT_SHOW</span>, <span class="number">100</span>);
        }<span class="keyword">else</span>{
            final <span class="type">Rect</span> contentPos=getContentViewPos(targetPos);
            mToast.setGravity(<span class="type">Gravity</span>.<span class="type">LEFT</span>|<span class="type">Gravity</span>.<span class="type">TOP</span>, contentPos.left, contentPos.top);
            mToast.show<span class="literal">()</span>;
        }
    }
</code></pre><p>该方法其实就是在获取targetVIew的位置，如果获取不到，则向自定义的Looper里发送一个Message重新调用该函数，如果得到了位置，那么就调用Toast的setGravity方法设置好要显示文本的位置，然后显示即可。</p>
<h2 id="获取要显示文本的位置">获取要显示文本的位置</h2><p>要获取显示的位置，就要知道targetVIew的位置以及它的宽、高，这样就能计算要显示文本的位置了。View组件都有一个函数，可以把自己在Window里的坐标转换为一个数组。</p>
<pre><code><span class="keyword">private</span> <span class="built_in">int</span><span class="literal">[]</span> getTargetViewPos<span class="literal">()</span>{
        final <span class="built_in">int</span><span class="literal">[]</span> targetPos=<span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">2</span>];
        mTargetView.getLocationInWindow(targetPos);
        return targetPos;
    }
</code></pre><p>这样，就返回了targetView的xy坐标了。光有targetView的坐标还不够，还要有contentView最终要显示的位置。</p>
<pre><code><span class="comment">/**
     * 计算获取浮动文本显示的位置，把浮动文本放在targetView的中心处
     * @return 一个包含top和left的Rect
     */</span>
    <span class="keyword">private</span>  Rect getContentViewPos(<span class="built_in">int</span>[] targetPos){
        <span class="keyword">final</span> Rect windowVisibleRect=<span class="keyword">new</span> Rect();
        <span class="keyword">final</span> View targetView=mTargetView;
        <span class="keyword">final</span> TextView contentView=mContentView;
        <span class="comment">//状态栏高度</span>
        targetView.getWindowVisibleDisplayFrame(windowVisibleRect);
        <span class="built_in">int</span> statusBarHeight=windowVisibleRect.top;

        <span class="comment">//背景图那个三角箭头的位置</span>
        <span class="keyword">final</span> TextPaint textPaint=contentView.getPaint();
        <span class="built_in">int</span> contentW=(<span class="built_in">int</span>)textPaint.measureText((<span class="keyword">String</span>)contentView.getText());
        <span class="built_in">int</span> arrowPos=(<span class="built_in">int</span>)(contentW*(<span class="number">30.0</span>/<span class="number">160</span>));

        <span class="keyword">final</span> Rect <span class="built_in">rect</span> = <span class="keyword">new</span> Rect();
        <span class="built_in">rect</span>.left = targetPos[<span class="number">0</span>]+targetView.getWidth()/<span class="number">2</span>-arrowPos;
        <span class="built_in">rect</span>.top = targetPos[<span class="number">1</span>]-statusBarHeight + targetView.getHeight();
        <span class="keyword">return</span> <span class="built_in">rect</span>;
    }
</code></pre><p>这个函数的功能就是让文本显示在targetView的下方的横向中间的位置，也就是文本的背景尖角三角要指向targetView横向中间的位置，这样才好看些。为了这个才需要使用Paint测量文本的宽度，所以这也是该组件的一个缺陷，不能显示String格式之外的字符，比如SpannableString。</p>
<h2 id="完整的组件代码">完整的组件代码</h2><p>上面是对组件代码的拆分讲解，是为了说明我们当时实现这个组件的想法以及步骤，下面就整体把代码列出来，明了的看一下。</p>
<pre><code><span class="javadoc">/**
 * 浮动的文本显示。根据一个提供的View，可以把文本显示到该View的下面.
 * 可以设置显示的时间，多了该时间后自动消失。目前只支持纯文本{@link String}类型的显示
 * 因为要计算显示文本的宽度。
 *<span class="javadoctag"> @author</span> michael_li(飞雪无情)
 *<span class="javadoctag"> @since</span> 2011-12-10 下午04:57:36
 */</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FloatTextToast</span> </span>{
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LENGTH_LONG=Toast.LENGTH_LONG;
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LENGTH_SHORT=Toast.LENGTH_SHORT;
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WHAT_SHOW=<span class="number">1</span>;

    <span class="keyword">private</span> Context mContext;
    <span class="keyword">private</span> View mTargetView;
    <span class="keyword">private</span> Toast mToast;
    <span class="keyword">private</span>  TextView mContentView;

    <span class="keyword">private</span> HandlerThread mHandlerThread;
    <span class="keyword">private</span> FloatTextToastHandler mHandler;
    <span class="function"><span class="keyword">private</span> <span class="title">FloatTextToast</span><span class="params">(Context context,View targetView)</span> </span>{
        <span class="keyword">this</span>.mTargetView = targetView;
        <span class="keyword">this</span>.mContext= context;
        mToast=<span class="keyword">new</span> Toast(mContext);
        mContentView=<span class="keyword">new</span> TextView(mContext);
        mContentView.setBackgroundResource(R.drawable.float_text_toast_bg);
        mContentView.setTextColor(Color.BLACK);
        mContentView.setTextSize(TypedValue.COMPLEX_UNIT_DIP,<span class="number">16</span>);
        mToast.setView(mContentView);

        <span class="comment">//初始化一个Handler线程</span>
        mHandlerThread=<span class="keyword">new</span> HandlerThread(<span class="string">"FloatTextToast"</span>);
        mHandlerThread.start();
        mHandler=<span class="keyword">new</span> FloatTextToastHandler(mHandlerThread.getLooper());
    }
    <span class="javadoc">/**
     * 生成一个FloatTextToast
     *<span class="javadoctag"> @param</span> context Activity 上下文
     *<span class="javadoctag"> @param</span> targetView  目标View，浮动文本要显示在哪个View下面
     *<span class="javadoctag"> @param</span> text 要显示的文本
     *<span class="javadoctag"> @param</span> duration 浮动文本显示的时间 {@link #LENGTH_LONG} {@link #LENGTH_SHORT}
     *<span class="javadoctag"> @return</span> 一个FloatTextToast，可以调用{@link #show()}显示
     */</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> FloatTextToast <span class="title">makeText</span><span class="params">(Context context,View targetView, String text, <span class="keyword">int</span> duration)</span> </span>{
        <span class="keyword">final</span> FloatTextToast floatToast=<span class="keyword">new</span> FloatTextToast(context,targetView);
        <span class="keyword">final</span> TextView contentView=floatToast.mContentView;
        contentView.setText(text);
        floatToast.mToast.setDuration(duration);
        <span class="keyword">return</span> floatToast;
    }
    <span class="javadoc">/**
     * 显示浮动文本
     */</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>{
        mHandler.sendEmptyMessage(WHAT_SHOW);
    }
    <span class="javadoc">/**在Handler调用的show方法，主要为了等待{@link #mTargetView}的位置*/</span>
    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">showInHandler</span><span class="params">()</span></span>{
        <span class="keyword">int</span>[] targetPos=getTargetViewPos();
        <span class="keyword">if</span>(targetPos[<span class="number">0</span>]==<span class="number">0</span>&amp;&amp;targetPos[<span class="number">1</span>]==<span class="number">0</span>){
            mHandler.sendEmptyMessageDelayed(WHAT_SHOW, <span class="number">100</span>);
        }<span class="keyword">else</span>{
            <span class="keyword">final</span> Rect contentPos=getContentViewPos(targetPos);
            mToast.setGravity(Gravity.LEFT|Gravity.TOP, contentPos.left, contentPos.top);
            mToast.show();
        }
    }
    <span class="keyword">private</span> <span class="keyword">int</span>[] getTargetViewPos(){
        <span class="keyword">final</span> <span class="keyword">int</span>[] targetPos=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];
        mTargetView.getLocationInWindow(targetPos);
        <span class="keyword">return</span> targetPos;
    }
    <span class="javadoc">/**
     * 计算获取浮动文本显示的位置，把浮动文本放在targetView的中心处
     *<span class="javadoctag"> @return</span> 一个包含top和left的Rect
     */</span>
    <span class="function"><span class="keyword">private</span>  Rect <span class="title">getContentViewPos</span><span class="params">(<span class="keyword">int</span>[] targetPos)</span></span>{
        <span class="keyword">final</span> Rect windowVisibleRect=<span class="keyword">new</span> Rect();
        <span class="keyword">final</span> View targetView=mTargetView;
        <span class="keyword">final</span> TextView contentView=mContentView;
        <span class="comment">//状态栏高度</span>
        targetView.getWindowVisibleDisplayFrame(windowVisibleRect);
        <span class="keyword">int</span> statusBarHeight=windowVisibleRect.top;

        <span class="comment">//背景图那个三角箭头的位置</span>
        <span class="keyword">final</span> TextPaint textPaint=contentView.getPaint();
        <span class="keyword">int</span> contentW=(<span class="keyword">int</span>)textPaint.measureText((String)contentView.getText());
        <span class="keyword">int</span> arrowPos=(<span class="keyword">int</span>)(contentW*(<span class="number">30.0</span>/<span class="number">160</span>));

        <span class="keyword">final</span> Rect rect = <span class="keyword">new</span> Rect();
        rect.left = targetPos[<span class="number">0</span>]+targetView.getWidth()/<span class="number">2</span>-arrowPos;
        rect.top = targetPos[<span class="number">1</span>]-statusBarHeight + targetView.getHeight();
        <span class="keyword">return</span> rect;
    }
    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">FloatTextToastHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span></span>{

        <span class="function"><span class="keyword">public</span> <span class="title">FloatTextToastHandler</span><span class="params">(Looper looper)</span> </span>{
            <span class="keyword">super</span>(looper);
        }

        <span class="annotation">@Override</span>
        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>{
            <span class="keyword">switch</span>(msg.what){
            <span class="keyword">case</span> WHAT_SHOW:
                showInHandler();
            }
        }

    }
}
</code></pre><p>此组件和Toast的实现方法一样，所以上手不难，只需使用makeText静态方法生成一个即可</p>
<pre><code>FloatTextToast.<span class="function"><span class="title">makeText</span><span class="params">(Context context, View targetView, String text, int duration)</span></span>.<span class="function"><span class="title">show</span><span class="params">()</span></span>
</code></pre><p>就这么简单，传进去几个参数，show出即可，和Toast一样好用。</p>
<h2 id="小结">小结</h2><p>这里主要是通过类之间的组合编写一个一个FloatTextToast组件，便于在应用中提示一些信息，不光局限于新功能的提示，还有其他的点击查看个人信息等等，就如上面的效果图一样。这里主要的难点就在于Activity启动获取targetView的状态，这里采用了不受影响的自定义的消息机制，能及时的获取targetView的状态。这里也采用的Toast的队列机制，这样就能够更好的一个个的提示，让用户看完一个再显示另外一个，不至于一下子全显示出来，而用户没有时间看。这里还采用了Paint用于测量文本的真实宽度，所以也有了一些缺陷，如果哪位有更好的方法，也可以留言告知我，不胜感激。</p>
<p><img src="http://hi.csdn.net/attachment/201112/10/0_1323508315BC94.gif" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>在开发Android应用时,加新功能是必不可少的，我们加入了新的功能，有的一看界面就可以看出来，但是有的新功能就比较隐蔽，也就是用户很难知道你添加了这个新功能，这个时候就需要用户在打开我们的应用时给出一些提示，说明我们在哪里添加了新功能]]>
    </summary>
    
      <category term="Android" scheme="http://www.flysnow.org/tags/Android/"/>
    
      <category term="Android" scheme="http://www.flysnow.org/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[提取出的最新Android4.0 API 源代码]]></title>
    <link href="http://www.flysnow.org/2011/11/15/android-4-0-api-arrange.html"/>
    <id>http://www.flysnow.org/2011/11/15/android-4-0-api-arrange.html</id>
    <published>2011-11-14T22:06:48.000Z</published>
    <updated>2016-05-22T10:14:57.302Z</updated>
    <content type="html"><![CDATA[<p>提取出的Android4.0 API 的源代码，也就是android.jar源代码，这样在Eclipse关联到该源代码，就可以在项目中查看Android API 的实现了。</p>
<p>下载地址 <a href="http://download.csdn.net/detail/michael__li/3802305" target="_blank" rel="external">http://download.csdn.net/detail/michael__li/3802305</a></p>
<p>Android4.0 全部源代码下载方法 ：<a href="http://blog.csdn.net/michael__li/article/details/6971765" target="_blank" rel="external">http://blog.csdn.net/michael__li/article/details/6971765</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>提取出的Android4.0 API 的源代码，也就是android.jar源代码，这样在Eclipse关联到该源代码，就可以在项目中查看Android API 的实现了。</p>
<p>下载地址 <a href="http://download.csdn.net/deta]]>
    </summary>
    
      <category term="API" scheme="http://www.flysnow.org/tags/API/"/>
    
      <category term="Android" scheme="http://www.flysnow.org/tags/Android/"/>
    
      <category term="Android" scheme="http://www.flysnow.org/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[最新最全的Android4.0 API源代码下载和完整Android4.0源代码下载教程]]></title>
    <link href="http://www.flysnow.org/2011/11/15/download-android-4-0-sources.html"/>
    <id>http://www.flysnow.org/2011/11/15/download-android-4-0-sources.html</id>
    <published>2011-11-14T17:41:00.000Z</published>
    <updated>2016-05-22T10:14:57.302Z</updated>
    <content type="html"><![CDATA[<p>这时刚刚整理好的最新的，包含所有的API的源代码，第一次上传的那个Android4.0 API 源代码有部分API没有包含，请点击下面的链接下载最新的。</p>
<p>附Android4.0 API 源代码下载<a href="http://download.csdn.net/detail/michael__li/3802305" target="_blank" rel="external">http://download.csdn.net/detail/michael__li/3802305</a></p>
<p>昨日凌晨Android放出4.0源代码，已经托管到GoogleSource上，大家可以下载了，这次放出的branch为Android-4.0.0_r1。</p>
<p>下载教程。操作系统环境为Linux,并且确保你已经安装了git jdk python等.</p>
<p>1.创建bin目录，并加入到PATH</p>
<pre><code>$ <span class="built_in">mkdir</span> ~/bin
$ <span class="built_in">PATH</span>=~/bin:$<span class="built_in">PATH</span>
</code></pre><p>2.下载repo到刚刚创建的bin目录，并设置权限为可执行。</p>
<pre><code><span class="variable">$ </span>curl <span class="symbol">https:</span>/<span class="regexp">/dl-ssl.google.com/dl</span><span class="regexp">/googlesource/git</span>-repo/repo &gt; ~<span class="regexp">/bin/repo</span>
<span class="variable">$ </span>chmod a+x ~<span class="regexp">/bin/repo</span>
</code></pre><p>3.创建Android源代码存放目录并进入到该目录</p>
<pre><code>$ mkdirAndroid-<span class="number">4.0</span><span class="number">.0</span>_<span class="built_in">r1</span>
$ cdAndroid-<span class="number">4.0</span><span class="number">.0</span>_<span class="built_in">r1</span>
</code></pre><p>4.初始化Android4.0.1的Git库</p>
<pre><code><span class="variable">$ </span>repo init -u <span class="symbol">https:</span>/<span class="regexp">/android.googlesource.com/platform</span><span class="regexp">/manifest -b android-4.0.1_r1</span>
</code></pre><p>5.最后执行开始同步下载</p>
<pre><code><span class="variable">$ </span>repo sync
</code></pre><p>然后就是漫长的等待了。。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这时刚刚整理好的最新的，包含所有的API的源代码，第一次上传的那个Android4.0 API 源代码有部分API没有包含，请点击下面的链接下载最新的。</p>
<p>附Android4.0 API 源代码下载<a href="http://download.csdn.ne]]>
    </summary>
    
      <category term="Android" scheme="http://www.flysnow.org/tags/Android/"/>
    
      <category term="Ubuntu" scheme="http://www.flysnow.org/tags/Ubuntu/"/>
    
      <category term="Android" scheme="http://www.flysnow.org/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android设计应用图标不用愁---Asset Studio Integration来帮你]]></title>
    <link href="http://www.flysnow.org/2011/11/11/android-asset-studio-integration.html"/>
    <id>http://www.flysnow.org/2011/11/11/android-asset-studio-integration.html</id>
    <published>2011-11-11T08:18:00.000Z</published>
    <updated>2016-05-22T10:14:57.302Z</updated>
    <content type="html"><![CDATA[<p><a href="http://android-ui-utils.googlecode.com/hg/asset-studio/dist/index.html" target="_blank" rel="external">Android Asset Studio</a>Web版是一个非常好用的Andrid图标资源设计工具，它是由RomanNurik开发的。现在我们已经在ADT14里支持同样的功能。首先，你要打开新建向导（Ctrl-N）,选择Android分类，然后在其下找到名字为“Android Icon Set”的这一项：</p>
<p><img src="http://hi.csdn.net/attachment/201111/10/0_13209351362229.gif" alt=""></p>
<p>然后，将会弹出“资源选择器”（这些资源其实就是你在布局文件用到的那些图片，比如对于上下文菜单自定义的背景图片，就需要一个为“Background”属性设置一个@drawable的引用）对话框，该对话框里有个按钮(Create New Icon…)，点击它.</p>
<p><img src="http://hi.csdn.net/attachment/201111/10/0_1320936348j75Y.gif" alt=""></p>
<p>当你打开Android Icon Set向导的时候，首先看到的是一个资源类型选择界面，也就是你想创建哪一类图标：</p>
<p><img src="http://hi.csdn.net/attachment/201111/10/0_1320936495Wu61.gif" alt=""></p>
<p>在这里，你可以选择创建哪一类图标，并且为这个被创建的图标起一个名字。</p>
<p>如果你选择创建一个启动图标并且单击了下一步，这时你会看到如下界面：</p>
<p><img src="http://hi.csdn.net/attachment/201111/10/0_1320936654FoRB.gif" alt=""></p>
<p>这个界面包含很多功能。首先你会在右边看到我们正在创建和处理的图标的预览图。正如你所看到的，针对不同分辨率的屏幕它创建了多个图标，这就是刚刚为什么我们指的是一个“图标集合”，而不仅仅是一个“图标”。除了上面显示的，我们还创建了一个高分辨率的“web”版本的图标，你可能会在上传应用到Android Market的时候用到它（译者按：在上传App倒Android<br>Market的时候，可以上传一个大图标）。</p>
<p><img src="http://hi.csdn.net/attachment/201111/10/0_1320937517H8eb.gif" alt=""></p>
<p>仔细看下这个图标，你会发现它比我们在上面预览（Preview）那里看到的更有光泽。你可以选择界面上的“Glossy”选项来使得你的图标具有光泽的效果。</p>
<p><img src="http://hi.csdn.net/attachment/201111/10/0_1320937955mwIb.gif" alt=""></p>
<p>你还可以设置背景的形状。文本的字体、颜色等等。</p>
<p><img src="http://hi.csdn.net/attachment/201111/10/0_1320938081E0sR.gif" alt=""></p>
<p>然而，使用文本并不能做出非常好的图标，但是请注意，这仅仅是我们为了得到初步的效果而采取的一种很快捷的方式。请注意界面的最上面还有三个功能选项：</p>
<ul>
<li>图片</li>
</ul>
<ul>
<li>剪贴画</li>
</ul>
<ul>
<li>文本</li>
</ul>
<p>理想情况下你会用你自己的“基准”图像（或者如果需要的话会是一个剪贴画），然后使用Asset Studio 向导生成合适的图标。</p>
<p>你会问了：“我已经有了一个自己绘制好的图标了，那么我为什么还要再生成”？原因就是Anroid有不同的版本、不同的主题，这就意味着你会提供不同效果、不同颜色以及不同样式的图标。比如下面我为状态栏和通知栏生成的图标：</p>
<p><img src="http://hi.csdn.net/attachment/201111/10/0_1320939254gexG.gif" alt=""></p>
<p>你可以看到使用的基准图像只是一个简单的黑白相间的Bugdroid图像，但是我们为Gingerbread(v9)、Honeycomb(v11)以及老的版本都生成了不同样式的图标。对于ActionBar，Asset Studio向导会生成亮、暗两种不同Holo 主题的图标。对于选项卡则会生成“选中”和“未选中”两种不同样式的图标，并且对于v5（Andoid2.0）之前的版本则会新生成不同演示的“未选中”状态的图标（译者按：Asset<br>Studio对于v5版本前后生成的“为选中”图标是不一样的，从下图可以看出，v5之前的图标发白，v5之后的发灰）。</p>
<p><img src="http://hi.csdn.net/attachment/201111/10/0_1320940269VMv2.gif" alt=""></p>
<p>使用Asset Studio的一个优势就是在你点击完成按钮后，它可以直接在你当前的项目中生成你设计好的图标。这样你就不用像使用Web版本（译者按：前面提到过，这个工具一开始是Web App，ADT14才加入进来，成为ADT的一部分）一样，还要下载下来并且提取图标放在正确的位置。它还会在图标名字冲突的时候提示你是否覆盖原文件。如果你在上面的资源选择器界面里点击了“Create<br>Icon”按钮，那么新创建的图标将会在选择器里被选中。</p>
<p>当你点击完成退出向导的时候，包资源管理器会自动更新并且选中新创建的图标。</p>
<p><img src="http://hi.csdn.net/attachment/201111/11/0_1321025460X3wc.gif" alt=""></p>
<p>和ADT集成的第二个优势就是我们可以知道你的项目工程的minimum SDK target，我们就可以利用这些信息仅仅生成必要的图标。比如你正在基于Android2.0或者以上版本开发一个App，那么我们将不会生成不需要的老的样式的图标，也不需要名字为drawable-mdpi-v5的文件夹等等；生成的图标直接会被放进drawable-mdpi文件夹里。</p>
<p>我们希望这些内容能让你更容易的创建很好的应用。请不要经常使用那个文本功能:（译者按：最好使用Image和Clipart两个）-)我们还仍需要为AOSP贡献更多的剪贴画，这样大家就可以在向导里选择使用（译者按：目前向导的剪贴画只有一个，可以参见前面的图片），所以如果你是个艺术设计者，我们非常欢迎你贡献些剪贴画出来！（请参见<a href="http://tools.android.com/contributing" target="_blank" rel="external">贡献页面</a>）</p>
<p>非常感谢Roman Nurik写出了这么好的网页应用并且为移植到ADT提供了帮助。</p>
<p>译自：<a href="http://tools.android.com/recent/assetstudiointegration" target="_blank" rel="external">http://tools.android.com/recent/assetstudiointegration</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="http://android-ui-utils.googlecode.com/hg/asset-studio/dist/index.html" target="_blank" rel="external">Android Asset Studio</a>W]]>
    </summary>
    
      <category term="Android" scheme="http://www.flysnow.org/tags/Android/"/>
    
      <category term="Android" scheme="http://www.flysnow.org/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Ubuntu下ADSL拨号和VPN 访问网站]]></title>
    <link href="http://www.flysnow.org/2011/10/22/adsl-and-vpn-config-for-ubuntu.html"/>
    <id>http://www.flysnow.org/2011/10/22/adsl-and-vpn-config-for-ubuntu.html</id>
    <published>2011-10-22T08:06:17.000Z</published>
    <updated>2016-05-22T10:14:57.302Z</updated>
    <content type="html"><![CDATA[<h2 id="1-更新NetworkManager">1.更新NetworkManager</h2><p>添加更新源：deb <a href="http://ppa.launchpad.net/network-manager/trunk/ubuntu" target="_blank" rel="external">http://ppa.launchpad.net/network-manager/trunk/ubuntu</a> maverick main</p>
<p>deb-src <a href="http://ppa.launchpad.net/network-manager/trunk/ubuntu" target="_blank" rel="external">http://ppa.launchpad.net/network-manager/trunk/ubuntu</a> maverick main</p>
<p>执行sudo apt-get update更新，然后打开更新管理器进行更新软件。</p>
<h2 id="2-启用NetworkManager。">2.启用NetworkManager。</h2><p>修改/etc/NetworkManager/NetworkManager.conf文件里的managed为true保存。修改/etc/network/interfaces文件，只保留最上面两行的auto lo iface lo inet loopback,然后删除/etc/resolv.conf，最后重启networkmanager sudo /etc/init.d/network-manager restart。</p>
<h2 id="3-添加DSL和VPN配置">3.添加DSL和VPN配置</h2><p>看到面板里的网络链接，编辑他，添加DSL链接，之用输入用户名和密码即可，VPN链接选用pptp协议，输入服务器地址和用户名密码即可</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="1-更新NetworkManager">1.更新NetworkManager</h2><p>添加更新源：deb <a href="http://ppa.launchpad.net/network-manager/trunk/ubuntu" target="_bla]]>
    </summary>
    
      <category term="Ubuntu" scheme="http://www.flysnow.org/tags/Ubuntu/"/>
    
      <category term="Linux" scheme="http://www.flysnow.org/categories/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android中我为什么发不了邮件--Android邮件发送详解]]></title>
    <link href="http://www.flysnow.org/2011/07/19/android-send-email-intro.html"/>
    <id>http://www.flysnow.org/2011/07/19/android-send-email-intro.html</id>
    <published>2011-07-19T06:50:52.000Z</published>
    <updated>2016-05-22T10:14:57.302Z</updated>
    <content type="html"><![CDATA[<p>Android中我为什么发不了邮件？？？我手机里明明有邮件客户端的，可我为什么不能调用它发送邮件？？？相信这是很多人会问的问题，手机里有Email客户端，可是偏偏在自己的应用里调用不了，抑或是不知道怎么调用，还有的是一直认为自己写对了，可是偏偏不能调用，无奈之下只能却网上找段代码粘贴上，ok，可以了。。可是你知道别人的代码为什么可以？你知道调用Email是怎么工作的吗？如果你又像给多人发邮件，还想发送附件，怎么做？又迷糊了吧？所以需要搞懂原理才能一通百通，举一反三，而这就是这篇博文要写的，也是你可以在这篇博文中学到的。</p>
<p>在这里你可以学到：</p>
<ol>
<li>什么是Intent和Intent Fileter</li>
</ol>
<ol>
<li>如何发送Email</li>
</ol>
<ol>
<li>如何发送特定的标题和内容的Emil</li>
</ol>
<ol>
<li>如何发送给多人</li>
</ol>
<ol>
<li>如何抄送和密送</li>
</ol>
<ol>
<li>如何发送附件</li>
</ol>
<h2 id="一：什么是Intent和Intent_Fileter">一：什么是Intent和Intent Fileter</h2><p>关于这个详细介绍请参考 :</p>
<p><a href="/2011/03/14/android-intents-and-intent-filters-one.html">Intents and Intent Filters(一)</a></p>
<p><a href="/2011/03/17/android-intents-and-intent-filters-two.html">Intents and Intent Filters(二)</a></p>
<p><a href="/2011/03/29/android-intents-and-intent-filters-three.html">Intents and Intent Filters(三)</a></p>
<h2 id="二：如何发送Email">二：如何发送Email</h2><p>通过上面就会知道Android应用之间的通信是通过Intent这个东西，如果手机中有实现了你想要功能的应用那么你就不用麻烦去实现一个拉。直接使用就可以，比如这里的发送邮件。</p>
<p>我们新建一个工程SendEmail，基于Android1.6实现。然后定义布局文件和代码如下：</p>
<pre><code>&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span>?&gt;
&lt;<span class="type">LinearLayout</span> xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span>
    android:orientation=<span class="string">"vertical"</span>
    android:layout_width=<span class="string">"fill_parent"</span>
    android:layout_height=<span class="string">"fill_parent"</span>
    &gt;
&lt;<span class="type">Button</span>
    android:id=<span class="string">"@+id/send_btn"</span>  
    android:layout_width=<span class="string">"fill_parent"</span> 
    android:layout_height=<span class="string">"wrap_content"</span> 
    android:text=<span class="string">"Send Action"</span>
    /&gt;
&lt;/<span class="type">LinearLayout</span>&gt;





 <span class="comment">/** 发送邮件测试界面
 * @author 飞雪无情
 * ＠since 2011-7-19
 */</span>
public <span class="class"><span class="keyword">class</span> <span class="title">SendEmailActivity</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Activity</span> <span class="title">implements</span> <span class="title">View</span>.<span class="title">OnClickListener</span>{</span>
    <span class="keyword">private</span> <span class="type">Button</span> mSendBtn;
    <span class="comment">/** Called when the activity is first created. */</span>
    <span class="annotation">@Override</span>
    public void onCreate(<span class="type">Bundle</span> savedInstanceState) {
        <span class="keyword">super</span>.onCreate(savedInstanceState);
        setContentView(<span class="type">R</span>.layout.main);
        mSendBtn=(<span class="type">Button</span>)findViewById(<span class="type">R</span>.id.send_btn);
        mSendBtn.setOnClickListener(<span class="keyword">this</span>);
    }
    <span class="annotation">@Override</span>
    public void onClick(<span class="type">View</span> v) {
        switch(v.getId()){
        <span class="keyword">case</span> <span class="type">R</span>.id.send_btn:
            startSendEmailIntent();
            <span class="keyword">break</span>;
        }
    }
    <span class="keyword">private</span> void startSendEmailIntent(){
        <span class="type">Intent</span> data=<span class="keyword">new</span> <span class="type">Intent</span>(<span class="type">Intent</span>.<span class="type">ACTION_SENDTO</span>);
        data.setData(<span class="type">Uri</span>.parse(<span class="string">"mailto:qq10000@qq.com"</span>));
        data.putExtra(<span class="type">Intent</span>.<span class="type">EXTRA_SUBJECT</span>, <span class="string">"这是标题"</span>);
        data.putExtra(<span class="type">Intent</span>.<span class="type">EXTRA_TEXT</span>, <span class="string">"这是内容"</span>);
        startActivity(data);
    }
}
</code></pre><p>这是我们运行应用，点击按钮就会看到如下效果:</p>
<p><img src="http://dl.iteye.com/upload/attachment/520422/f01623aa-77eb-3a1f-bf30-306092c83e0d.png" alt=""><br><img src="http://dl.iteye.com/upload/attachment/520425/ed85ef04-3760-33a4-a0e7-b4fc2701eaca.png" alt=""></p>
<h2 id="三：分析发送代码">三：分析发送代码</h2><p>主要的发送代码如下：</p>
<pre><code>Intent <span class="built_in">data</span><span class="subst">=</span><span class="literal">new</span> Intent(Intent<span class="built_in">.</span>ACTION_SENDTO);
<span class="built_in">data</span><span class="built_in">.</span>setData(Uri<span class="built_in">.</span>parse(<span class="string">"mailto:qq10000@qq.com"</span>));
<span class="built_in">data</span><span class="built_in">.</span>putExtra(Intent<span class="built_in">.</span>EXTRA_SUBJECT, <span class="string">"这是标题"</span>);
<span class="built_in">data</span><span class="built_in">.</span>putExtra(Intent<span class="built_in">.</span>EXTRA_TEXT, <span class="string">"这是内容"</span>);
startActivity(<span class="built_in">data</span>);
</code></pre><ol>
<li>首先构造一个Action为SENDTO的Action</li>
</ol>
<ol>
<li>其次创建一个Uri，他是一个mailto的邮件链接，也就是接收地址.</li>
</ol>
<ol>
<li>再通过Intent.EXTRA_SUBJECT和Intent.EXTRA_TEXT传递标题和文本的数据，记住，一定要使用这些常量，这是标准，否则Email客户端不认识，那样你传递的标题和文本就不起作用了。</li>
</ol>
<ol>
<li>然后就是startActivity进行打开，系统会根据Intent自动匹配找到能处理这个intent的应用，如图列表，有很多个，我们这里选择网易掌上邮，就打开了一个邮件发送界面，如我们所愿，邮件地址、标题和内容都在了，很成功.</li>
</ol>
<ol>
<li>intent中的数据传递是以Extra的方式进行put后传递的，然后在使用的时候getter取出使用。</li>
</ol>
<h2 id="四：发送给多人以及抄送和密送">四：发送给多人以及抄送和密送</h2><p>发送给多人以及抄送和密送都很简单，查找Intent类中的Extra常量，发送有这么三个常量:Intent.EXTRA_EMAIL,Intent.EXTRA_CC,Intent.EXTRA_BCC。这三个分别用于传递“接受人地址列表”、“抄送人地址列表”和“密送人地址列表”，传递的都是String[]类型的Email地址，如果数组中有多个地址，就可以发送给多人。发送的函数修改如下，我们看下效果:</p>
<pre><code>private <span class="keyword">void</span> startSendEmailIntent(){
        Intent data=<span class="keyword">new</span> Intent(Intent.ACTION_SENDTO);
        data.setData(<span class="built_in">Uri</span>.parse(<span class="string">"mailto:qq10000@qq.com"</span>));
        data.putExtra(Intent.EXTRA_EMAIL, <span class="keyword">new</span> <span class="built_in">String</span>[]{<span class="string">"ls8707@163.com"</span>,<span class="string">"ls8708@163.com"</span>});
        data.putExtra(Intent.EXTRA_CC, <span class="keyword">new</span> <span class="built_in">String</span>[]{<span class="string">"ls8709@163.com"</span>});
        data.putExtra(Intent.EXTRA_BCC, <span class="keyword">new</span> <span class="built_in">String</span>[]{<span class="string">"ls810@163.com"</span>});
        data.putExtra(Intent.EXTRA_SUBJECT, <span class="string">"这是标题"</span>);
        data.putExtra(Intent.EXTRA_TEXT, <span class="string">"这是内容"</span>);
        startActivity(data);
    }
</code></pre><p><img src="http://dl.iteye.com/upload/attachment/520438/c837b159-0616-3890-8344-2dd841b43585.png" alt=""></p>
<h2 id="五，发送附件">五，发送附件</h2><p>Email’客户端的发送Activity提供了两个Intent Filter，一个用于发送普通邮件，一个用户发送带有附件的邮件。区分很很容易的，发送普通邮件的那个Intent Filter配置的Action SENDTO，而带有附件的邮件则是SEND,所以是2个不一样，但是哪些比如附加“标题”，“内容”，“抄送”，“发送多人”等等还是通用的。布局文件新增一个按钮，用于发送带有附件的邮件，Activity代码也做修改。</p>
<pre><code>&lt;Button
    android:id=<span class="string">"@+id/send_to_btn"</span>  
    android:layout_width=<span class="string">"fill_parent"</span> 
    android:layout_height=<span class="string">"wrap_content"</span> 
    android:text=<span class="string">"SendTo Action"</span>/&gt;





 <span class="comment">/* * 发送邮件测试界面
 * @author 飞雪无情 
 * ＠since 2011-7-19
 */</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendEmailActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> <span class="keyword">implements</span> <span class="title">View</span>.<span class="title">OnClickListener</span></span>{
    <span class="keyword">private</span> Button mSendBtn;
    <span class="keyword">private</span> Button mSendToBtn;
    <span class="javadoc">/** Called when the activity is first created. */</span>
    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>{
        <span class="keyword">super</span>.onCreate(savedInstanceState);
        setContentView(R.layout.main);
        mSendBtn=(Button)findViewById(R.id.send_btn);
        mSendToBtn=(Button)findViewById(R.id.send_to_btn);
        mSendBtn.setOnClickListener(<span class="keyword">this</span>);
        mSendToBtn.setOnClickListener(<span class="keyword">this</span>);
    }
    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>{
        <span class="keyword">switch</span>(v.getId()){
        <span class="keyword">case</span> R.id.send_btn:
            startSendEmailIntent();
            <span class="keyword">break</span>;
        <span class="keyword">case</span> R.id.send_to_btn:
            startSendToEmailIntent();
            <span class="keyword">break</span>;
        }
    }
    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startSendEmailIntent</span><span class="params">()</span></span>{
        Intent data=<span class="keyword">new</span> Intent(Intent.ACTION_SENDTO);
        data.setData(Uri.parse(<span class="string">"mailto:qq10000@qq.com"</span>));
        data.putExtra(Intent.EXTRA_EMAIL, <span class="keyword">new</span> String[]{<span class="string">"ls8707@163.com"</span>,<span class="string">"ls8708@163.com"</span>});
        data.putExtra(Intent.EXTRA_CC, <span class="keyword">new</span> String[]{<span class="string">"ls8709@163.com"</span>});
        data.putExtra(Intent.EXTRA_BCC, <span class="keyword">new</span> String[]{<span class="string">"ls810@163.com"</span>});
        data.putExtra(Intent.EXTRA_SUBJECT, <span class="string">"这是标题"</span>);
        data.putExtra(Intent.EXTRA_TEXT, <span class="string">"这是内容"</span>);
        startActivity(data);
    }
    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startSendToEmailIntent</span><span class="params">()</span></span>{
        Intent data=<span class="keyword">new</span> Intent(Intent.ACTION_SEND);
        data.putExtra(Intent.EXTRA_EMAIL, <span class="keyword">new</span> String[]{<span class="string">"ls8707@163.com"</span>});
        data.putExtra(Intent.EXTRA_SUBJECT, <span class="string">"这是标题"</span>);
        data.putExtra(Intent.EXTRA_TEXT, <span class="string">"这是内容"</span>);
        data.putExtra(Intent.EXTRA_STREAM, Uri.parse(<span class="string">""</span>));
        data.setType(<span class="string">"text/plain"</span>);
        startActivity(data);
    }
}
</code></pre><p>运行应用，我们看到效果图里最小面的附件标识，说明已经可以发送附件了.</p>
<p><img src="http://dl.iteye.com/upload/attachment/520458/5ebe4f65-d647-3e0e-8a28-c351e8b5fccb.png" alt=""></p>
<p>发送附件最重要的就是Action必须为SEND，type一定要设置setType(“”),还要为Intent.EXTRA_STREAM赋值，类型为Uri，一个附件的Uri。这样才能发送附件。</p>
<h2 id="六，客户端Email应用的发送Activity配置">六，客户端Email应用的发送Activity配置</h2><p>这是Android1.6自带Email客户端的配置，如下：</p>
<pre><code><span class="tag">&lt;<span class="title">activity</span>
            <span class="attribute">android:name</span>=<span class="value">".activity.MessageCompose"</span>
            <span class="attribute">android:label</span>=<span class="value">"@string/app_name"</span>
            <span class="attribute">android:enabled</span>=<span class="value">"false"</span>
            &gt;</span>
            <span class="tag">&lt;<span class="title">intent-filter</span>&gt;</span>
                <span class="tag">&lt;<span class="title">action</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.action.VIEW"</span> /&gt;</span>
                <span class="tag">&lt;<span class="title">action</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.action.SENDTO"</span> /&gt;</span>
                <span class="tag">&lt;<span class="title">data</span> <span class="attribute">android:scheme</span>=<span class="value">"mailto"</span> /&gt;</span>
                <span class="tag">&lt;<span class="title">category</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.category.DEFAULT"</span> /&gt;</span>
                <span class="tag">&lt;<span class="title">category</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.category.BROWSABLE"</span> /&gt;</span>
            <span class="tag">&lt;/<span class="title">intent-filter</span>&gt;</span>
            <span class="tag">&lt;<span class="title">intent-filter</span> <span class="attribute">android:label</span>=<span class="value">"@string/app_name"</span>&gt;</span>
                <span class="tag">&lt;<span class="title">action</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.action.SEND"</span> /&gt;</span>
                <span class="tag">&lt;<span class="title">data</span> <span class="attribute">android:mimeType</span>=<span class="value">"text/plain"</span> /&gt;</span>
                <span class="tag">&lt;<span class="title">data</span> <span class="attribute">android:mimeType</span>=<span class="value">"image/*"</span> /&gt;</span>
                <span class="tag">&lt;<span class="title">data</span> <span class="attribute">android:mimeType</span>=<span class="value">"video/*"</span> /&gt;</span>
                <span class="tag">&lt;<span class="title">category</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.category.DEFAULT"</span> /&gt;</span>
            <span class="tag">&lt;/<span class="title">intent-filter</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">activity</span>&gt;</span>
</code></pre><p>从以上代码总结:</p>
<ol>
<li>一个Activity定义了2个Intent Filter用于发送不同类型邮件。</li>
</ol>
<ol>
<li>SENDTO发送普通邮件，SEND可以发送普通和带有附件的，不过最好主要用于发送附件。</li>
</ol>
<ol>
<li>使用SENDTO时，必须为Intent设置Data，也就是Uri，内容为”mailto:emailaddr”,否则不能匹配，因为有schema必须为mailto的限制</li>
</ol>
<ol>
<li>使用SEND时必须要设置type，也就是使用setType()方法，type只能为以前xml定义的4个。不过我测试了text/*也可以，其他的没测试.</li>
</ol>
<ol>
<li>发送附件只能使用SEND这个Action.</li>
</ol>
<p>附加Email客户端中提取Email地址，抄送，标题，附件等信息的源代码分析.</p>
<pre><code><span class="keyword">void</span> initFromIntent(Intent intent) {

        <span class="comment">//提取接受人地址列表</span>
        <span class="keyword">String</span>[] extraStrings = intent.getStringArrayExtra(Intent.EXTRA_EMAIL);
        <span class="keyword">if</span> (extraStrings != <span class="keyword">null</span>) {
            addAddresses(mToView, extraStrings);
        }
<span class="comment">//提取抄送人地址列表</span>
        extraStrings = intent.getStringArrayExtra(Intent.EXTRA_CC);
        <span class="keyword">if</span> (extraStrings != <span class="keyword">null</span>) {
            addAddresses(mCcView, extraStrings);
        }
<span class="comment">//提取密送人地址列表</span>
        extraStrings = intent.getStringArrayExtra(Intent.EXTRA_BCC);
        <span class="keyword">if</span> (extraStrings != <span class="keyword">null</span>) {
            addAddresses(mBccView, extraStrings);
        }
<span class="comment">//提取标题</span>
        <span class="keyword">String</span> extraString = intent.getStringExtra(Intent.EXTRA_SUBJECT);
        <span class="keyword">if</span> (extraString != <span class="keyword">null</span>) {
            mSubjectView.setText(extraString);
        }

        <span class="comment">//提取Uri中的接受人地址</span>
        <span class="keyword">final</span> Uri dataUri = intent.getData();
        <span class="keyword">if</span> (dataUri != <span class="keyword">null</span>) {
            <span class="keyword">if</span> (<span class="string">"mailto"</span>.equals(dataUri.getScheme())) {
                initializeFromMailTo(dataUri.toString());
            } <span class="keyword">else</span> {
                <span class="keyword">String</span> toText = dataUri.getSchemeSpecificPart();
                <span class="keyword">if</span> (toText != <span class="keyword">null</span>) {
                    addAddresses(mToView, toText.<span class="built_in">split</span>(<span class="string">","</span>));
                }
            }
        }

       <span class="comment">//提取邮件内容</span>

        CharSequence <span class="built_in">text</span> = intent.getCharSequenceExtra(Intent.EXTRA_TEXT);
        <span class="keyword">if</span> (<span class="built_in">text</span> != <span class="keyword">null</span>) {
            mMessageContentView.setText(<span class="built_in">text</span>);
        }

      <span class="comment">//提取附件，可以看出Action必须是SEND.EXTRA_STREAM中有数据</span>
     <span class="comment">//type不能为null,这样才能提取倒附件.</span>

        <span class="keyword">if</span> (Intent.ACTION_SEND.equals(intent.getAction()) &amp;&amp; intent.hasExtra(Intent.EXTRA_STREAM)) {
            <span class="keyword">String</span> type = intent.getType();
            Uri stream = (Uri) intent.getParcelableExtra(Intent.EXTRA_STREAM);
            <span class="keyword">if</span> (stream != <span class="keyword">null</span> &amp;&amp; type != <span class="keyword">null</span>) {
                <span class="keyword">if</span> (MimeUtility.mimeTypeMatches(type, Email.ACCEPTABLE_ATTACHMENT_SEND_TYPES)) {
                    addAttachment(stream);
                }
            }
        }

        <span class="comment">// Finally - expose fields that were filled in but are normally hidden, and set focus</span>

        <span class="keyword">if</span> (mCcView.length() &gt; <span class="number">0</span>) {
            mCcView.setVisibility(View.VISIBLE);
        }
        <span class="keyword">if</span> (mBccView.length() &gt; <span class="number">0</span>) {
            mBccView.setVisibility(View.VISIBLE);
        }
        setNewMessageFocus();
        mDraftNeedsSaving = <span class="keyword">false</span>;
    }
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>Android中我为什么发不了邮件？？？我手机里明明有邮件客户端的，可我为什么不能调用它发送邮件？？？相信这是很多人会问的问题，手机里有Email客户端，可是偏偏在自己的应用里调用不了，抑或是不知道怎么调用，还有的是一直认为自己写对了，可是偏偏不能调用，无奈之下只能却网上找]]>
    </summary>
    
      <category term="Android" scheme="http://www.flysnow.org/tags/Android/"/>
    
      <category term="Email" scheme="http://www.flysnow.org/tags/Email/"/>
    
      <category term="Android" scheme="http://www.flysnow.org/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[高效程序员的45个习惯--敏捷开发修炼之道]]></title>
    <link href="http://www.flysnow.org/2011/07/17/practices-of-an-agile-developer.html"/>
    <id>http://www.flysnow.org/2011/07/17/practices-of-an-agile-developer.html</id>
    <published>2011-07-17T02:09:52.000Z</published>
    <updated>2016-05-22T10:14:57.302Z</updated>
    <content type="html"><![CDATA[<p>笔者 写道<br>在去年就在豆瓣上看到这本不错的书，近来才拿到这本书好好的研读一下。读了之后又对本书有了更深的认识。我如此推崇她，因为我觉得她不像有些书那样的长篇大论，讲的都是大道理，看了云里雾里的。而这本书呢，讲的都是我们项目开发中实实在在遇到的，只是平时不太注意，作者只是用更朴素易懂的语言组织总结出来的一个个好习惯。</p>
<p>本书的文字言简意赅，写作方式采用坏习惯和好习惯的对比方式，当时也许你觉得这些习惯有点偏激，不过不要烦恼，因为每个习惯的最后作者都给出了中庸平衡之道。</p>
<p>相信很多人都有这本书，但是也有没有的，或者还不知道这本书，为了加深我自己对这45个习惯的理解和为了让更多的人知道、了解这45个习惯，所以我在这篇博客中记录下这45个习惯。前面我也提了，这本书言简意赅，所以对于习惯的总结更是如此，让我们可以一看到习惯的标题，就知道这个习惯的精髓所在。</p>
<h3 id="态度决定一切">态度决定一切</h3><ol>
<li>做事</li>
</ol>
<ol>
<li>欲速则不达</li>
</ol>
<ol>
<li>对事不对人</li>
</ol>
<ol>
<li>排除万难，奋勇前进</li>
</ol>
<h3 id="学无止境">学无止境</h3><ol>
<li>跟踪变化</li>
</ol>
<ol>
<li>对团队投资</li>
</ol>
<ol>
<li>懂得丢弃</li>
</ol>
<ol>
<li>打破沙锅问到底</li>
</ol>
<ol>
<li>把握开发节奏</li>
</ol>
<h3 id="交付用户想要的软件">交付用户想要的软件</h3><ol>
<li>让客户做决定</li>
</ol>
<ol>
<li>让设计指导而不是操纵开发</li>
</ol>
<ol>
<li>合理地使用技术</li>
</ol>
<ol>
<li>保持可以发布</li>
</ol>
<ol>
<li>提早集成，频繁集成</li>
</ol>
<ol>
<li>提早实现自动化部署</li>
</ol>
<ol>
<li>使用演示获得频繁反馈</li>
</ol>
<ol>
<li>使用短迭代，增量发布</li>
</ol>
<ol>
<li>固定的价格就意味着背叛承诺</li>
</ol>
<h3 id="敏捷反馈">敏捷反馈</h3><ol>
<li>守护天使（单元测试）</li>
</ol>
<ol>
<li>先用它再实现它</li>
</ol>
<ol>
<li>不同环境，就有不用问题</li>
</ol>
<ol>
<li>自动验收测试</li>
</ol>
<ol>
<li>度量真实的进度</li>
</ol>
<ol>
<li>倾听用户的声音</li>
</ol>
<h3 id="敏捷编码">敏捷编码</h3><ol>
<li>代码要清晰地表达意图</li>
</ol>
<ol>
<li>用代码沟通</li>
</ol>
<ol>
<li>动态评估取舍</li>
</ol>
<ol>
<li>增量式编程</li>
</ol>
<ol>
<li>保持简单</li>
</ol>
<ol>
<li>编写内聚的代码</li>
</ol>
<ol>
<li>告知，不要询问</li>
</ol>
<ol>
<li>根据契约进行替换</li>
</ol>
<h3 id="敏捷调试">敏捷调试</h3><ol>
<li>记录问题解决日志</li>
</ol>
<ol>
<li>警告就是错误</li>
</ol>
<ol>
<li>对问题各个击破</li>
</ol>
<ol>
<li>报告所有的异常</li>
</ol>
<ol>
<li>提供有用的错误信息</li>
</ol>
<h3 id="敏捷协作">敏捷协作</h3><ol>
<li>定期安排会面时间</li>
</ol>
<ol>
<li>架构师必须写代码</li>
</ol>
<ol>
<li>实行代码集体所有制</li>
</ol>
<ol>
<li>成为指导者</li>
</ol>
<ol>
<li>允许大家自己想办法</li>
</ol>
<ol>
<li>准备好后再共享代码</li>
</ol>
<ol>
<li>进行代码复查</li>
</ol>
<ol>
<li>及时通报进展与问题</li>
</ol>
<p>笔者 写道</p>
<p>这些都是些很不错的习惯，如果有你没有用到的，可以试着使用一下，有条件的也可以在团队推广使用，看看是否能带来惊喜。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>笔者 写道<br>在去年就在豆瓣上看到这本不错的书，近来才拿到这本书好好的研读一下。读了之后又对本书有了更深的认识。我如此推崇她，因为我觉得她不像有些书那样的长篇大论，讲的都是大道理，看了云里雾里的。而这本书呢，讲的都是我们项目开发中实实在在遇到的，只是平时不太注意，作者只]]>
    </summary>
    
      <category term="敏捷" scheme="http://www.flysnow.org/tags/%E6%95%8F%E6%8D%B7/"/>
    
      <category term="软件工程" scheme="http://www.flysnow.org/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="软件开发" scheme="http://www.flysnow.org/tags/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
      <category term="软件开发" scheme="http://www.flysnow.org/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android中关于线程使用的几点注意事项]]></title>
    <link href="http://www.flysnow.org/2011/05/21/android-thread-notice-item.html"/>
    <id>http://www.flysnow.org/2011/05/21/android-thread-notice-item.html</id>
    <published>2011-05-21T06:43:55.000Z</published>
    <updated>2016-05-22T10:14:57.302Z</updated>
    <content type="html"><![CDATA[<p>我们都知道Android是单线程模型，这意味着Android UI操作并不是线程安全的并且这些操作必须在UI线程中执行，所以你单纯的new一个Thrad并且start()不行的，因为这违背了Android的单线程模型。</p>
<p>很幸运的是Android为我们提供了在其他线程中访问UI线程的方法，相信大家都见过，这几个就是Activity的runOnUiThread方法，View的post和postDelayed方法，以及最常用的Hanlder和AsyncTask，这里我推荐使用Hanlder和AsyncTask，尤其是AsyncTask，因为使用他们你会发现你的代码很容易被理解，因为他们都有一些具有特定职责的方法，尤其是AsyncTask，有预处理的方法onPreExecute，有后台执行任务的方法doInBackground，有更新进度的方法publishProgress，有返回结果的方法onPostExecute等等，这就不像post这些方法，把所有的操作都一大坨的写在一个Runnable里。</p>
<p>有了Android为我们提供了这些方法我们就可以很好的解决一些长时间处理的任务了，但是在使用的时候我们还必须注意以下几点：</p>
<ol>
<li>这些方法或者类必须在在UI线程中创建和调用</li>
</ol>
<ol>
<li>其实这些方法和类最终的实现都是Android的Message、MessageQueue和Looper的机制，所以不要期待你会马上看到结果（效果），因为这是一个Loop一直循环出MessageQueue中的Message执行的过程，如果你没有看到效果，那么等等吧，因为还没有轮到你。</li>
</ol>
<ol>
<li>有线程（多个）的地方就会有并发，会有资源共享冲突，所以在使用的时候谨慎点吧，说不准你的一个线程中使用的变量已经被另一个线程改的面目全非了。。</li>
</ol>
<p>后语：忙的很久没有写博客了，搭黑写了平时总结的线程的注意事项，demo就不写了，相信大家都会，此外多了解点Android的消息机制对于这个理解比较好的多。。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>我们都知道Android是单线程模型，这意味着Android UI操作并不是线程安全的并且这些操作必须在UI线程中执行，所以你单纯的new一个Thrad并且start()不行的，因为这违背了Android的单线程模型。</p>
<p>很幸运的是Android为我们提供了在其]]>
    </summary>
    
      <category term="Android" scheme="http://www.flysnow.org/tags/Android/"/>
    
      <category term="Android" scheme="http://www.flysnow.org/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android Intents and Intent Filters(三)]]></title>
    <link href="http://www.flysnow.org/2011/03/29/android-intents-and-intent-filters-three.html"/>
    <id>http://www.flysnow.org/2011/03/29/android-intents-and-intent-filters-three.html</id>
    <published>2011-03-28T18:02:48.000Z</published>
    <updated>2016-05-22T10:14:57.302Z</updated>
    <content type="html"><![CDATA[<h2 id="数据(data)检测">数据(data)检测</h2><p>data标记也是在intent-filter中定义的，大致格式如下:</p>
<pre><code><span class="tag">&lt;<span class="title">intent-filter</span>&gt;</span>
                <span class="tag">&lt;<span class="title">action</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.action.VIEW"</span>&gt;</span><span class="tag">&lt;/<span class="title">action</span>&gt;</span>
                <span class="tag">&lt;<span class="title">category</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.category.DEFAULT"</span>&gt;</span><span class="tag">&lt;/<span class="title">category</span>&gt;</span>
                <span class="tag">&lt;<span class="title">data</span> <span class="attribute">android:mimeType</span>=<span class="value">"text/plain"</span>&gt;</span><span class="tag">&lt;/<span class="title">data</span>&gt;</span>
            <span class="tag">&lt;/<span class="title">intent-filter</span>&gt;</span>
</code></pre><p>每个data定义一个URI和数据类型(MIME)，URI由4个属性来定义，分别是android:scheme,android:host,android:port,android:path..这个四个属性构成如下格式的URI:<br>scheme://host:port/path</p>
<p>如：content://com.flysnow.intent:8080/show/view。其中content就是scheme，com.flysnow.intent就是host，8080就是port,show/view就是path…如果有经常使用ContentProvider的应该熟悉。。我们经常定义的authority不就是host+port吗？还有这几个元素都是可选的，但是不是随便用就可以的，port要依赖于host，没有host，port就会被忽略，不起作用，同样，如果要使用host+port(authority)就必须指定scheme。而path则依赖于scheme和authority。。</p>
<p>还有一个很重要的类型就是mimeType,这个属性用于指定内容的类型，也就是这个组件可以处理哪些类型的内容。。如text/plain表示无格式文本类型，mimeType也支持通配符，使用text/*则表示所有文本类型。通过使用它，你可以很方便的开发出关联打开诸如txt文件，pdf文件的应用。后面的两个自理将会演示txt文件查看器，图片查看器的例子。。MIME可以参考<a href="http://www.w3school.com.cn/media/media_mimeref.asp。这里有所有的内容类型的定义。。" target="_blank" rel="external">http://www.w3school.com.cn/media/media_mimeref.asp。这里有所有的内容类型的定义。。</a></p>
<h3 id="开发实例-拨打电话，text阅读器和图片查看器">开发实例-拨打电话，text阅读器和图片查看器</h3><h3 id=""> </h3><p>下面通过一个例子来演示data的检测,项目名为Intents,应用名为Intents and Filters，运行在Android2.2版本上.主启动Activity为IntentsTestList。例子包括以下演示：</p>
<ol>
<li>通过发送intent的方式“打开拨号界面并输入电话123456”。</li>
</ol>
<ol>
<li>创建一个Text文件阅读器</li>
</ol>
<ol>
<li>创建一个图片查看器</li>
</ol>
<p>首先我们实现第一项，修改IntentsTestList类如下：</p>
<pre><code><span class="comment">/**
 * Intents测试列表类
 * @author 飞雪无情
 * @since 2011-3-14
 */</span>
<span class="keyword">public</span> <span class="keyword">class</span> <span class="title">IntentsTestList</span> <span class="title">extends</span> <span class="title">ListActivity</span> {
    <span class="comment">/** Called when the activity is first created. */</span>
    @<span class="function">Override
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>{
        super.onCreate(savedInstanceState);
      <span class="comment">//定义ListAdapter</span>
        setListAdapter(<span class="keyword">new</span> SimpleAdapter(<span class="keyword">this</span>, getData(),
                android.R.layout.simple_list_item_1, <span class="keyword">new</span> String[] { <span class="string">"title"</span> },<span class="keyword">new</span> <span class="keyword">int</span>[] {android.R.id.text1}));
        getListView().setTextFilterEnabled(<span class="keyword">true</span>);
    }
    @<span class="function">Override
    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onListItemClick</span><span class="params">(ListView l, View v, <span class="keyword">int</span> position, <span class="keyword">long</span> id)</span> </span>{
        Intent intent=(Intent)getData().<span class="keyword">get</span>(position).<span class="keyword">get</span>(<span class="string">"intent"</span>);
        Boolean isActivity=(Boolean)getData().<span class="keyword">get</span>(position).<span class="keyword">get</span>(<span class="string">"isActivity"</span>);
        <span class="keyword">if</span>(isActivity){
            startActivity(intent);
        }<span class="keyword">else</span>{
            sendBroadcast(intent);
        }
    }

    <span class="comment">/**
     * 返回ListView需要的数据
     * @return ListView需要的数据
     */</span>
    <span class="keyword">private</span> List&lt;map&lt;<span class="keyword">string</span>,<span class="keyword">object</span>&gt;&gt; getData() {
        List&lt;map&lt;<span class="keyword">string</span>,<span class="keyword">object</span>&gt;&gt; data=<span class="keyword">new</span> ArrayList&lt;map&lt;<span class="keyword">string</span>,<span class="keyword">object</span>&gt;&gt;();
        addItem(data, <span class="string">"打开拨号界面并输入电话123456"</span>, <span class="keyword">new</span> Intent(Intent.ACTION_DIAL, Uri.parse(<span class="string">"tel://123456"</span>)), <span class="keyword">true</span>);
        <span class="keyword">return</span> data;
    }
    <span class="comment">/**
     * 给ListView添加数据
     * @param data 存储数据的List
     * @param name 要显示的Title
     * @param intent 单击某一项时要启动的Activity
     * @param isActivity 启动的是否是Activity，true是，false为广播
     */</span>
    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addItem</span><span class="params">(List&lt;map&lt;<span class="keyword">string</span>,<span class="keyword">object</span>&gt;&gt; data, String name, Intent intent,boolean isActivity)</span> </span>{
        Map&lt;<span class="keyword">string</span>, <span class="keyword">object</span>=<span class="string">""</span>&gt; temp = <span class="keyword">new</span> HashMap&lt;<span class="keyword">string</span>, <span class="keyword">object</span>=<span class="string">""</span>&gt;();
        temp.put(<span class="string">"title"</span>, name);
        temp.put(<span class="string">"intent"</span>, intent);
        temp.put(<span class="string">"isActivity"</span>, isActivity);
        data.add(temp);
    }

}
</code></pre><p>这时我们运行程序，单击“打开拨号界面并输入电话123456”就会打开系统的自带的拨号界面，并且默认已经录入了要拨打的号码“123456”。效果图如下：<br><img src="http://dl.iteye.com/upload/attachment/449159/2d492720-aea1-316f-a85f-52e465d8b106.png" alt=""></p>
<p><img src="http://dl.iteye.com/upload/attachment/449161/b0112c45-6c10-351d-a538-80b8b0a34b6c.png" alt=""></p>
<h3 id="然后我们实现第二功能-txt文件阅读器">然后我们实现第二功能-txt文件阅读器</h3><p>新建TextWatcherActivity代码如下：</p>
<pre><code><span class="javadoc">/**
 * 显示文本的Activity
 *<span class="javadoctag"> @author</span> 飞雪无情
 *<span class="javadoctag"> @since</span> 2011-3-24
 */</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TextWatcherActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>{
    <span class="keyword">private</span> TextView mTextView;

    <span class="annotation">@Override</span>
    <span class="keyword">protected</span> <span class="function"><span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>{
        <span class="keyword">super</span>.onCreate(savedInstanceState);
        mTextView=<span class="keyword">new</span> TextView(<span class="keyword">this</span>);
        setContentView(mTextView);
    }

    <span class="annotation">@Override</span>
    <span class="keyword">protected</span> <span class="function"><span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>{
        <span class="keyword">super</span>.onStart();
        Intent txtIntent=getIntent();
        Uri data=txtIntent.getData();
        String txt;
        <span class="keyword">try</span> {
            txt = readTxt(data);
        } <span class="keyword">catch</span> (IOException e) {
            txt=<span class="string">"打开txt文件异常"</span>;
        }
        mTextView.setText(txt);
    }
    <span class="javadoc">/**
     * 读取txt文本
     *<span class="javadoctag"> @param</span> txtUri
     *<span class="javadoctag"> @return</span>
     *<span class="javadoctag"> @throws</span> IOException
     */</span>
    <span class="keyword">private</span> <span class="function">String <span class="title">readTxt</span><span class="params">(Uri txtUri)</span> <span class="keyword">throws</span> IOException</span>{
        BufferedReader bufferedReader=<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(getContentResolver().openInputStream(txtUri),Charset.forName(<span class="string">"GBK"</span>)));
        StringBuilder txt=<span class="keyword">new</span> StringBuilder();
        String buf=<span class="string">""</span>;
        <span class="keyword">while</span>((buf=bufferedReader.readLine())!=<span class="keyword">null</span>){
            txt.append(buf).append(<span class="string">"\n"</span>);
        }
        <span class="function"><span class="keyword">return</span> txt.<span class="title">toString</span><span class="params">()</span></span>;
    }

}
</code></pre><p>然后在AndroidManifest.xml中加入如下定义:</p>
<pre><code><span class="tag">&lt;<span class="title">activity</span> <span class="attribute">android:name</span>=<span class="value">".TextWatcherActivity"</span>
            <span class="attribute">android:label</span>=<span class="value">"查看TXT文件"</span>&gt;</span>
            <span class="tag">&lt;<span class="title">intent-filter</span>&gt;</span>
                <span class="tag">&lt;<span class="title">action</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.action.VIEW"</span>&gt;</span><span class="tag">&lt;/<span class="title">action</span>&gt;</span>
                <span class="tag">&lt;<span class="title">category</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.category.DEFAULT"</span>&gt;</span><span class="tag">&lt;/<span class="title">category</span>&gt;</span>
                <span class="tag">&lt;<span class="title">data</span> <span class="attribute">android:mimeType</span>=<span class="value">"text/plain"</span>&gt;</span><span class="tag">&lt;/<span class="title">data</span>&gt;</span>
            <span class="tag">&lt;/<span class="title">intent-filter</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">activity</span>&gt;</span>
</code></pre><p>这样在单击txt文件的时候就可以选择我们的这个Activity对txt文件处理，显示其内容.我们新建一个1.txt文件，写上一些内容，放在我们的sd卡中，使用文件管理工具查看这个txt文件，会弹出如下图的提示，看到我们刚刚做的《TXT阅读器》了吧。</p>
<p><img src="http://dl.iteye.com/upload/attachment/449475/079e5ed7-7342-39bf-95af-c95ec024681c.png" alt=""></p>
<p>选择“查看TXT文件”，就可以看到我们的txt内容：</p>
<p><img src="http://dl.iteye.com/upload/attachment/449477/e1fb042a-0555-3e43-b225-7fe7fce94dad.png" alt=""></p>
<h3 id="最后实现第三个功能—图片查看器">最后实现第三个功能—图片查看器</h3><p>新建ImageWatcherActivity，代码如下：</p>
<pre><code><span class="javadoc">/**
 * 显示文本的Activity
 *<span class="javadoctag"> @author</span> 飞雪无情
 *<span class="javadoctag"> @since</span> 2011-3-24
 */</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageWatcherActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>{
    <span class="keyword">private</span> <span class="keyword">final</span> String IMAGE_URI_KEY=<span class="string">"imageUriKey"</span>;
    <span class="keyword">private</span> Uri image;
    <span class="keyword">private</span> ImageView mImageView;

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>{
        <span class="keyword">super</span>.onCreate(savedInstanceState);
        mImageView=<span class="keyword">new</span> ImageView(<span class="keyword">this</span>);
        setContentView(mImageView);
    }

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>{
        <span class="keyword">super</span>.onStart();
        Intent txtIntent=getIntent();
        image=txtIntent.getData();
        <span class="comment">//对于大图片未做优化处理</span>
        mImageView.setImageURI(image);
    }

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onRestoreInstanceState</span><span class="params">(Bundle savedInstanceState)</span> </span>{
        <span class="keyword">super</span>.onRestoreInstanceState(savedInstanceState);
        image=savedInstanceState.getParcelable(IMAGE_URI_KEY);
        mImageView.setImageURI(image);
    }

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onSaveInstanceState</span><span class="params">(Bundle outState)</span> </span>{
        <span class="keyword">super</span>.onSaveInstanceState(outState);
        outState.putParcelable(IMAGE_URI_KEY,image);
    }

}
</code></pre><p>然后在AndroidManifest.xml中加入如下定义:</p>
<pre><code><span class="tag">&lt;<span class="title">activity</span> <span class="attribute">android:name</span>=<span class="value">".ImageWatcherActivity"</span>
            <span class="attribute">android:label</span>=<span class="value">"查看图片文件"</span>&gt;</span>
            <span class="tag">&lt;<span class="title">intent-filter</span>&gt;</span>
                <span class="tag">&lt;<span class="title">action</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.action.VIEW"</span>&gt;</span><span class="tag">&lt;/<span class="title">action</span>&gt;</span>
                <span class="tag">&lt;<span class="title">category</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.category.DEFAULT"</span>&gt;</span><span class="tag">&lt;/<span class="title">category</span>&gt;</span>
                <span class="tag">&lt;<span class="title">data</span> <span class="attribute">android:mimeType</span>=<span class="value">"image/*"</span>&gt;</span><span class="tag">&lt;/<span class="title">data</span>&gt;</span>
            <span class="tag">&lt;/<span class="title">intent-filter</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">activity</span>&gt;</span>
</code></pre><p>这样在单击图片文件的时候就可以选择我们的这个Activity对txt文件处理并且显示。</p>
<p><img src="http://dl.iteye.com/upload/attachment/449481/9b6c7d30-4ed9-3fb4-8615-42dea2f0e02c.png" alt=""></p>
<p><img src="http://dl.iteye.com/upload/attachment/449483/dba27c5a-45df-3339-9fa6-e2135cff7fb6.png" alt=""></p>
<h3 id="数据(data)检测小结">数据(data)检测小结</h3><p>对于data的匹配，如果说怎么怎么匹配，在什么情况下通过可能会比较难以理解，这里以一种简单的方式来解说。</p>
<p>假定我们定义的Intent Filter 的data标签为集合A，传递的Intent中包含的data为集合B，当B是A的子集时就通过了（Action和Category也得检测通过）。如果B为空（不配置data），那么A也得为空（不配置data）才能通过<br>。更详细（繁琐）的介绍请参考doc</p>
<h3 id="Intents_and_Intent_Filters总结">Intents and Intent Filters总结</h3><p>Android提供了以Intent的方式调用Android设备的内置Google应用，比如打电话，调用Google浏览器打开网页，搜索等。关于这方便的介绍可以参考Android开发文档《Intents List: Invoking Google Applications on Android Devices》这一节的介绍，很详细。docs/guide/appendix/g-app-intents.html。</p>
<p>Intent是一个很好的设计，它提供了一种在各个组建之间通信的方式，也为我们使用其他的应用的功能提供了可能，这样如果我们想在自己的应用打开一个网页，我们就不用特意迁入一个webview，我们直接调用Android内的浏览器打开即可。。</p>
<p>最后值得一提的是PackageManager这个类中为我们提供了一系列的query…()方法，可以让我们根据我们定义的Intent查询特定的匹配Intent Filter标记的所有组件。。有兴趣的可以研究一下。。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="数据(data)检测">数据(data)检测</h2><p>data标记也是在intent-filter中定义的，大致格式如下:</p>
<pre><code><span class="tag">&lt;<span class="title">intent-fil]]>
    </summary>
    
      <category term="Android" scheme="http://www.flysnow.org/tags/Android/"/>
    
      <category term="Intent" scheme="http://www.flysnow.org/tags/Intent/"/>
    
      <category term="Android" scheme="http://www.flysnow.org/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[android.resource://这个Uri你知道吗]]></title>
    <link href="http://www.flysnow.org/2011/03/28/do-you-know-android-resource.html"/>
    <id>http://www.flysnow.org/2011/03/28/do-you-know-android-resource.html</id>
    <published>2011-03-27T19:22:31.000Z</published>
    <updated>2016-05-22T10:14:57.302Z</updated>
    <content type="html"><![CDATA[<p>如何访问平时APK文件Res目录下的内容呢? 如果直接访问Apk下的assets目录可以使用AssetManager类处理，而需要访问<br>res/raw这样的文件夹怎么办呢? 这里Android123可以告诉大家APK在安装时已经解压缩，部分资源存放在/data/data<br>/package_name/这里， 比如我们想访问res/raw/android123.cwj文件，可以使用android.resource:<br>//package_name/“ + R.raw.android123 这个Uri，其中package_name是你工程的包名。<br>完整的处理代码为 Uri uri = Uri.parse(“android.resource://com.android123.Sample/raw/android123.cwj”); 即可使用工程res/raw目录下的文件了。</p>
<p>转自：<a href="http://www.android123.com.cn/androidkaifa/827.html" target="_blank" rel="external">http://www.android123.com.cn/androidkaifa/827.html</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>如何访问平时APK文件Res目录下的内容呢? 如果直接访问Apk下的assets目录可以使用AssetManager类处理，而需要访问<br>res/raw这样的文件夹怎么办呢? 这里Android123可以告诉大家APK在安装时已经解压缩，部分资源存放在/data/dat]]>
    </summary>
    
      <category term="Android" scheme="http://www.flysnow.org/tags/Android/"/>
    
      <category term="Android" scheme="http://www.flysnow.org/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android Intents and Intent Filters(二)]]></title>
    <link href="http://www.flysnow.org/2011/03/17/android-intents-and-intent-filters-two.html"/>
    <id>http://www.flysnow.org/2011/03/17/android-intents-and-intent-filters-two.html</id>
    <published>2011-03-17T00:41:02.000Z</published>
    <updated>2016-05-22T10:14:57.302Z</updated>
    <content type="html"><![CDATA[<h2 id="Category（类别）检测">Category（类别）检测</h2><p>类别在中是通过标记定义的,Category和Action一样，他们的名字都是一个字符串定义，但是我们在代码中可以使用对应的类别常量，在xml文件定义中只能使用定义好的字符串。Android的Intent类中提供了很多内置的类别定义，一中类别代表一个意思，可以参考说明使用。。比如android.intent.category.LAUNCHER标表示你的应用会展示在启动列表页面，经常和android.intent.action.MAIN搭配使用</p>
<p>下面通过一个例子来说明Category的检测,项目名为Intents,应用名为Intents and Filters，运行在Android2.2版本上.主启动Activity为IntentsTestList。</p>
<p>IntentsTestList代码如下:</p>
<pre><code><span class="comment">/**
 * Intents测试列表类
 * @author 飞雪无情
 * @since 2011-3-14
 */</span>
<span class="keyword">public</span> <span class="keyword">class</span> <span class="title">IntentsTestList</span> <span class="title">extends</span> <span class="title">ListActivity</span> {
    <span class="keyword">private</span> String ACTION_VIEW=<span class="string">"com.flysnow.intent.ACTION_VIEW"</span>;
    <span class="keyword">private</span> String CATEGORY_MAN=<span class="string">"com.flysnow.intent.CATEGORY_MAN"</span>;
    <span class="keyword">private</span> String CATEGORY_SHOP=<span class="string">"com.flysnow.intent.CATEGORY_SHOP"</span>;
    <span class="comment">/** Called when the activity is first created. */</span>
    @<span class="function">Override
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>{
        super.onCreate(savedInstanceState);
      <span class="comment">//定义ListAdapter</span>
        setListAdapter(<span class="keyword">new</span> SimpleAdapter(<span class="keyword">this</span>, getData(),
                android.R.layout.simple_list_item_1, <span class="keyword">new</span> String[] { <span class="string">"title"</span> },<span class="keyword">new</span> <span class="keyword">int</span>[] {android.R.id.text1}));
        getListView().setTextFilterEnabled(<span class="keyword">true</span>);

        filter.addCategory(CATEGORY_MAN);
        <span class="comment">//注册一个广播</span>
        super.registerReceiver(<span class="keyword">new</span> BroadcastReceiver() {

            @<span class="function">Override
            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>{
                Toast.makeText(context, <span class="string">"该Broadcast的Intent Filter设置了Category和Action"</span>, Toast.LENGTH_SHORT).show();
            }
        },filter);
    }
    @<span class="function">Override
    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onListItemClick</span><span class="params">(ListView l, View v, <span class="keyword">int</span> position, <span class="keyword">long</span> id)</span> </span>{
        Intent intent=(Intent)getData().<span class="keyword">get</span>(position).<span class="keyword">get</span>(<span class="string">"intent"</span>);
        Boolean isActivity=(Boolean)getData().<span class="keyword">get</span>(position).<span class="keyword">get</span>(<span class="string">"isActivity"</span>);
        <span class="keyword">if</span>(isActivity){
            startActivity(intent);
        }<span class="keyword">else</span>{
            sendBroadcast(intent);
        }

    }

    <span class="comment">/**
     * 返回ListView需要的数据
     * @return ListView需要的数据
     */</span>
    <span class="keyword">private</span> List&lt;map&lt;<span class="keyword">string</span>,<span class="keyword">object</span>&gt;&gt; getData() {
        List&lt;map&lt;<span class="keyword">string</span>,<span class="keyword">object</span>&gt;&gt; data=<span class="keyword">new</span> ArrayList&lt;map&lt;<span class="keyword">string</span>,<span class="keyword">object</span>&gt;&gt;();
        addItem(data, <span class="string">"1个Category检测-Activity"</span>, <span class="keyword">new</span> Intent(ACTION_VIEW).addCategory(CATEGORY_MAN),<span class="keyword">true</span>);
        addItem(data, <span class="string">"1个Category检测-Broadcast"</span>, <span class="keyword">new</span> Intent(ACTION_VIEW).addCategory(CATEGORY_MAN),<span class="keyword">false</span>);
        addItem(data, <span class="string">"2个Category检测-Activity"</span>, <span class="keyword">new</span> Intent(ACTION_VIEW).addCategory(CATEGORY_MAN).addCategory(CATEGORY_SHOP),<span class="keyword">true</span>);
        <span class="keyword">return</span> data;
    }
    <span class="comment">/**
     * 给ListView添加数据
     * @param data 存储数据的List
     * @param name 要显示的Title
     * @param intent 单击某一项时要启动的Activity
     * @param isActivity 启动的是否是Activity，true是，false为广播
     */</span>
    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addItem</span><span class="params">(List&lt;map&lt;<span class="keyword">string</span>,<span class="keyword">object</span>&gt;&gt; data, String name, Intent intent,boolean isActivity)</span> </span>{
        Map&lt;<span class="keyword">string</span>, <span class="keyword">object</span>=<span class="string">""</span>&gt; temp = <span class="keyword">new</span> HashMap&lt;<span class="keyword">string</span>, <span class="keyword">object</span>=<span class="string">""</span>&gt;();
        temp.put(<span class="string">"title"</span>, name);
        temp.put(<span class="string">"intent"</span>, intent);
        temp.put(<span class="string">"isActivity"</span>, isActivity);
        data.add(temp);
    }
    <span class="keyword">private</span> IntentFilter filter=<span class="keyword">new</span> IntentFilter(ACTION_VIEW);

}
</code></pre><p>以上代码主要是一个ListView，列出了三个测试项，1个Category的测试和2个Category的测试，注册了一个广播.<br>为了测试新建了2个Activity，分别是CategoryActivity和Category2Activity,代码如下：</p>
<pre><code><span class="comment">/**
 * @author 飞雪无情
 * @since 2011-3-14
 */</span>
public <span class="class"><span class="keyword">class</span> <span class="title">CategoryActivity</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Activity</span> {</span>

    <span class="annotation">@Override</span>
    <span class="keyword">protected</span> void onCreate(<span class="type">Bundle</span> savedInstanceState) {
        <span class="keyword">super</span>.onCreate(savedInstanceState);
        <span class="type">TextView</span> text=<span class="keyword">new</span> <span class="type">TextView</span>(<span class="keyword">this</span>);
        text.setText(<span class="string">"该Activity的Intent Filter值设置了Action和1个Category，不包含android.intent.category.DEFAULT"</span>);
        setContentView(text);
    }

}




<span class="comment">/**
 * @author 飞雪无情
 * @since 2011-3-14
 */</span>
public <span class="class"><span class="keyword">class</span> <span class="title">Category2Activity</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Activity</span> {</span>

    <span class="annotation">@Override</span>
    <span class="keyword">protected</span> void onCreate(<span class="type">Bundle</span> savedInstanceState) {
        <span class="keyword">super</span>.onCreate(savedInstanceState);
        <span class="type">TextView</span> text=<span class="keyword">new</span> <span class="type">TextView</span>(<span class="keyword">this</span>);
        text.setText(<span class="string">"该Activity的Intent Filter值设置了Action和2个Category，不包含android.intent.category.DEFAULT"</span>);
        setContentView(text);
    }

}
</code></pre><p>很简单只是一段文字的说明</p>
<p>AndroidManiftest.xml修改如下：</p>
<pre><code><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span>
<span class="tag">&lt;<span class="title">manifest</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span>
      <span class="attribute">package</span>=<span class="value">"com.flysnow.intent"</span>
      <span class="attribute">android:versionCode</span>=<span class="value">"1"</span>
      <span class="attribute">android:versionName</span>=<span class="value">"1.0"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">uses-sdk</span> <span class="attribute">android:minSdkVersion</span>=<span class="value">"8"</span> /&gt;</span>

    <span class="tag">&lt;<span class="title">application</span> <span class="attribute">android:icon</span>=<span class="value">"@drawable/icon"</span> <span class="attribute">android:label</span>=<span class="value">"@string/app_name"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">activity</span> <span class="attribute">android:name</span>=<span class="value">".IntentsTestList"</span>
                  <span class="attribute">android:label</span>=<span class="value">"@string/app_name"</span>&gt;</span>
            <span class="tag">&lt;<span class="title">intent-filter</span>&gt;</span>
                <span class="tag">&lt;<span class="title">action</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.action.MAIN"</span> /&gt;</span>
                <span class="tag">&lt;<span class="title">category</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.category.LAUNCHER"</span> /&gt;</span>
            <span class="tag">&lt;/<span class="title">intent-filter</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">activity</span>&gt;</span>
        <span class="tag">&lt;<span class="title">activity</span> <span class="attribute">android:name</span>=<span class="value">".CategoryActivity"</span> <span class="attribute">android:label</span>=<span class="value">"1个Category检测"</span>&gt;</span>
            <span class="tag">&lt;<span class="title">intent-filter</span>&gt;</span>
                <span class="tag">&lt;<span class="title">action</span> <span class="attribute">android:name</span>=<span class="value">"com.flysnow.intent.ACTION_VIEW"</span>&gt;</span><span class="tag">&lt;/<span class="title">action</span>&gt;</span>
                <span class="tag">&lt;<span class="title">category</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.category.DEFAULT"</span>&gt;</span><span class="tag">&lt;/<span class="title">category</span>&gt;</span>
                <span class="tag">&lt;<span class="title">category</span> <span class="attribute">android:name</span>=<span class="value">"com.flysnow.intent.CATEGORY_MAN"</span>&gt;</span><span class="tag">&lt;/<span class="title">category</span>&gt;</span>
            <span class="tag">&lt;/<span class="title">intent-filter</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">activity</span>&gt;</span>
         <span class="tag">&lt;<span class="title">activity</span> <span class="attribute">android:name</span>=<span class="value">".Category2Activity"</span> <span class="attribute">android:label</span>=<span class="value">"2个Category检测"</span>&gt;</span>
            <span class="tag">&lt;<span class="title">intent-filter</span>&gt;</span>
                <span class="tag">&lt;<span class="title">action</span> <span class="attribute">android:name</span>=<span class="value">"com.flysnow.intent.ACTION_VIEW"</span>&gt;</span><span class="tag">&lt;/<span class="title">action</span>&gt;</span>
                <span class="tag">&lt;<span class="title">category</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.category.DEFAULT"</span>&gt;</span><span class="tag">&lt;/<span class="title">category</span>&gt;</span>
                <span class="tag">&lt;<span class="title">category</span> <span class="attribute">android:name</span>=<span class="value">"com.flysnow.intent.CATEGORY_MAN"</span>&gt;</span><span class="tag">&lt;/<span class="title">category</span>&gt;</span>
                <span class="tag">&lt;<span class="title">category</span> <span class="attribute">android:name</span>=<span class="value">"com.flysnow.intent.CATEGORY_SHOP"</span>&gt;</span><span class="tag">&lt;/<span class="title">category</span>&gt;</span>
            <span class="tag">&lt;/<span class="title">intent-filter</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">activity</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">application</span>&gt;</span>
<span class="tag">&lt;/<span class="title">manifest</span>&gt;</span>
</code></pre><p>为CategoryActivity添加了2个Category，一个是默认的（隐式Intent必须），一个是自定义的。而相应的Category2Activity则有三个Category。</p>
<p>我们运行测试，效果图如下：<img src="http://dl.iteye.com/upload/attachment/439568/21480d9b-d2fb-35cd-a240-5b045eacc7bd.png" alt=""><br>当点击“1个Category检测-Activity”的时候，会弹出</p>
<p><img src="http://dl.iteye.com/upload/attachment/439572/ccf8c038-7289-3d78-aa21-fecdbe95497c.png" alt=""><br>这是，因为我们的Intent定义了一个Category，这个Category在CategoryActivity和Category2Activity里都有，都能匹配上，所以就会弹出这两个Activity供我们选择，而当我们单击《2个Category检测-Activity》的时候就会直接打开Category2Activity，这是因为这个选项里的Intent有2个Category，只有Category2Activity才能匹配上。。。通过例子我们可以总结到：Intent中所包含的所有Category必须在一个组件的intent-filter中有定义，一个都不能少，否则不能通过检测。。但是intent-filter的可以有额外的Category<br>.再次提醒：</p>
<p>Android对所有传递给</p>
<p>Context.startActivity()的隐式intent至少包含”android.intent.category.DEFAULT”</p>
<p>未完待续</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Category（类别）检测">Category（类别）检测</h2><p>类别在中是通过标记定义的,Category和Action一样，他们的名字都是一个字符串定义，但是我们在代码中可以使用对应的类别常量，在xml文件定义中只能使用定义好的字符串。Android]]>
    </summary>
    
      <category term="Android" scheme="http://www.flysnow.org/tags/Android/"/>
    
      <category term="Intent" scheme="http://www.flysnow.org/tags/Intent/"/>
    
      <category term="Android" scheme="http://www.flysnow.org/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android Intents and Intent Filters(一)]]></title>
    <link href="http://www.flysnow.org/2011/03/14/android-intents-and-intent-filters-one.html"/>
    <id>http://www.flysnow.org/2011/03/14/android-intents-and-intent-filters-one.html</id>
    <published>2011-03-14T02:01:05.000Z</published>
    <updated>2016-05-22T10:14:57.302Z</updated>
    <content type="html"><![CDATA[<p>看过前面的几节教程的应该都会留意到一个很重要的东西，那就是Intent。Intent是什么呢？我们都知道Android有四大核心组件 Activity、Service、Broadcast Receiver和Content Provider，略去Content Provider不提，那么剩下的三个组件之间的通信考什么？这就是Intent！！它不仅可以在同一个应用中起传递信息的作用，还是可以在不同的应用进行传递信息。这就使得我们的应用和系统中的其他应用进行交互有了可能，进而使得整个Android开发变得更加精彩。想想吧，我们自己的应用可以调用系统中的通话应用进行拨号、可以调用短信应用发短信，这是多么美妙的一件事情啊！！！</p>
<h2 id="在这里你将会学到：">在这里你将会学到：</h2><ol>
<li>什么是Intent和Intent Filter</li>
</ol>
<ol>
<li>Intent和Intent Filter有什么用</li>
</ol>
<ol>
<li>怎么启动（传递）一个Intent</li>
</ol>
<ol>
<li>Intent里包含什么</li>
</ol>
<ol>
<li>什么是显式Intent以及什么隐式Intent</li>
</ol>
<ol>
<li>Intent是怎样匹配的</li>
</ol>
<h2 id="一：前言">一：前言</h2><p>在正式介绍Intent之前，我们先看下上面说的Activity、Service和Broadcast Receiver是怎样传递Intent。对于这三个组件而言，他们都有自己独立的传递Intent的机制：</p>
<ol>
<li>Activity:对于Activity来说，它主要是通过Context.startActivity()或Activity.startActivityForRestult()来启动一个存在的Activity做一些事情。当使用Activity.startActivityForResult()启动一个Activity时，可以使用Activity.setResult()返回一些结果信息，可以在Activity.onActivityResult()<br>中得到返回的结果.</li>
</ol>
<ol>
<li>Service:对于Service来说，它主要是通过Context.startService()初始化一个Service或者传递消息给正在运行的Service。同样，也可以通过Context.bindService()建立一个调用组件和目标服务之间的连接。</li>
</ol>
<ol>
<li>Broadcast Receiver:我们可以通过Context.sendBroadcast()Context.sendOrderedBroadcast()以及Context.sendStickyBroadcast()这些方法，传递Intent给感兴趣的广播。</li>
</ol>
<p>消息之间的传递是没有重叠的，比如调用startActivity()传播一个Intent，只会传播给Activity，而不会传播给Service和Broadcast Receiver，反过来也是这样的。</p>
<h2 id="二：Intent对象">二：Intent对象</h2><p>一个Intent对象包含了很多数据的信息，比如要执行的动作，类别，数据，附加信息等等，下面就一一列列出一个Intent中包含的信息。</p>
<h3 id="组件名称">组件名称</h3><p>这个组件名称字段其实就是一个ComponentName类，它包含了一个目标组件的全限定名，比如com.flysnow.intent.Activity1，这就是一个全限定名的Activity。组件名字可以通过setComponent()、setClass()或者setClassName()设置，如果设置了Intent目标组件的名字，那么这个Intent就会被传递给特定的组件，也就是我们说的显式Intent.如果不设置，则是隐式的Intent，Android系统将根据Intent Filter中的信息进行匹配.</p>
<h3 id="Action(动作)">Action(动作)</h3><p>一个Intent的Action在很大程度上说明这个Intent要做什么，是查看(View)、删除(Delete)、编辑(Edit)等等。Action一个字符串命名的动作，Android中预定义了很多Action，可以参考Intent类查看,下面是文档中的几个动作</p>
<p><img src="http://dl.iteye.com/upload/attachment/435153/de61628d-7112-32f4-a6b2-902e1eb72ea1.png" alt=""><br>当然，我们也可以自定义Action，比如com.flysnow.intent.ACTION_ADD,定义Action的时候最好能表明意思，要做什么，这样我们的Intent中的数据才好填充。Intent对象的getAction()可以获取动作，使用setAction()可以设置动作。</p>
<h3 id="Data（数据）">Data（数据）</h3><p>Data，其实就是一个URI，用于执行一个Action时所用到的数据的URI和MIME。不同的Action有不同的数据规格，比如ACTION_EDIT动作，数据就可以能包含一个用于编辑文档的URI,如果是一个ACTION_CALL动作，那么数据就是一个包含了tel:6546541的数据字段，所以上面提到的自定义Action时要规范命名。数据的URI和类型对于Intent的匹配是很重要的，Android往往根据数据的URI和MIME找到能处理该Intent的最佳目标组件。</p>
<h3 id="Category(类别)">Category(类别)</h3><p>Category指定了用于处理Intent的组件的类型信息，一个Intent可以添加多个Category，使用addCategory()方法即可，使用removeCategory()删除一个已经添加的类别。Android的Intent类里定义了很多常用的类别，可以参考使用。</p>
<h3 id="Extras(附加信息)">Extras(附加信息)</h3><p>有些用于处理Intent的目标组件需要一些额外的信息，那么就可以通过Intent的put..()方法把额外的信息塞入到Intent对象中，用于目标组件的使用，一个附件信息就是一个key-value的键值对..Intent有一系列的put和get方法用于处理附加信息的塞入和取出。</p>
<h3 id="Flag(标识)">Flag(标识)</h3><p>Android有很多标识，用于标记如何启动一个活动，是NEW_TASK还是其他等等，以及启动后怎么对待这个活动。。可以参考Intent类中的FLAG常量字段。</p>
<h2 id="三：Intent的解析">三：Intent的解析</h2><p>介绍完了Intent对象的构成，就要介绍Android系统是怎样解析Intent的，Android是怎么传递Intent到目标组件的呢？</p>
<h3 id="Intent分类">Intent分类</h3><p>Intent可以分为两类，一类是显式的Intent，一类是隐式的Intent，上面有过提及。显示的Intent就是指定了组件名字的，隐式的就是没有指定Intent的组件名字，需要Android根据Intent中的Action、data、Category等来解析匹配。而目标组件（Activity、Service、Broadcast Receiver）怎通过设置他们的Intent Filter来界定其处理的Intent。如果一个组件没有定义Intent Filter，那么它只能接受处理显示的Intent，只有定义了Intent Filter的组件才能同时处理隐式和显示的Intent。</p>
<h3 id="Action检测">Action检测</h3><p>为了对Action的作用进行检测，我们使用一个例子来演示Action的作用。项目名为Intents,应用名为Intents and Filters，运行在Android2.2版本上.主启动Activity为IntentsTestList</p>
<p>IntentsTestList代码如下：</p>
<pre><code><span class="comment">/**
 * Intents测试列表类
 * @author 飞雪无情
 * @since 2011-3-14
 */</span>
<span class="keyword">public</span> <span class="keyword">class</span> <span class="title">IntentsTestList</span> <span class="title">extends</span> <span class="title">ListActivity</span> {
    <span class="keyword">private</span> String ACTION_VIEW=<span class="string">"com.flysnow.intent.ACTION_VIEW"</span>;
    <span class="comment">/** Called when the activity is first created. */</span>
    @<span class="function">Override
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>{
        super.onCreate(savedInstanceState);
      <span class="comment">//定义ListAdapter</span>
        setListAdapter(<span class="keyword">new</span> SimpleAdapter(<span class="keyword">this</span>, getData(),
                android.R.layout.simple_list_item_1, <span class="keyword">new</span> String[] { <span class="string">"title"</span> },<span class="keyword">new</span> <span class="keyword">int</span>[] {android.R.id.text1}));
        getListView().setTextFilterEnabled(<span class="keyword">true</span>);

        <span class="comment">//注册一个广播</span>
        super.registerReceiver(<span class="keyword">new</span> BroadcastReceiver() {

            @<span class="function">Override
            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>{
                Toast.makeText(context, <span class="string">"该Broadcast的Intent Filter值只设置了Action"</span>, Toast.LENGTH_SHORT).show();
            }
        },<span class="keyword">new</span> IntentFilter(ACTION_VIEW));
    }
    @<span class="function">Override
    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onListItemClick</span><span class="params">(ListView l, View v, <span class="keyword">int</span> position, <span class="keyword">long</span> id)</span> </span>{
        Intent intent=(Intent)getData().<span class="keyword">get</span>(position).<span class="keyword">get</span>(<span class="string">"intent"</span>);
        Boolean isActivity=(Boolean)getData().<span class="keyword">get</span>(position).<span class="keyword">get</span>(<span class="string">"isActivity"</span>);
        <span class="keyword">if</span>(isActivity){
            startActivity(intent);
        }<span class="keyword">else</span>{
            sendBroadcast(intent);
        }

    }

    <span class="comment">/**
     * 返回ListView需要的数据
     * @return ListView需要的数据
     */</span>
    <span class="keyword">private</span> List&lt;map&lt;<span class="keyword">string</span>,<span class="keyword">object</span>&gt;&gt; getData() {
        List&lt;map&lt;<span class="keyword">string</span>,<span class="keyword">object</span>&gt;&gt; data=<span class="keyword">new</span> ArrayList&lt;map&lt;<span class="keyword">string</span>,<span class="keyword">object</span>&gt;&gt;();
        addItem(data, <span class="string">"空Action的Activity"</span>, <span class="keyword">new</span> Intent(),<span class="keyword">true</span>);
        addItem(data, <span class="string">"Action检测-Activity"</span>, <span class="keyword">new</span> Intent(ACTION_VIEW),<span class="keyword">true</span>);
        addItem(data, <span class="string">"Action检测-Broadcast"</span>, <span class="keyword">new</span> Intent(ACTION_VIEW),<span class="keyword">false</span>);
        <span class="keyword">return</span> data;
    }
    <span class="comment">/**
     * 给ListView添加数据
     * @param data 存储数据的List
     * @param name 要显示的Title
     * @param intent 单击某一项时要启动的Activity
     * @param isActivity 启动的是否是Activity，true是，false为广播
     */</span>
    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addItem</span><span class="params">(List&lt;map&lt;<span class="keyword">string</span>,<span class="keyword">object</span>&gt;&gt; data, String name, Intent intent,boolean isActivity)</span> </span>{
        Map&lt;<span class="keyword">string</span>, <span class="keyword">object</span>=<span class="string">""</span>&gt; temp = <span class="keyword">new</span> HashMap&lt;<span class="keyword">string</span>, <span class="keyword">object</span>=<span class="string">""</span>&gt;();
        temp.put(<span class="string">"title"</span>, name);
        temp.put(<span class="string">"intent"</span>, intent);
        temp.put(<span class="string">"isActivity"</span>, isActivity);
        data.add(temp);
    }
}
</code></pre><p>这里主要是使用ListActivity列出3个测试，一个测试空的Intent,一个测试只有Action的Intent—Activity版，一个测试只有Action的Intent—Broadcast版。。。</p>
<p>为了测试startActivity()，我们新建一个Activity名字为ActionActivity代码如下：</p>
<pre><code><span class="comment">/**
 * @author 飞雪无情
 * @since 2011-3-14
 */</span>
public <span class="class"><span class="keyword">class</span> <span class="title">ActionActivity</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Activity</span> {</span>

    <span class="annotation">@Override</span>
    <span class="keyword">protected</span> void onCreate(<span class="type">Bundle</span> savedInstanceState) {
        <span class="keyword">super</span>.onCreate(savedInstanceState);
        <span class="type">TextView</span> text=<span class="keyword">new</span> <span class="type">TextView</span>(<span class="keyword">this</span>);
        text.setText(<span class="string">"该Activity的Intent Filter值只设置了Action"</span>);
        setContentView(text);
    }

}
</code></pre><p>很简单，只有一段文本的展示。</p>
<p>AndroidManifest.xml修改如下:</p>
<pre><code><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span>
<span class="tag">&lt;<span class="title">manifest</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span>
      <span class="attribute">package</span>=<span class="value">"com.flysnow.intent"</span>
      <span class="attribute">android:versionCode</span>=<span class="value">"1"</span>
      <span class="attribute">android:versionName</span>=<span class="value">"1.0"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">uses-sdk</span> <span class="attribute">android:minSdkVersion</span>=<span class="value">"8"</span> /&gt;</span>

    <span class="tag">&lt;<span class="title">application</span> <span class="attribute">android:icon</span>=<span class="value">"@drawable/icon"</span> <span class="attribute">android:label</span>=<span class="value">"@string/app_name"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">activity</span> <span class="attribute">android:name</span>=<span class="value">".IntentsTestList"</span>
                  <span class="attribute">android:label</span>=<span class="value">"@string/app_name"</span>&gt;</span>
            <span class="tag">&lt;<span class="title">intent-filter</span>&gt;</span>
                <span class="tag">&lt;<span class="title">action</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.action.MAIN"</span> /&gt;</span>
                <span class="tag">&lt;<span class="title">category</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.category.LAUNCHER"</span> /&gt;</span>
            <span class="tag">&lt;/<span class="title">intent-filter</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">activity</span>&gt;</span>
        <span class="tag">&lt;<span class="title">activity</span> <span class="attribute">android:name</span>=<span class="value">".ActionActivity"</span> <span class="attribute">android:label</span>=<span class="value">"Action检测"</span>&gt;</span>
            <span class="tag">&lt;<span class="title">intent-filter</span>&gt;</span>
                <span class="tag">&lt;<span class="title">action</span> <span class="attribute">android:name</span>=<span class="value">"com.flysnow.intent.ACTION_VIEW"</span>&gt;</span><span class="tag">&lt;/<span class="title">action</span>&gt;</span>
                <span class="tag">&lt;<span class="title">action</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.action.VIEW"</span>&gt;</span><span class="tag">&lt;/<span class="title">action</span>&gt;</span>
                <span class="tag">&lt;<span class="title">category</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.category.DEFAULT"</span>&gt;</span><span class="tag">&lt;/<span class="title">category</span>&gt;</span>
            <span class="tag">&lt;/<span class="title">intent-filter</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">activity</span>&gt;</span>

    <span class="tag">&lt;/<span class="title">application</span>&gt;</span>
<span class="tag">&lt;/<span class="title">manifest</span>&gt;</span>
</code></pre><p>很简单，为我们的ActionContext加上了两个action标签和一个category标签,加category标签设置成android.intent.category.DEFAULT是为了让这个Activity可以接收隐式的Intent请求，这是Android规定的，对于Activity，使用Context.startActivity()传递隐式Intent，默认是包含了android.intent.category.DEFAULT的，所以定义的Activity要想接收，必须在Intent Filter里添加android.intent.category.DEFAULT这个Category。</p>
<p>运行入下图：<br><img src="http://dl.iteye.com/upload/attachment/435312/5a7c0913-7b0f-3035-8b65-abe0a68dd21f.png" alt=""><br>当点击“空Action的Activity”的时候，会报异常，因为Intent什么都没有设置，没有任何的Activity能处理它<br>。当点击“Action检测-Activity”的时候会打开我们的ActionActivity这个Activity，点击“Action检测-Broadcast”会弹出Toast提示，说明已经被接收到。。从上面我们可以看出，当Intent设置了Action时，只要对应的组件的Intent Filter中包含该Action的定义，那么这个组件就会接收该Intent。。。</p>
<p>因为内容较多，，所以进行了分节。。。这样也会使得看本章带的Demo的时候不至于迷糊，因为这个Demo就只是实现了这一个功能。如果多个功能测试的话，就会在Demo改来改去，导致Demo代码不清晰了。未完待续，敬请期待！！！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>看过前面的几节教程的应该都会留意到一个很重要的东西，那就是Intent。Intent是什么呢？我们都知道Android有四大核心组件 Activity、Service、Broadcast Receiver和Content Provider，略去Content Provide]]>
    </summary>
    
      <category term="Android" scheme="http://www.flysnow.org/tags/Android/"/>
    
      <category term="Intent" scheme="http://www.flysnow.org/tags/Intent/"/>
    
      <category term="Android" scheme="http://www.flysnow.org/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[新浪微博布局学习--新浪微博Android版底部工具栏的Demo]]></title>
    <link href="http://www.flysnow.org/2011/03/08/android-bottom-tool-bar-demo.html"/>
    <id>http://www.flysnow.org/2011/03/08/android-bottom-tool-bar-demo.html</id>
    <published>2011-03-08T00:31:54.000Z</published>
    <updated>2016-05-22T10:14:57.302Z</updated>
    <content type="html"><![CDATA[<p>前几天看到一篇很好的文章《新浪微博布局学习——妙用TabHost》，已经转载到我的博客里<a href="/2011/03/02/sina-weibo-tool-bar-tabhost.html">新浪微博布局学习——妙用TabHost </a><br>里面详细的介绍了怎么妙用TabHost构建底部的工具栏，有兴趣的可以看一下。因为那边文章没有Demo，工作之余，我写了一个Demo，供朋友们参考，欢迎拍砖讨论。。附件中提供下载。</p>
<p><img src="http://dl.iteye.com/upload/attachment/431685/f7fbcca0-7830-37a9-8caa-cfa908809cd4.png" alt=""><br>本文附件下载:</p>
<p><a href="/uploads/2013/10/sina-weibo-tool-bar-demo.zip">sina-weibo-tool-bar-demo</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>前几天看到一篇很好的文章《新浪微博布局学习——妙用TabHost》，已经转载到我的博客里<a href="/2011/03/02/sina-weibo-tool-bar-tabhost.html">新浪微博布局学习——妙用TabHost </a><br>里面详细的介绍了怎么]]>
    </summary>
    
      <category term="Android" scheme="http://www.flysnow.org/tags/Android/"/>
    
      <category term="Android" scheme="http://www.flysnow.org/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[新浪微博布局学习——妙用TabHost]]></title>
    <link href="http://www.flysnow.org/2011/03/02/sina-weibo-tool-bar-tabhost.html"/>
    <id>http://www.flysnow.org/2011/03/02/sina-weibo-tool-bar-tabhost.html</id>
    <published>2011-03-01T23:44:21.000Z</published>
    <updated>2016-05-22T10:14:57.302Z</updated>
    <content type="html"><![CDATA[<p>前言</p>
<p>为了更好的开发Android应用程序，除了熟练掌握基本的UI组件和API外，还需要掌握一些技巧，而这些技巧可以通过阅读一些代码来提高，本系列将与大家分享一些新浪微博布局方面的收获，欢迎交流！</p>
<p>声明</p>
<p>欢迎转载，但请保留文章原始出处:)</p>
<p>博客园：<a href="http://www.cnblogs.com" target="_blank" rel="external">http://www.cnblogs.com</a></p>
<p>农民伯伯： <a href="http://www.cnblogs.com/over140" target="_blank" rel="external">http://www.cnblogs.com/over140</a></p>
<p>版本</p>
<p>新浪微博 weibo_10235010.apk</p>
<p>正文</p>
<p>一、效果图</p>
<p><img src="http://images.cnblogs.com/cnblogs_com/over140/2011/3/2011-3-1_1.png" alt=""></p>
<p>红色部分是本文要实现的目标。</p>
<p>二、实现maintabs.xml</p>
<pre><code>&lt;?xml <span class="variable">version=</span><span class="string">"1.0"</span> <span class="variable">encoding=</span><span class="string">"UTF-8"</span>?&gt;
&lt;TabHost android:<span class="variable">id=</span><span class="string">"@android:id/tabhost"</span> android:<span class="variable">layout_width=</span><span class="string">"fill_parent"</span> android:<span class="variable">layout_height=</span><span class="string">"fill_parent"</span>
  xmlns:<span class="variable">android=</span><span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;
    &lt;LinearLayout android:<span class="variable">orientation=</span><span class="string">"vertical"</span> android:<span class="variable">layout_width=</span><span class="string">"fill_parent"</span> android:<span class="variable">layout_height=</span><span class="string">"fill_parent"</span>&gt;
        &lt;FrameLayout android:<span class="variable">id=</span><span class="string">"@android:id/tabcontent"</span> android:<span class="variable">layout_width=</span><span class="string">"fill_parent"</span> android:<span class="variable">layout_height=</span><span class="string">"0.0dip"</span> android:<span class="variable">layout_weight=</span><span class="string">"1.0"</span> /&gt;
        &lt;TabWidget android:<span class="variable">id=</span><span class="string">"@android:id/tabs"</span> android:<span class="variable">visibility=</span><span class="string">"gone"</span> android:<span class="variable">layout_width=</span><span class="string">"fill_parent"</span> android:<span class="variable">layout_height=</span><span class="string">"wrap_content"</span> android:<span class="variable">layout_weight=</span><span class="string">"0.0"</span> /&gt;
        &lt;RadioGroup android:<span class="variable">gravity=</span><span class="string">"center_vertical"</span> android:<span class="variable">layout_gravity=</span><span class="string">"bottom"</span> android:<span class="variable">orientation=</span><span class="string">"horizontal"</span> android:<span class="variable">id=</span><span class="string">"@id/main_radio"</span> android:<span class="variable">background=</span><span class="string">"@drawable/maintab_toolbar_bg"</span> android:<span class="variable">layout_width=</span><span class="string">"fill_parent"</span> android:<span class="variable">layout_height=</span><span class="string">"wrap_content"</span>&gt;
            &lt;RadioButton   android:<span class="variable">text=</span><span class="string">"@string/main_home"</span> android:<span class="variable">checked=</span><span class="string">"true"</span> android:<span class="variable">id=</span><span class="string">"@+id/radio_button0"</span> android:<span class="variable">layout_marginTop=</span><span class="string">"2.0dip"</span> android:<span class="variable">drawableTop=</span><span class="string">"@drawable/icon_1_n"</span> <span class="variable">style=</span><span class="string">"@style/main_tab_bottom"</span> /&gt;
            &lt;RadioButton android:<span class="variable">id=</span><span class="string">"@+id/radio_button1"</span> android:<span class="variable">layout_marginTop=</span><span class="string">"2.0dip"</span> android:<span class="variable">text=</span><span class="string">"@string/main_news"</span> android:<span class="variable">drawableTop=</span><span class="string">"@drawable/icon_2_n"</span> <span class="variable">style=</span><span class="string">"@style/main_tab_bottom"</span> /&gt;
            &lt;RadioButton android:<span class="variable">id=</span><span class="string">"@+id/radio_button2"</span> android:<span class="variable">layout_marginTop=</span><span class="string">"2.0dip"</span> android:<span class="variable">text=</span><span class="string">"@string/main_my_info"</span> android:<span class="variable">drawableTop=</span><span class="string">"@drawable/icon_3_n"</span> <span class="variable">style=</span><span class="string">"@style/main_tab_bottom"</span> /&gt;
            &lt;RadioButton android:<span class="variable">id=</span><span class="string">"@+id/radio_button3"</span> android:<span class="variable">layout_marginTop=</span><span class="string">"2.0dip"</span> android:<span class="variable">text=</span><span class="string">"@string/menu_search"</span> android:<span class="variable">drawableTop=</span><span class="string">"@drawable/icon_4_n"</span> <span class="variable">style=</span><span class="string">"@style/main_tab_bottom"</span> /&gt;
            &lt;RadioButton android:<span class="variable">id=</span><span class="string">"@+id/radio_button4"</span> android:<span class="variable">layout_marginTop=</span><span class="string">"2.0dip"</span> android:<span class="variable">text=</span><span class="string">"@string/more"</span> android:<span class="variable">drawableTop=</span><span class="string">"@drawable/icon_5_n"</span> <span class="variable">style=</span><span class="string">"@style/main_tab_bottom"</span> /&gt;
        &lt;/RadioGroup&gt;
    &lt;/LinearLayout&gt;
&lt;/TabHost&gt;
</code></pre><p>styles.xml</p>
<pre><code>&lt;style <span class="property">name</span>=<span class="string">"main_tab_bottom"</span>&gt;
       &lt;<span class="property">item</span> <span class="property">name</span>=<span class="string">"android:textSize"</span>&gt;@dimen/bottom_tab_font_size&lt;/<span class="property">item</span>&gt;
       &lt;<span class="property">item</span> <span class="property">name</span>=<span class="string">"android:textColor"</span>&gt;<span class="comment">#ffffffff&lt;/item&gt;</span>
       &lt;<span class="property">item</span> <span class="property">name</span>=<span class="string">"android:ellipsize"</span>&gt;marquee&lt;/<span class="property">item</span>&gt;
       &lt;<span class="property">item</span> <span class="property">name</span>=<span class="string">"android:gravity"</span>&gt;center_horizontal&lt;/<span class="property">item</span>&gt;
       &lt;<span class="property">item</span> <span class="property">name</span>=<span class="string">"android:background"</span>&gt;@drawable/home_btn_bg&lt;/<span class="property">item</span>&gt;
       &lt;<span class="property">item</span> <span class="property">name</span>=<span class="string">"android:paddingTop"</span>&gt;@dimen/bottom_tab_padding_up&lt;/<span class="property">item</span>&gt;
       &lt;<span class="property">item</span> <span class="property">name</span>=<span class="string">"android:layout_width"</span>&gt;fill_parent&lt;/<span class="property">item</span>&gt;
       &lt;<span class="property">item</span> <span class="property">name</span>=<span class="string">"android:layout_height"</span>&gt;wrap_content&lt;/<span class="property">item</span>&gt;
       &lt;<span class="property">item</span> <span class="property">name</span>=<span class="string">"android:button"</span>&gt;@null&lt;/<span class="property">item</span>&gt;
       &lt;<span class="property">item</span> <span class="property">name</span>=<span class="string">"android:singleLine"</span>&gt;<span class="constant">true</span>&lt;/<span class="property">item</span>&gt;
       &lt;<span class="property">item</span> <span class="property">name</span>=<span class="string">"android:drawablePadding"</span>&gt;@dimen/bottom_tab_padding_drawable&lt;/<span class="property">item</span>&gt;
       &lt;<span class="property">item</span> <span class="property">name</span>=<span class="string">"android:layout_weight"</span>&gt;<span class="number">1.0</span>&lt;/<span class="property">item</span>&gt;
   &lt;/style&gt;
</code></pre><p>home_btn_bg.xml</p>
<pre><code>&lt;selector
         xmlns:<span class="variable">android=</span><span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;
           &lt;item android:<span class="variable">state_focused=</span><span class="string">"true"</span> android:<span class="variable">state_enabled=</span><span class="string">"true"</span> android:<span class="variable">state_pressed=</span><span class="string">"false"</span> android:<span class="variable">drawable=</span><span class="string">"@drawable/home_btn_bg_s"</span> /&gt;
           &lt;item android:<span class="variable">state_enabled=</span><span class="string">"true"</span> android:<span class="variable">state_pressed=</span><span class="string">"true"</span> android:<span class="variable">drawable=</span><span class="string">"@drawable/home_btn_bg_s"</span> /&gt;
           &lt;item android:<span class="variable">state_enabled=</span><span class="string">"true"</span> android:<span class="variable">state_checked=</span><span class="string">"true"</span> android:<span class="variable">drawable=</span><span class="string">"@drawable/home_btn_bg_d"</span> /&gt;
           &lt;item android:<span class="variable">drawable=</span><span class="string">"@drawable/transparent"</span> /&gt;
       &lt;/selector&gt;
</code></pre><p>代码说明：</p>
<ol>
<li>需要注意的是他这里把TabWidget的Visibility设置成了gone!也就是默认难看的风格不见了：<img src="http://images.cnblogs.com/cnblogs_com/over140/2011/3/2011-3-1_2.jpg" alt=""> ，取而代之的是5个带风格的单选按钮.</li>
</ol>
<ol>
<li>注意为单选按钮设置的style，其中最重要的是为其background设置了home_btn_bg.xml，也就是自定义了选中效果。</li>
</ol>
<p>Java文件</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainTabActivity</span> <span class="keyword">extends</span> <span class="title">TabActivity</span> <span class="keyword">implements</span>
        <span class="title">OnCheckedChangeListener</span> {</span>

    <span class="keyword">private</span> TabHost mHost;
    <span class="keyword">private</span> Intent mMBlogIntent;
    <span class="keyword">private</span> Intent mMoreIntent;
    <span class="keyword">private</span> Intent mInfoIntent;
    <span class="keyword">private</span> Intent mSearchIntent;
    <span class="keyword">private</span> Intent mUserInfoIntent;

    <span class="annotation">@Override</span>
    <span class="keyword">protected</span> <span class="typename">void</span> onCreate(Bundle savedInstanceState) {
        <span class="keyword">super</span>.onCreate(savedInstanceState);
        requestWindowFeature(Window.FEATURE_NO_TITLE);
        setContentView(R.layout.maintabs);

        <span class="comment">// ~~~~~~~~~~~~ 初始化</span>
        <span class="keyword">this</span>.mMBlogIntent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, HomeListActivity.<span class="keyword">class</span>);
        <span class="keyword">this</span>.mSearchIntent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, SearchSquareActivity.<span class="keyword">class</span>);
        <span class="keyword">this</span>.mInfoIntent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, MessageGroup.<span class="keyword">class</span>);
        <span class="keyword">this</span>.mUserInfoIntent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, MyInfoActivity.<span class="keyword">class</span>);
        <span class="keyword">this</span>.mMoreIntent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, MoreItemsActivity.<span class="keyword">class</span>);

        initRadios();

        setupIntent();
    }

    <span class="javadoc">/**
     * 初始化底部按钮
     */</span>
    <span class="keyword">private</span> <span class="typename">void</span> initRadios() {
         ((RadioButton) findViewById(R.id.radio_button0)).setOnCheckedChangeListener(<span class="keyword">this</span>);
         ((RadioButton) findViewById(R.id.radio_button1)).setOnCheckedChangeListener(<span class="keyword">this</span>);
         ((RadioButton) findViewById(R.id.radio_button2)).setOnCheckedChangeListener(<span class="keyword">this</span>);
         ((RadioButton) findViewById(R.id.radio_button3)).setOnCheckedChangeListener(<span class="keyword">this</span>);
         ((RadioButton) findViewById(R.id.radio_button4)).setOnCheckedChangeListener(<span class="keyword">this</span>);
    }

    <span class="javadoc">/**
     * 切换模块
     */</span>
    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="typename">void</span> onCheckedChanged(CompoundButton buttonView, <span class="typename">boolean</span> isChecked) {
        <span class="keyword">if</span> (isChecked) {
            <span class="keyword">switch</span> (buttonView.getId()) {
            <span class="keyword">case</span> R.id.<span class="string">radio_button0:</span>
                <span class="keyword">this</span>.mHost.setCurrentTabByTag(<span class="string">"mblog_tab"</span>);
                <span class="keyword">break</span>;
            <span class="keyword">case</span> R.id.<span class="string">radio_button1:</span>
                <span class="keyword">this</span>.mHost.setCurrentTabByTag(<span class="string">"message_tab"</span>);
                <span class="keyword">break</span>;
            <span class="keyword">case</span> R.id.<span class="string">radio_button2:</span>
                <span class="keyword">this</span>.mHost.setCurrentTabByTag(<span class="string">"userinfo_tab"</span>);
                <span class="keyword">break</span>;
            <span class="keyword">case</span> R.id.<span class="string">radio_button3:</span>
                <span class="keyword">this</span>.mHost.setCurrentTabByTag(<span class="string">"search_tab"</span>);
                <span class="keyword">break</span>;
            <span class="keyword">case</span> R.id.<span class="string">radio_button4:</span>
                <span class="keyword">this</span>.mHost.setCurrentTabByTag(<span class="string">"more_tab"</span>);
                <span class="keyword">break</span>;
            }
        }
    }

    <span class="keyword">private</span> <span class="typename">void</span> setupIntent() {
        <span class="keyword">this</span>.mHost = getTabHost();
        TabHost localTabHost = <span class="keyword">this</span>.mHost;

        localTabHost.addTab(buildTabSpec(<span class="string">"mblog_tab"</span>, R.string.main_home,
                R.drawable.icon_1_n, <span class="keyword">this</span>.mMBlogIntent));

        localTabHost.addTab(buildTabSpec(<span class="string">"message_tab"</span>, R.string.main_news,
                R.drawable.icon_2_n, <span class="keyword">this</span>.mInfoIntent));

        localTabHost.addTab(buildTabSpec(<span class="string">"userinfo_tab"</span>, R.string.main_my_info,
                R.drawable.icon_3_n, <span class="keyword">this</span>.mUserInfoIntent));

        localTabHost.addTab(buildTabSpec(<span class="string">"search_tab"</span>, R.string.menu_search,
                R.drawable.icon_4_n, <span class="keyword">this</span>.mSearchIntent));

        localTabHost.addTab(buildTabSpec(<span class="string">"more_tab"</span>, R.string.more,
                R.drawable.icon_5_n, <span class="keyword">this</span>.mMoreIntent));

    }

    <span class="keyword">private</span> TabHost.TabSpec buildTabSpec(String tag, <span class="typename">int</span> resLabel, <span class="typename">int</span> resIcon,
            <span class="keyword">final</span> Intent content) {
        <span class="keyword">return</span> <span class="keyword">this</span>.mHost
                .newTabSpec(tag)
                .setIndicator(getString(resLabel),
                        getResources().getDrawable(resIcon))
                .setContent(content);
    }
</code></pre><p>代码说明</p>
<ol>
<li>由于TabWidget被隐藏，所以相关的事件也会无效，这里取巧用RadioGroup与RadioButton的特性来处理切换，然后监听事件调用setCurrentTabByTag来切换Activity。</li>
</ol>
<ol>
<li>注意即使TabWidget被隐藏，也要为其设置indicator，否则会保持。</li>
</ol>
<p>三、总结<br>在这之前如果要做这种效果我恐怕第一时间就会想到用ActivityGroup来做，主要是因为TabHost的TabWidget非常难看，用起<br>来也不方便。其实从源码可以看出，TabActivity也是继承自ActivityGroup，这里结合了单选按钮和TabHost，各取其长，有时间<br>可以专门写一个这样的自定义控件:)</p>
<p>四、相关文章</p>
<p><a href="http://www.cnblogs.com/over140/archive/2010/09/07/1820876.html" target="_blank" rel="external">[Android]使用ActivityGroup来切换Activity和Layout</a></p>
<p>结束</p>
<p>本文中使用的资源均反编译自apk文件，这里主要是讲思路，欢迎大家交流。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>前言</p>
<p>为了更好的开发Android应用程序，除了熟练掌握基本的UI组件和API外，还需要掌握一些技巧，而这些技巧可以通过阅读一些代码来提高，本系列将与大家分享一些新浪微博布局方面的收获，欢迎交流！</p>
<p>声明</p>
<p>欢迎转载，但请保留文章原始出]]>
    </summary>
    
      <category term="Android" scheme="http://www.flysnow.org/tags/Android/"/>
    
      <category term="Android" scheme="http://www.flysnow.org/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[编写高效的Android代码]]></title>
    <link href="http://www.flysnow.org/2011/02/22/writing-efficient-android-code.html"/>
    <id>http://www.flysnow.org/2011/02/22/writing-efficient-android-code.html</id>
    <published>2011-02-21T18:38:51.000Z</published>
    <updated>2016-05-22T10:14:57.302Z</updated>
    <content type="html"><![CDATA[<p>毫无疑问，基于Android平台的设备一定是嵌入式设备。现代的手持设备不仅仅是一部电话那么简单，它还是一个小型的手持电脑，但是，即使是最快的最高端的手持设备也远远比不上一个中等性能的桌面机。</p>
<p>这就是为什么在编写Android程序时要时刻考虑执行的效率，这些系统不是想象中的那么快，并且你还要考虑它电池的续航能力。这就意味着没有多少剩余空间给你去浪费了，因此，在你写Android程序的时候，要尽可能的使你的代码优化而提高效率。</p>
<p>本页介绍了几种可以让开发者的Android程序运行的更加有效率的方法。通过下面的一些跳转的连接，你可以学会怎么让你的程序更加有效运行</p>
<p>内容</p>
<ul>
<li>介绍</li>
</ul>
<ul>
<li>尽量避免创建对象</li>
</ul>
<ul>
<li>使用自身方法</li>
</ul>
<ul>
<li>使用虚拟优于使用接口</li>
</ul>
<ul>
<li>使用静态优于使用虚拟</li>
</ul>
<ul>
<li>避免内部使用Setter和Getter</li>
</ul>
<ul>
<li>缓冲属性调用</li>
</ul>
<ul>
<li>声明Final常量</li>
</ul>
<ul>
<li>慎重使用增强型的For循环语句</li>
</ul>
<ul>
<li>避免列举类型Avoid Enums</li>
</ul>
<ul>
<li>通过内联类使用包空间</li>
</ul>
<ul>
<li>尽量避免浮点类型</li>
</ul>
<ul>
<li>一些标准操作的时间比较</li>
</ul>
<ul>
<li><a href="/admin/blogs/l#closing_notes">结束语</a></li>
</ul>
<h2 id="介绍">介绍</h2><p>对于如何判断一个系统的不合理，这里有两个基本的原则：</p>
<ul>
<li>不要做不必要做的事情。</li>
</ul>
<ul>
<li>尽可能的节省内存的使用。</li>
</ul>
<p>下面的所有方法都是基于这两项的。</p>
<p>有人会认为本页花了大量的篇幅去讲如何进行“初步优化”（ premature<br>optimization）。虽然有时候微观优化对开发高效的数据结构和算法很困难，但是在嵌入式手持设备上面你毫无选择。例如，如果把桌面电脑的虚拟机<br>移植到你的Android系统中，你会发现你写的程序会耗尽你的内存。这就会导致程序运行起来极度缓慢，即使不考虑它对系统上其他的运行程序的影响。</p>
<p>这就是为什么上面两条原则这么重要。Android的成功在于开发程序提供给用户的体验，然而用户体验的好坏又决定于你的代码是否能及时的响应而不<br>至于慢的让人崩溃。因为我们所有的程序都会在同一个设备上面运行，所以我们把它们作为一个整体来考虑。本文就像你考驾照需要学习的交通规则一样：如果所有<br>人遵守，事情就会很流畅；但当你不遵守时，你就会撞车。</p>
<p>在我们讨论实质问题之前，有一个简要的说明：无论虚拟机是否是Java编译器的一个特点，下面介绍的所有观点都是正确的。如果我们有两种方法完成同<br>样的事情，但是foo()的解释执行要快于bar()，那么foo()的编译速度一定不会比bar()慢，仅仅靠编译器使你的代码运行速度提升是不明智的<br>做法。</p>
<h2 id="尽可能避免创建对象（Object）">尽可能避免创建对象（Object）</h2><p>对象的创建并不是没有代价的。一个带有线程分配池的generational的内存管理机制会使创建临时对象的代价减少，不是分配内存总比不上不分配内存好。</p>
<p>如果你在一个用户界面的循环中分配一个对象，你不得不强制的进行内存回收，那么就会使用户体验出现稍微“打嗝”的现象。</p>
<p>因此，如果没有必要你就不应该创建对象实例。下面是一件有帮助的例子：</p>
<ul>
<li>当从原始的输入数据中提取字符串时，试着从原始字符串返回一个子字符串，而不是创建一份拷贝。你将会创建一个新的字符串对象，但是它和你的原始数据共享数据空间。</li>
</ul>
<ul>
<li>如果你有一个返回字符串地方法，你应该知道无论如何返回的结果是StringBuffer，改变你的函数的定义和执行，让函数直接返回而不是通过创建一个临时的对象。</li>
</ul>
<p>一个比较激进的方法就是把一个多维数组分割成几个平行的一维数组：</p>
<ul>
<li>一个Int类型的数组要比一个Integer类型的数组要好，但着同样也可以归纳于这样一个原则，两个Int类型的数组要比一个（int，int）对象数组的效率要高的多<br>。对于其他原始数据类型，这个原则同样适用。</li>
</ul>
<ul>
<li><br>如果你需要创建一个包含一系列Foo和Bar对象的容器（container）时，记住：两个平行的Foo[]和Bar[]要比一个（Foo,Bar）对<br>象数组的效率高得多。（这个例子也有一个例外，当你设计其他代码的接口API时；在这种情况下，速度上的一点损失就不用考虑了。但是，在你的代码里面，你<br>应该尽可能的编写高效代码。）</li>
</ul>
<p>一般来说，尽可能的避免创建短期的临时对象。越少的对象创建意味着越少的垃圾回收，这会提高你程序的用户体验质量。</p>
<h2 id="使用自身方法（Use_Native_Methods）">使用自身方法（Use Native Methods）</h2><p>当处理字符串的时候，不要犹豫，尽可能多的使用诸如String.indexOf()、String.lastIndexOf()这样对象自身带有的方法。因为这些方法使用C/C++来实现的，要比在一个java循环中做同样的事情快10-100倍。</p>
<p>还有一点要补充说明的是，这些自身方法使用的代价要比那些解释过的方法高很多，因而，对于细微的运算，尽量不用这类方法。</p>
<h2 id="使用虚拟优于使用接口">使用虚拟优于使用接口</h2><p>假设你有一个HashMap对象，你可以声明它是一个HashMap或则只是一个Map：</p>
<pre><code>Map myMap1 = <span class="keyword">new</span> <span class="keyword">HashMap</span>();
<span class="keyword">HashMap</span> myMap2 = <span class="keyword">new</span> <span class="keyword">HashMap</span>();
</code></pre><p>哪一个更好呢？</p>
<p>一般来说明智的做法是使用Map，因为它能够允许你改变Map接口执行上面的任何东西，但是这种“明智”的方法只是适用于常规的编程，对于嵌入式系统并不适合。通过接口引用来调用会花费2倍以上的时间，相对于通过具体的引用进行虚拟函数的调用。</p>
<p>如果你选择使用一个HashMap，因为它更适合于你的编程，那么使用Map会毫无价值。假定你有一个能重构你代码的集成编码环境，那么调用Map<br>没有什么用处，即使你不确定你的程序从哪开头。（同样，public的API是一个例外，一个好的API的价值往往大于执行效率上的那点损失）</p>
<h2 id="使用静态优于使用虚拟">使用静态优于使用虚拟</h2><p>如果你没有必要去访问对象的外部，那么使你的方法成为静态方法。它会被更快的调用，因为它不需要一个虚拟函数导向表。这同时也是一个很好的实践，因为它告诉你如何区分方法的性质（signature），调用这个方法不会改变对象的状态。</p>
<h2 id="尽可能避免使用内在的Get、Set方法">尽可能避免使用内在的Get、Set方法</h2><p>像C++iyangde编程语言，通常会使用Get方法(例如<code>i = getCount()</code><br>)去取代直接访问这个属性（<code>i=mCount</code><br>）。 这在C++编程里面是一个很好的习惯，因为编译器会把访问方式设置为Inline，并且如果想约束或调试属性访问，你只需要在任何时候添加一些代码。</p>
<p>在Android编程中，这不是一个很不好的主意。虚方法的调用会产生很多代价，比实例属性查询的代价还要多。我们应该在外部调用时使用Get和Set函数，但是在内部调用时，我们应该直接调用。</p>
<h2 id="缓冲属性调用Cache_Field_Lookups">缓冲属性调用Cache Field Lookups</h2><p>访问对象属性要比访问本地变量慢得多。你不应该这样写你的代码：</p>
<pre><code>for <span class="comment">(int i = 0; i &lt; this.mCount; i++)</span>
      dumpItem<span class="comment">(this.mItems[i])</span>;
</code></pre><p>而是应该这样写：</p>
<pre><code><span class="keyword">int</span> <span class="keyword">count</span> = <span class="keyword">this</span>.mCount;
Item[] items = <span class="keyword">this</span>.mItems;

<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">count</span>; i++)
    dumpItems(items[i]);
</code></pre><p>（我们直接使用“this”表明这些是它的成员变量）</p>
<p>一个相似的原则就是：决不在一个For语句中第二次调用一个类的方法。例如，下面的代码就会一次又一次地执行getCount（）方法，这是一个极大地浪费相比你把它直接隐藏到一个Int变量中。</p>
<pre><code>for <span class="comment">(int i = 0; i &lt; this.getCount()</span>; i++)
    dumpItems<span class="comment">(this.getItem(i)</span>);
</code></pre><p>这是一个比较好的办法，当你不止一次的调用某个实例时，直接本地化这个实例，把这个实例中的某些值赋给一个本地变量。例如：</p>
<pre><code> <span class="keyword">protected</span> <span class="keyword">void</span> drawHorizontalScrollBar(Canvas canvas, <span class="built_in">int</span> <span class="variable">width</span>, <span class="built_in">int</span> <span class="variable">height</span>) {
        <span class="keyword">if</span> (isHorizontalScrollBarEnabled()) {
            <span class="built_in">int</span> <span class="built_in">size</span> = mScrollBar.getSize(<span class="keyword">false</span>

);
            <span class="keyword">if</span> (<span class="built_in">size</span> &lt;= <span class="number">0</span>) {
                <span class="built_in">size</span> = mScrollBarSize;
            }
            mScrollBar.setBounds(<span class="number">0</span>, <span class="variable">height</span>- <span class="built_in">size</span>, <span class="variable">width</span>, <span class="variable">height</span>);
            mScrollBar.setParams(
                    computeHorizontalScrollRange(),
                    computeHorizontalScrollOffset(),
                    computeHorizontalScrollExtent(), <span class="keyword">false</span>

);
            mScrollBar.<span class="title">draw</span>(canvas);
        }
    }
</code></pre><p>这里有四次<code>mScrollBar</code><br>的属性调用，把<code>mScrollBar</code><br>缓冲到一个堆栈变量之中，四次成员属性的调用就会变成四次堆栈的访问，这样就会提高效率。</p>
<p>附带说一下，对于方法同样也可以像本地变量一样具有相同的特点。</p>
<h2 id="声明Final常量">声明Final常量</h2><p>我们可以看看下面一个类顶部的声明：</p>
<pre><code><span class="literal">static</span> <span class="built_in">int</span> intVal = <span class="number">42</span>;
<span class="literal">static</span> <span class="built_in">String</span> strVal = <span class="string">"Hello, world!"</span>;
</code></pre><p>当一个类第一次使用时，编译器会调用一个类初始化方法——<code>`
，这个方法将42存入变量</code>intVal<code>，并且为</code>strVal`<br>在类文件字符串常量表中提取一个引用，当这些值在后面引用时，就会直接属性调用。</p>
<p>我们可以用关键字“final”来改进代码：</p>
<pre><code><span class="literal">static</span> <span class="keyword">final</span> <span class="built_in">int</span> intVal = <span class="number">42</span>;
<span class="literal">static</span> <span class="keyword">final</span> <span class="built_in">String</span> strVal = <span class="string">"Hello, world!"</span>;
</code></pre><p>这个类将不会调用es a <code>`
方法，因为这些常量直接写入了类文件静态属性初始化中，这个初始化直接由虚拟机来处理。代码访问</code>intVal<code>将会使用Integer类型的42，访问</code>strVal`<br>将使用相对节省的“字符串常量”来替代一个属性调用。</p>
<p>将一个类或者方法声明为“final”并不会带来任何的执行上的好处，它能够进行一定的最优化处理。例如，如果编译器知道一个Get方法不能被子类重载，那么它就把该函数设置成Inline。</p>
<p>同时，你也可以把本地变量声明为final变量。但是，这毫无意义。作为一个本地变量，使用final只能使代码更加清晰（或者你不得不用，在匿名访问内联类时）。</p>
<h2 id="慎重使用增强型For循环语句">慎重使用增强型For循环语句</h2><p>增强型For循环（也就是常说的“For-each循环”）经常用于Iterable接口的继承收集接口上面。在这些对象里面，一个<br>iterator被分配给对象去调用它的hasNext（）和next（）方法。在一个数组列表里面，你可以自己接的敷衍它，在其他的收集器里面，增强型<br>的for循环将相当于iterator的使用。</p>
<p>尽管如此，下面的源代码给出了一个可以接受的增强型for循环的例子：</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>{
    <span class="keyword">int</span> mSplat;
    <span class="keyword">static</span> Foo mArray[] = <span class="keyword">new</span> Foo[<span class="number">27</span>];

    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> zero() {
        <span class="keyword">int</span> <span class="keyword">sum</span> = <span class="number">0</span>;
        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mArray.length; i++) {
            <span class="keyword">sum</span> += mArray[i].mSplat;
        }
    }

    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> one() {
        <span class="keyword">int</span> <span class="keyword">sum</span> = <span class="number">0</span>;
        Foo[] localArray = mArray;
        <span class="keyword">int</span> len = localArray.length;

        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) {
            <span class="keyword">sum</span> += localArray[i].mSplat;
        }
    }

    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> two() {
        <span class="keyword">int</span> <span class="keyword">sum</span> = <span class="number">0</span>;
        <span class="keyword">for</span> (Foo a: mArray) {
            <span class="keyword">sum</span> += a.mSplat;
        }
    }
}
</code></pre><p>zero()<br>函数在每一次的循环中重新得到静态属性两次，获得数组长度一次。</p>
<p>one()<br>函数把所有的东西都变为本地变量，避免类查找属性调用</p>
<p>two()</p>
<p>函数使用Java语言的1.5版本中的for循环语句，编辑者产生的源代码考虑到了拷贝数组的引用和数组的长度到本地变量，是例遍数组比较好的方法，它在<br>主循环中确实产生了一个额外的载入和储存过程（显然保存了“a”），相比函数one（）来说，它有一点比特上的减慢和4字节的增长。</p>
<p>总结之后，我们可以得到：增强的for循环在数组里面表现很好，但是当和Iterable对象一起使用时要谨慎，因为这里多了一个对象的创建。</p>
<h2 id="避免列举类型Avoid_Enums">避免列举类型Avoid Enums</h2><p>列举类型非常好用，当考虑到尺寸和速度的时候，就会显得代价很高，例如：</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> {</span>
   <span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Shrubbery</span> {</span> GROUND, CRAWLING, HANGING }
}
</code></pre><p>这会转变成为一个900字节的class文件（Foo$Shrubbery.class）。第一次使用时，类的初始化要在独享上面调用方法去描述列举的每一项，每一个对象都要有它自身的静态空间，整个被储存在一个数组里面（一个叫做“$VALUE”的静态数组）。那是一大堆的代码和数据，仅仅是为了三个整数值。</p>
<pre><code><span class="attribute">Shrubbery shrub </span>=<span class="string"> Shrubbery.GROUND;</span>
</code></pre><p>这会引起一个静态属性的调用，如果GROUND是一个静态的Final变量，编译器会把它当做一个常数嵌套在代码里面。</p>
<p>还有一点要说的，通过列举，你可以得到更好地API和一些编译时间上的检查。因此，一种比较平衡的做法就是：你应该尽一切方法在你的公用API中使用列举型变量，当处理问题时就尽量的避免。</p>
<p>在一些环境下面，通过<code>ordinal</code><br>（）方法获取一个列举变量的整数值是很有用的，例如：把下面代码</p>
<pre><code><span class="keyword">for</span> (int <span class="keyword">n</span> = 0; <span class="keyword">n</span> &lt; <span class="keyword">list</span>.size(); <span class="keyword">n</span>++) {
    <span class="keyword">if</span> (<span class="keyword">list</span>.items[<span class="keyword">n</span>].<span class="keyword">e</span> == MyEnum.VAL_X)
       <span class="comment">// do stuff 1</span>
    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">list</span>.items[<span class="keyword">n</span>].<span class="keyword">e</span> == MyEnum.VAL_Y)
       <span class="comment">// do stuff 2</span>
}
</code></pre><p>替换为：</p>
<pre><code>int valX = MyEnum.VAL_X.ordinal();
int valY = MyEnum.VAL_Y.ordinal();
int <span class="keyword">count</span> = <span class="keyword">list</span>.size();
MyItem items = <span class="keyword">list</span>.items();

<span class="keyword">for</span> (int  <span class="keyword">n</span> = 0; <span class="keyword">n</span> &lt; <span class="keyword">count</span>; <span class="keyword">n</span>++)
{
     int  valItem = items[<span class="keyword">n</span>].<span class="keyword">e</span>.ordinal();

     <span class="keyword">if</span> (valItem == valX)
       <span class="comment">// do stuff 1</span>
     <span class="keyword">else</span> <span class="keyword">if</span> (valItem == valY)
       <span class="comment">// do stuff 2</span>
}
</code></pre><p>在一些条件下，这会执行的更快，虽然没有保障。</p>
<h2 id="通过内联类使用包空间">通过内联类使用包空间</h2><p>我们看下面的类声明</p>
<pre><code><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Foo</span> {
    <span class="keyword">private</span> <span class="keyword">int</span> mValue;

    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
        Inner <span class="keyword">in</span> = <span class="keyword">new</span> Inner();
        mValue = <span class="number">27</span>;
        <span class="keyword">in</span>.stuff();
    }

    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doStuff</span><span class="params">(<span class="keyword">int</span> <span class="keyword">value</span>)</span> </span>{
        System.<span class="keyword">out</span>.println(<span class="string">"Value is "</span> + <span class="keyword">value</span>);
    }

    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title">Inner</span> {
        <span class="function"><span class="keyword">void</span> <span class="title">stuff</span><span class="params">()</span> </span>{
            Foo.<span class="keyword">this</span>.doStuff(Foo.<span class="keyword">this</span>.mValue);
        }
    }
}
</code></pre><p>这里我们要注意的是我们定义了一个内联类，它调用了外部类的私有方法和私有属性。这是合法的调用，代码应该会显示”Value is 27”。</p>
<p>问题是Foo$Inner在理论上（后台运行上）是应该是一个完全独立的类，它违规的调用了Foo的私有成员。为了弥补这个缺陷，编译器产生了一对合成的方法：</p>
<pre><code><span class="comment">/*package*/</span> <span class="keyword">static</span> <span class="keyword">int</span> Foo.access$<span class="number">100</span>(Foo foo) {
    <span class="keyword">return</span> foo.mValue;
}
<span class="comment">/*package*/</span> <span class="keyword">static</span> <span class="keyword">void</span> Foo.access$<span class="number">200</span>(Foo foo, <span class="keyword">int</span> <span class="keyword">value</span>) {
    foo.doStuff(<span class="keyword">value</span>);
}
</code></pre><p>当内联类需要从外部访问“mValue”和调用“doStuff”时，内联类就会调用这些静态的方法，这就意味着你不是直接访问类成员，而是通过公共的方法来访问的。前面我们谈过间接访问要比直接访问慢，因此这是一个按语言习惯无形执行的例子。</p>
<p>让拥有包空间的内联类直接声明需要访问的属性和方法，我们就可以避免这个问题，哲理诗是包空间而不是私有空间。这运行的更快并且去除了生成函数前面<br>东西。（不幸的是，它同时也意味着该属性也能够被相同包下面的其他的类直接访问，这违反了标准的面向对象的使所有属性私有的原则。同样，如果是设计公共的<br>API你就要仔细的考虑这种优化的用法）</p>
<h2 id="避免浮点类型的使用">避免浮点类型的使用</h2><p>在奔腾CPU发布之前，游戏作者尽可能的使用Integer类型的数学函数是很正常的。在奔腾处理器里面，浮点数的处理变为它一个突出的特点，并且浮点数与整数的交互使用相比单独使用整数来说，前者会使你的游戏运行的更快，一般的在桌面电脑上面我们可以自由的使用浮点数。</p>
<p>不幸的是，嵌入式的处理器通常并不支持浮点数的处理，阴齿所有的“float”和“double”操作都是通过软件进行的，一些基本的浮点数的操作就需要花费毫秒级的时间。</p>
<p>同事，即使是整数，一些芯片也只有乘法而没有除法。在这些情况下，整数的除法和取模操作都是通过软件实现。当你创建一个Hash表或者进行大量的数学运算时，这都是你要考虑的。</p>
<h2 id="一些标准操作的时间比较">一些标准操作的时间比较</h2><p>为了距离说明我们的观点，下面有一张表，包括一些基本操作所使用的大概时间。注意这些时间并不是绝对的时间，绝对时间要考虑到CPU和时钟频率。系<br>统不同，时间的大小也会有所差别。当然，这也是一种有意义的比较方法，我们可以比叫不同操作花费的相对时间。例如，添加一个成员变量的时间是添加一个本地<br>变量的四倍。</p>
<p>Action<br>Time</p>
<table border="0"><br><tbody><br><tr><br><br><td>Add a local variable<br></td><br><br><td>1<br></td><br></tr><br><tr><br><br><td>Add a member variable<br></td><br><br><td>4<br></td><br></tr><br><tr><br><br><td>Call String.length()<br></td><br><br><td>5<br></td><br></tr><br><tr><br><br><td>Call empty static native method<br></td><br><br><td>5<br></td><br></tr><br><tr><br><br><td>Call empty static method<br></td><br><br><td>12<br></td><br></tr><br><tr><br><br><td>Call empty virtual method<br></td><br><br><td>12.5<br></td><br></tr><br><tr><br><br><td>Call empty interface method<br></td><br><br><td>15<br></td><br></tr><br><tr><br><br><td>Call Iterator:next() on a HashMap<br></td><br><br><td>165<br></td><br></tr><br><tr><br><br><td>Call put() on a HashMap<br></td><br><br><td>600<br></td><br></tr><br><tr><br><br><td>Inflate 1 View from XML<br></td><br><br><td>22,000<br></td><br></tr><br><tr><br><br><td>Inflate 1 LinearLayout containing 1 TextView<br></td><br><br><td>25,000<br></td><br></tr><br><tr><br><br><td>Inflate 1 LinearLayout containing 6 View objects<br></td><br><br><td>100,000<br></td><br></tr><br><tr><br><br><td>Inflate 1 LinearLayout containing 6 TextView objects<br></td><br><br><td>135,000<br></td><br></tr><br><tr><br><br><td>Launch an empty activity<br></td><br><br><td>3,000,000<br></td><br></tr><br></tbody><br></table>



<h2 id="结束语">结束语</h2><p>写高效的嵌入式程序的最好方法就是要搞清楚你写的程序究竟做了些什么。如果你真的想分配一个iterator类，进一切方法的在一个List中使用增强型的for循环，使它成为一个有意而为之的做法，而不是一个无意的疏漏而产生负面影响。</p>
<p>有备无患，搞清楚你在做什么！你可以假如你自己的一些行为准则，但是一定要注意你的代码正在做什么，然后开始寻找方法去优化它。</p>
<p>转自：<a href="http://www.chinaup.org/docs/toolbox/performance.html" target="_blank" rel="external">http://www.chinaup.org/docs/toolbox/performance.html</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>毫无疑问，基于Android平台的设备一定是嵌入式设备。现代的手持设备不仅仅是一部电话那么简单，它还是一个小型的手持电脑，但是，即使是最快的最高端的手持设备也远远比不上一个中等性能的桌面机。</p>
<p>这就是为什么在编写Android程序时要时刻考虑执行的效率，这些系统]]>
    </summary>
    
      <category term="Android" scheme="http://www.flysnow.org/tags/Android/"/>
    
      <category term="Android" scheme="http://www.flysnow.org/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android中为图标加上数字--用于未读短信数提醒，待更新应用数提醒等]]></title>
    <link href="http://www.flysnow.org/2011/02/15/android-icon-with-number.html"/>
    <id>http://www.flysnow.org/2011/02/15/android-icon-with-number.html</id>
    <published>2011-02-14T21:48:01.000Z</published>
    <updated>2016-05-22T10:14:57.302Z</updated>
    <content type="html"><![CDATA[<p>在我们开发一些如短消息、应用商店等应用时，会考虑在短消息的图标上加上未读短信的数量，在应用商店上加上可以升级的应用数量，这样不占太大空间还能达到提示的目的。</p>
<p>本节就以一个展示手机内联系人数量的例子来演示怎么在一个图标的上面加上数字的例子，也就是一个数字overlay..做过google map开发的知道overlay这个东西。。</p>
<h2 id="一：你可学到">一：你可学到</h2><ol>
<li>手机内依据Uri查看联系人</li>
</ol>
<ol>
<li>权限的添加</li>
</ol>
<ol>
<li>获取手机内任意一款应用的应用图标</li>
</ol>
<ol>
<li>对图形的处理，如复制，为图片加上覆盖层—数字。</li>
</ol>
<ol>
<li>使用RemoteView自定义Notification</li>
</ol>
<h2 id="二：开始行动">二：开始行动</h2><ol>
<li>新建名为NotificationIconCount的Android Project。附件中有最终版本的项目工程</li>
</ol>
<ol>
<li>首先修改AndroidManifest.xml,加入权限,因为我们要读取联系人。</li>
</ol>
<ol>
<li>修改main.xml如下,这里定义一个ImageView，勇于预览我们处理好的加上数字的图标。</li>
</ol>
<pre><code><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span>
<span class="tag">&lt;<span class="title">LinearLayout</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span>
    <span class="attribute">android:orientation</span>=<span class="value">"vertical"</span>
    <span class="attribute">android:layout_width</span>=<span class="value">"fill_parent"</span>
    <span class="attribute">android:layout_height</span>=<span class="value">"fill_parent"</span>
    &gt;</span>
    <span class="tag">&lt;<span class="title">ImageView</span> 
        <span class="attribute">android:id</span>=<span class="value">"@+id/icon"</span>
        <span class="attribute">android:layout_width</span>=<span class="value">"wrap_content"</span>
        <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span>
        <span class="attribute">android:scaleType</span>=<span class="value">"center"</span>
        <span class="attribute">android:adjustViewBounds</span>=<span class="value">"true"</span>/&gt;</span>
<span class="tag">&lt;/<span class="title">LinearLayout</span>&gt;</span>
</code></pre><ol>
<li>先来获取手机内通讯录的图标，如果没有获取到，则使用该应用的图标.</li>
</ol>
<pre><code><span class="keyword">super</span>.onCreate(savedInstanceState);
        setContentView(R.layout.main);
        mImageView=(ImageView)findViewById(R.id.icon);
        <span class="comment">//优先采用联系人的图标，如果不存在则采用该应用的图标</span>
        Drawable contactIcon;
        <span class="keyword">try</span> {
            contactIcon = getPackageManager().getApplicationIcon(<span class="string">"com.android.contacts"</span>);
        } <span class="keyword">catch</span> (NameNotFoundException e) {
            contactIcon=<span class="literal">null</span>;
        }
        Bitmap icon;
        <span class="keyword">if</span>(contactIcon <span class="keyword">instanceof</span> BitmapDrawable){
            icon=((BitmapDrawable)contactIcon).getBitmap();
        }<span class="keyword">else</span>{
            icon=getResIcon(getResources(), R.id.icon);
        }
</code></pre><p>这里用到一个自定义的根据资源图标id获取图片的函数，很简单，代码如下：</p>
<pre><code><span class="javadoc">/**
 * 根据id获取一个图片
 *<span class="javadoctag"> @param</span> res
 *<span class="javadoctag"> @param</span> resId
 *<span class="javadoctag"> @return</span>
 */</span>
<span class="keyword">private</span> <span class="function">Bitmap <span class="title">getResIcon</span><span class="params">(Resources res,<span class="keyword">int</span> resId)</span></span>{
    Drawable icon=res.getDrawable(resId);
    <span class="keyword">if</span>(icon <span class="keyword">instanceof</span> BitmapDrawable){
        BitmapDrawable bd=(BitmapDrawable)icon;
        <span class="function"><span class="keyword">return</span> bd.<span class="title">getBitmap</span><span class="params">()</span></span>;
    }<span class="keyword">else</span>{
        <span class="keyword">return</span> <span class="keyword">null</span>;
    }
}
</code></pre><ol>
<li>获取到图标之后就要对这个图标进行处理了，要为该图标加上联系人数量的覆盖，首先我们看获取联系人个数的函数。</li>
</ol>
<pre><code><span class="javadoc">/**
     * 获取联系人的个数
     *<span class="javadoctag"> @return</span> 手里通讯录中联系人的个数
     */</span>
    <span class="keyword">private</span> <span class="function"><span class="keyword">int</span> <span class="title">getContactCount</span><span class="params">()</span></span>{
        Cursor c=getContentResolver().query(ContactsContract.Contacts.CONTENT_URI, <span class="keyword">new</span> String[]{ContactsContract.Contacts._COUNT}, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);
        <span class="keyword">try</span>{
            c.moveToFirst();
            <span class="function"><span class="keyword">return</span> c.<span class="title">getInt</span><span class="params">(<span class="number">0</span>)</span></span>;
        }<span class="keyword">catch</span>(Exception e){
            <span class="keyword">return</span> <span class="number">0</span>;
        }<span class="keyword">finally</span>{
            c.close();
        }
    }
</code></pre><p>这里采用Uri的方式获取联系人的cursor，然后获取个数。</p>
<ol>
<li>有了图标和联系人个数就可以生成带联系人个数的图标了，我们看下生成的这个函数。</li>
</ol>
<pre><code><span class="javadoc">/**
     * 在给定的图片的右上角加上联系人数量。数量用红色表示
     *<span class="javadoctag"> @param</span> icon 给定的图片
     *<span class="javadoctag"> @return</span> 带联系人数量的图片
     */</span>
    <span class="keyword">private</span> <span class="function">Bitmap <span class="title">generatorContactCountIcon</span><span class="params">(Bitmap icon)</span></span>{
        <span class="comment">//初始化画布</span>
        <span class="keyword">int</span> iconSize=(<span class="keyword">int</span>)getResources().getDimension(android.R.dimen.app_icon_size);
        Log.d(TAG, <span class="string">"the icon size is "</span>+iconSize);
        Bitmap contactIcon=Bitmap.createBitmap(iconSize, iconSize, Config.ARGB_8888);
        Canvas canvas=<span class="keyword">new</span> Canvas(contactIcon);

        <span class="comment">//拷贝图片</span>
        Paint iconPaint=<span class="keyword">new</span> Paint();
        iconPaint.setDither(<span class="keyword">true</span>);<span class="comment">//防抖动</span>
        iconPaint.setFilterBitmap(<span class="keyword">true</span>);<span class="comment">//用来对Bitmap进行滤波处理，这样，当你选择Drawable时，会有抗锯齿的效果</span>
        Rect src=<span class="keyword">new</span> Rect(<span class="number">0</span>, <span class="number">0</span>, icon.getWidth(), icon.getHeight());
        Rect dst=<span class="keyword">new</span> Rect(<span class="number">0</span>, <span class="number">0</span>, iconSize, iconSize);
        canvas.drawBitmap(icon, src, dst, iconPaint);

        <span class="comment">//在图片上创建一个覆盖的联系人个数</span>
        <span class="keyword">int</span> contacyCount=getContactCount();
        <span class="comment">//启用抗锯齿和使用设备的文本字距</span>
        Paint countPaint=<span class="keyword">new</span> Paint(Paint.ANTI_ALIAS_FLAG|Paint.DEV_KERN_TEXT_FLAG);
        countPaint.setColor(Color.RED);
        countPaint.setTextSize(<span class="number">20</span>f);
        countPaint.setTypeface(Typeface.DEFAULT_BOLD);
        canvas.drawText(String.valueOf(contacyCount), iconSize-<span class="number">18</span>, <span class="number">25</span>, countPaint);
        <span class="keyword">return</span> contactIcon;
    }
</code></pre><p>注释的很详细，就不解释了，无非就是定义一个画布(Canvas)，然后在上面画图标，画数字文本。</p>
<ol>
<li>然后我们把得到的这个处理过的Bitmap放在我们在main.xml里定义的ImageView里展示就可以看到效果了.</li>
</ol>
<pre><code>mImageView.setImageBitmap<span class="comment">(contactCountIcon)</span>;
</code></pre><ol>
<li>我们启动应用看看效果.</li>
</ol>
<p><img src="http://dl.iteye.com/upload/attachment/416490/e01bcd81-c359-366c-944b-1b451c698847.png" alt=""><br>我们看到了，右上角红色的1代表我手机中有一个联系人</p>
<h2 id="三：采用状态栏通知的办法展示联系人的数量">三：采用状态栏通知的办法展示联系人的数量</h2><ol>
<li>如果我们监听未读短信的数量，展示在状态栏通知了，就可以用这个方法，我这里还是以联系人的数量为例</li>
</ol>
<ol>
<li>由于Notification默认的icon字段使用的是一个一个资源的引用类型int,所以我们这里采用RemoteView的方式自定义Notification。定义RemoteView，需要一个layout，用于定义展示的Notification样式，我们新建一个notification.xml布局文件如下：</li>
</ol>
<pre><code>&lt;?xml <span class="variable">version=</span><span class="string">"1.0"</span> <span class="variable">encoding=</span><span class="string">"utf-8"</span>?&gt;
&lt;LinearLayout xmlns:<span class="variable">android=</span><span class="string">"http://schemas.android.com/apk/res/android"</span>
              android:<span class="variable">orientation=</span><span class="string">"horizontal"</span>
              android:<span class="variable">layout_width=</span><span class="string">"fill_parent"</span>
              android:<span class="variable">layout_height=</span><span class="string">"fill_parent"</span>
              android:<span class="variable">padding=</span><span class="string">"3dp"</span>
              &gt;
    &lt;ImageView android:<span class="variable">id=</span><span class="string">"@+id/image"</span>
              android:<span class="variable">layout_width=</span><span class="string">"wrap_content"</span>
              android:<span class="variable">layout_height=</span><span class="string">"fill_parent"</span>
              android:<span class="variable">layout_marginRight=</span><span class="string">"10dp"</span>
              /&gt;
    &lt;TextView android:<span class="variable">id=</span><span class="string">"@+id/text"</span>
              android:<span class="variable">layout_width=</span><span class="string">"wrap_content"</span>
              android:<span class="variable">layout_height=</span><span class="string">"fill_parent"</span>
              android:<span class="variable">textColor=</span><span class="string">"#000"</span>
              /&gt;
&lt;/LinearLayout&gt;
</code></pre><p>很简单，一个ImageView和一个TextView，用于显示提示的图标和文字。</p>
<ol>
<li>要想使用Notification，我们必须获取一个Service—NotificationManager,Android中由它来管理我们的Notification，获取NotificationManager的代码如下,卸载onCreate方法里</li>
</ol>
<pre><code><span class="attribute">nm</span>=<span class="string">(NotificationManager)getSystemService(Context.NOTIFICATION_SERVICE);</span>
</code></pre><ol>
<li>然后紧接着我们就调用我们定义好的方法来显示通知:</li>
</ol>
<pre><code><span class="function">showNotifacation</span>(contactCountIcon);
</code></pre><ol>
<li>下面我们看一下方法showNotifacation的具体实现:</li>
</ol>
<pre><code><span class="comment">/**
 * 显示状态栏通知
 * @param icon 通知内容图标
 */</span>
<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">showNotifacation</span><span class="params">(Bitmap icon)</span></span>{
    Notification notification=<span class="keyword">new</span>  Notification(R.drawable.icon,<span class="string">"联系人数量"</span>,System.currentTimeMillis());
    <span class="comment">//使用RemoteView自定义通知视图</span>
    RemoteViews contentView=<span class="keyword">new</span> RemoteViews(getPackageName(), R.layout.notification);
    contentView.setImageViewBitmap(R.id.image, icon);
    contentView.setTextViewText(R.id.text, <span class="string">"图标上的红色数字表示手机中联系人的数量"</span>);
    notification.contentView=contentView;
    Intent notificationIntent=<span class="keyword">new</span> Intent(<span class="keyword">this</span>, NotificationIconActivity.<span class="keyword">class</span>);
    PendingIntent contentIntent=PendingIntent.getActivity(<span class="keyword">this</span>, <span class="number">0</span>, notificationIntent, <span class="number">0</span>);
    notification.contentIntent=contentIntent;
    nm.notify(NOTIFICATION_CONTACT_ID, notification);
}
</code></pre><p>注释的都很详细，就不一一解释了</p>
<ol>
<li>最后的就是重写onDestroy，在Android销毁该Activity的时候清除我们的通知。</li>
</ol>
<pre><code><span class="annotation">@Override</span>
    <span class="keyword">protected</span> <span class="function"><span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>{
        <span class="keyword">super</span>.onDestroy();
        nm.cancel(NOTIFICATION_CONTACT_ID);
    }
</code></pre><ol>
<li>运行，可以看到如下效果<br><img src="http://dl.iteye.com/upload/attachment/416492/cf287cda-9c80-3fe1-8fe9-09d06f677b33.png" alt=""><br>可以看到，效果已经出来了。。</li>
</ol>
<h2 id="四：小结和一点引申">四：小结和一点引申</h2><p>这结的主要关键还是对图片的处理，比如这里的加上数字，当时你也可以加上其他的东西，Canvas里有很多相应的函数可以使用。。</p>
<p>这里说的都是应用内、状态通知等一些显示处理后图片的办法，那么有没有方法处理手机主屏幕上的图标的办法，为他们加上数字呢。比如在短信息的应用图标的右上角加上未读短信数目等,答案是有的，不过是迂回实现的，给个思路就是使用AppWidget,这个可以实现，还能动态更新，具体怎么实现，大家可以自己摸索下，这里只提供个思路，整体和这节的例子差不多，只不过呢，要做成AppWidget。。。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在我们开发一些如短消息、应用商店等应用时，会考虑在短消息的图标上加上未读短信的数量，在应用商店上加上可以升级的应用数量，这样不占太大空间还能达到提示的目的。</p>
<p>本节就以一个展示手机内联系人数量的例子来演示怎么在一个图标的上面加上数字的例子，也就是一个数字over]]>
    </summary>
    
      <category term="Android" scheme="http://www.flysnow.org/tags/Android/"/>
    
      <category term="Android" scheme="http://www.flysnow.org/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android GridView组件的使用]]></title>
    <link href="http://www.flysnow.org/2011/01/20/android-gridview-tutorial.html"/>
    <id>http://www.flysnow.org/2011/01/20/android-gridview-tutorial.html</id>
    <published>2011-01-20T01:41:53.000Z</published>
    <updated>2016-05-22T10:14:57.290Z</updated>
    <content type="html"><![CDATA[<p>GridView是一个网络布局的视图，他能让你的元素显示在一个个的格子里。我们的桌面就是一个GridView。。</p>
<ol>
<li>新建一个HelloGridView的工程</li>
</ol>
<ol>
<li>修改main.xml代码如下：</li>
</ol>
<pre><code>&lt;?xml <span class="variable">version=</span><span class="string">"1.0"</span> <span class="variable">encoding=</span><span class="string">"utf-8"</span>?&gt;
&lt;GridView
  xmlns:<span class="variable">android=</span><span class="string">"http://schemas.android.com/apk/res/android"</span>
  android:<span class="variable">id=</span><span class="string">"@+id/gridview"</span>
  android:<span class="variable">layout_width=</span><span class="string">"fill_parent"</span>
  android:<span class="variable">layout_height=</span><span class="string">"fill_parent"</span>
  android:<span class="variable">columnWidth=</span><span class="string">"90dp"</span>
  android:<span class="variable">numColumns=</span><span class="string">"auto_fit"</span>
  android:<span class="variable">horizontalSpacing=</span><span class="string">"10dp"</span>
  android:<span class="variable">verticalSpacing=</span><span class="string">"10dp"</span>
  android:<span class="variable">stretchMode=</span><span class="string">"columnWidth"</span>
  android:<span class="variable">gravity=</span><span class="string">"center"</span>&gt;
&lt;/GridView&gt;
</code></pre><p>很简单，就是一个GridView。设置列宽为90dp,这样当我们的numColumns设置为auto_fit时，Android就会自动计算我们手机屏幕的大小以决定每一行展示几个元素。这是很方便。android:horizontalSpacing定义列之间的间隔，android:verticalSpacing定义行之间的间隔。android:stretchMode设置为columnWidth是意味着根据列宽自动缩放。</p>
<ol>
<li>修改我们Activity HelloGridView如下：</li>
</ol>
<pre><code><span class="javadoc">/**
 * 
 *<span class="javadoctag"> @author</span> 飞雪无情
 *<span class="javadoctag"> @since</span> 2011-1-20
 */</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloGridView</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>{
    <span class="javadoc">/** Called when the activity is first created. */</span>
    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>{
        <span class="keyword">super</span>.onCreate(savedInstanceState);
        setContentView(R.layout.main);
        GridView gridView=(GridView)findViewById(R.id.gridview);
        gridView.setAdapter(<span class="keyword">new</span> ImageAdapter(<span class="keyword">this</span>));
        <span class="comment">//单击GridView元素的响应</span>
        gridView.setOnItemClickListener(<span class="keyword">new</span> OnItemClickListener() {

            <span class="annotation">@Override</span>
            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onItemClick</span><span class="params">(AdapterView&lt;!--?--&gt; parent, View view,
                    <span class="keyword">int</span> position, <span class="keyword">long</span> id)</span> </span>{
                <span class="comment">//弹出单击的GridView元素的位置</span>
                Toast.makeText(HelloGridView.<span class="keyword">this</span>,mThumbIds[position], Toast.LENGTH_SHORT).show();
            }
        });
    }
    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageAdapter</span> <span class="keyword">extends</span> <span class="title">BaseAdapter</span></span>{
        <span class="keyword">private</span> Context mContext;

        <span class="function"><span class="keyword">public</span> <span class="title">ImageAdapter</span><span class="params">(Context context)</span> </span>{
            <span class="keyword">this</span>.mContext=context;
        }

        <span class="annotation">@Override</span>
        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>{
            <span class="keyword">return</span> mThumbIds.length;
        }

        <span class="annotation">@Override</span>
        <span class="function"><span class="keyword">public</span> Object <span class="title">getItem</span><span class="params">(<span class="keyword">int</span> position)</span> </span>{
            <span class="keyword">return</span> mThumbIds[position];
        }

        <span class="annotation">@Override</span>
        <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getItemId</span><span class="params">(<span class="keyword">int</span> position)</span> </span>{
            <span class="comment">// TODO Auto-generated method stub</span>
            <span class="keyword">return</span> <span class="number">0</span>;
        }

        <span class="annotation">@Override</span>
        <span class="function"><span class="keyword">public</span> View <span class="title">getView</span><span class="params">(<span class="keyword">int</span> position, View convertView, ViewGroup parent)</span> </span>{
            <span class="comment">//定义一个ImageView,显示在GridView里</span>
            ImageView imageView;
            <span class="keyword">if</span>(convertView==<span class="keyword">null</span>){
                imageView=<span class="keyword">new</span> ImageView(mContext);
                imageView.setLayoutParams(<span class="keyword">new</span> GridView.LayoutParams(<span class="number">85</span>, <span class="number">85</span>));
                imageView.setScaleType(ImageView.ScaleType.CENTER_CROP);
                imageView.setPadding(<span class="number">8</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">8</span>);
            }<span class="keyword">else</span>{
                imageView = (ImageView) convertView;
            }
            imageView.setImageResource(mThumbIds[position]);
            <span class="keyword">return</span> imageView;
        }

    }
    <span class="comment">//展示图片</span>
    <span class="keyword">private</span> Integer[] mThumbIds = {
            R.drawable.sample_2, R.drawable.sample_3,
            R.drawable.sample_4, R.drawable.sample_5,
            R.drawable.sample_6, R.drawable.sample_7,
            R.drawable.sample_0, R.drawable.sample_1,
            R.drawable.sample_2, R.drawable.sample_3,
            R.drawable.sample_4, R.drawable.sample_5,
            R.drawable.sample_6, R.drawable.sample_7,
            R.drawable.sample_0, R.drawable.sample_1,
            R.drawable.sample_2, R.drawable.sample_3,
            R.drawable.sample_4, R.drawable.sample_5,
            R.drawable.sample_6, R.drawable.sample_7
    };
}
</code></pre><p>这里我们也是采用的自定义Adapter，可以上一节的自定义Adapter讲解。展示了一些图片，然后点击一个图片的时候会显示这个图片所在的位置。</p>
<ol>
<li>运行程序，效果图如下：<br><img src="http://dl.iteye.com/upload/attachment/401529/01f43426-e794-3215-84c1-9273836917cc.jpg" alt=""></li>
</ol>
<p>本文附件下载:</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>GridView是一个网络布局的视图，他能让你的元素显示在一个个的格子里。我们的桌面就是一个GridView。。</p>
<ol>
<li>新建一个HelloGridView的工程</li>
</ol>
<ol>
<li>修改main.xml代码如下：</li>
</ol>]]>
    </summary>
    
      <category term="Android" scheme="http://www.flysnow.org/tags/Android/"/>
    
      <category term="Widget" scheme="http://www.flysnow.org/tags/Widget/"/>
    
      <category term="Android" scheme="http://www.flysnow.org/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android 源码目录结构详解]]></title>
    <link href="http://www.flysnow.org/2011/01/10/android-sources-directory-structure.html"/>
    <id>http://www.flysnow.org/2011/01/10/android-sources-directory-structure.html</id>
    <published>2011-01-10T01:11:57.000Z</published>
    <updated>2016-05-22T10:14:57.290Z</updated>
    <content type="html"><![CDATA[<p>这是Android2.1的源代码的目录结构，可以帮助我们研究Android的源代码。Android源代码的下载请参考官网</p>
<p>Android 2.1<br>|— Makefile<br>|— bionic                        （bionic C库）</p>
<p>|— bootable                （启动引导相关代码）<br>|— build<br>（存放系统编译规则及generic等基础开发包配置）<br>|— cts                        （Android兼容性测试套件标准）</p>
<table>
<thead>
<tr>
<th>— dalvik                        （dalvik JAVA虚拟机）</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>development        （应用程序开发相关）<br>|— external<br>（android使用的一些开源的模组）<br>|— frameworks                （核心框架——java及C++语言）<br>|—<br>hardware                （部分厂家开源的硬解适配层HAL代码）<br>|— out<br>（编译完成后的代码输出与此目录）<br>|— packages                （应用程序包）<br>|—<br>prebuilt                （x86和arm架构下预编译的一些资源）<br>|— sdk<br>（sdk及模拟器）<br>|— system                        （底层文件系统库、应用及组件——C语言）<br>`—<br>vendor                （厂商定制代码）</p>
<p>bionic 目录<br>|—<br>libc                        （C库）<br>|   |— arch-arm        （ARM架构，包含系统调用汇编实现）</p>
<p>|   |— arch-x86        （x86架构，包含系统调用汇编实现）<br>|   |— bionic<br>（由C实现的功能，架构无关）<br>|   |— docs                （文档）<br>|   |—<br>include                （头文件）<br>|   |— inet                （？inet相关，具体作用不明）</p>
<p>|   |— kernel                （Linux内核中的一些头文件）<br>|   |—<br>netbsd                （？nesbsd系统相关，具体作用不明）<br>|   |— private<br>（？一些私有的头文件）<br>|   |— stdio                （stdio实现）<br>|   |—<br>stdlib                （stdlib实现）<br>|   |— string                （string函数实现）</p>
<p>|   |— tools                （几个工具）<br>|   |— tzcode<br>（时区相关代码）<br>|   |— unistd                （unistd实现）<br>|   `—<br>zoneinfo        （时区信息）<br>|— libdl<br>（libdl实现，dl是动态链接，提供访问动态链接库的功能）<br>|— libm                        （libm数学库的实现，）</p>
<p>|   |— alpha                （apaha架构）<br>|   |— amd64<br>（amd64架构）<br>|   |— arm                （arm架构）<br>|   |—<br>bsdsrc                （？bsd的源码）<br>|   |— i386                （i386架构）<br>|<br>|— i387                （i387架构？）<br>|   |— ia64                （ia64架构）</p>
<p>|   |— include                （头文件）<br>|   |— man<br>（数学函数，后缀名为.3，一些为freeBSD的库文件）<br>|   |— powerpc        （powerpc架构）<br>|   |—<br>sparc64                （sparc64架构）<br>|   <code>-- src                （源代码）
|--
libstdc++                （libstdc++ C++实现库）
|   |-- include
（头文件）
|</code>— src                （源码）<br>|— libthread_db<br>（多线程程序的调试器库）<br>|   <code>-- include                （头文件）</code>—<br>linker                        （动态链接器）<br>`— arch<br>（支持arm和x86两种架构）</p>
<p>bootable 目录<br>.<br>|—<br>bootloader                                （适合各种bootloader的通用代码）<br>|   <code>--
legacy                                （估计不能直接使用，可以参考）
|       |--
arch_armv6                （V6架构，几个简单的汇编文件）
|       |--
arch_msm7k                （高通7k处理器架构的几个基本驱动）
|       |--
include                        （通用头文件和高通7k架构头文件）
|       |--
libboot                        （启动库，都写得很简单）
|       |--
libc                        （一些常用的c函数）
|       |-- nandwrite
（nandwirte函数实现）
|</code>— usbloader                （usbloader实现）<br>|—<br>diskinstaller                        （android镜像打包器，x86可生产iso）<br><code>--
recovery                                （系统恢复相关）
|--
edify                                （升级脚本使用的edify脚本语言）
|--
etc                                （init.rc恢复脚本）
|--
minui                                （一个简单的UI）
|--
minzip                                （一个简单的压缩工具）
|--
mtdutils                        （mtd工具）
|--
res                                （资源）
|</code>—<br>images                        （一些图片）<br>|—<br>tools                                （工具）<br>|   <code>--
ota                        （OTA Over The Air Updates升级工具）</code>—<br>updater                        （升级器）</p>
<p>build目录<br>.<br>|—<br>core                                （核心编译规则）<br>|—<br>history                                （历史记录）<br>|—<br>libs<br>|   `— host<br>（主机端库，有android “cp”功能替换）<br>|— target                                （目标机编译对象）</p>
<p>|   |— board                        （开发平台）<br>|   |   |— emulator<br>（模拟器）<br>|   |   |— generic                （通用）<br>|   |   |—<br>idea6410        （自己添加的）<br>|   |   <code>-- sim                （最简单）
|</code>—<br>product                （开发平台对应的编译规则）<br>|       `— security        （密钥相关）</p>
<p>`— tools                                （编译中主机使用的工具及脚本）<br>|—<br>acp                        （Android “acp” Command）<br>|—<br>apicheck                （api检查工具）<br>|— applypatch                （补丁工具）</p>
<table>
<thead>
<tr>
<th>— apriori                        （预链接工具）</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>atree                        （tree工具）<br>|— bin2asm<br>（bin转换为asm工具）<br>|— check_prereq        （检查编译时间戳工具）<br>|—<br>dexpreopt                （模拟器相关工具，具体功能不明）<br>|— droiddoc<br>（？作用不明，java语言，网上有人说和JDK5有关）<br>|— fs_config                （This program<br>takes a list of files and directories）<br>|— fs_get_stats<br>（获取文件系统状态）<br>|— iself                        （判断是否ELF格式）<br>|—<br>isprelinked                （判断是否prelinked）<br>|—<br>kcm                        （按键相关）<br>|— lsd                        （List<br>symbol dependencies）<br>|— releasetools                （生成镜像的工具及脚本）</p>
<table>
<thead>
<tr>
<th>— rgb2565                （rgb转换为565）</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>signapk                （apk签名工具）<br>|— soslim<br>（strip工具）<br>`— zipalign                （zip archive alignment tool）</p>
<p>dalvik目录 dalvik虚拟机<br>.<br>|— dalvikvm<br>（main.c的目录）<br>|— dexdump                        （dex反汇编）<br>|—<br>dexlist                                （List all methods in all concrete classes<br>in a DEX file.）<br>|— dexopt                                （预验证与优化）<br>|—<br>docs                                （文档）<br>|—<br>dvz                                （和zygote相关的一个命令）<br>|—<br>dx                                （dx工具，将多个java转换为dex）<br>|—<br>hit                                （？java语言写成）<br>|—<br>libcore                                （核心库）<br>|—<br>libcore-disabled                （？禁用的库）<br>|—<br>libdex                                （dex的库）<br>|—<br>libnativehelper                （Support functions for Android’s class libraries）</p>
<table>
<thead>
<tr>
<th>— tests                                （测试代码）</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>tools                                （工具）<br>`—<br>vm                                （虚拟机实现）</p>
<p>development 目录<br>（开发者需要的一些例程及工具）<br>|— apps                                （一些核心应用程序）<br>|<br>|— BluetoothDebug        （蓝牙调试程序）<br>|   |— CustomLocale        （自定义区域设置）</p>
<p>|   |— Development        （开发）<br>|   |— Fallback<br>（和语言相关的一个程序）<br>|   |— FontLab                （字库）<br>|   |—<br>GestureBuilder        （手势动作）<br>|   |— NinePatchLab        （？）<br>|   |—<br>OBJViewer                （OBJ查看器）<br>|   |— SdkSetup                （SDK安装器）</p>
<p>|   |— SpareParts                （高级设置）<br>|   |—<br>Term                        （远程登录）<br>|   `— launchperf                （？）</p>
<table>
<thead>
<tr>
<th>— build                                （编译脚本模板）</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>cmds                                （有个monkey工具）<br>|—<br>data                                （配置数据）<br>|—<br>docs                                （文档）<br>|—<br>host                                （主机端USB驱动等）<br>|—<br>ide                                （集成开发环境）<br>|—<br>ndk                                （本地开发套件——c语言开发套件）<br>|—<br>pdk                                （Plug Development Kit）<br>|—<br>samples                        （例程）<br>|   |— AliasActivity        （？）<br>|<br>|— ApiDemos                （API演示程序）<br>|   |— BluetoothChat        （蓝牙聊天）</p>
<p>|   |— BrowserPlugin        （浏览器插件）<br>|   |— BusinessCard        （商业卡）</p>
<p>|   |— Compass                （指南针）<br>|   |— ContactManager<br>（联系人管理器）<br>|   |— CubeLiveWallpaper        （动态壁纸的一个简单例程）<br>|   |—<br>FixedGridLayout        （像是布局）<br>|   |— GlobalTime                （全球时间）</p>
<p>|   |— HelloActivity        （Hello）<br>|   |— Home<br>（Home）<br>|   |— JetBoy                        （jetBoy游戏）<br>|   |—<br>LunarLander        （貌似又是一个游戏）<br>|   |— MailSync                （邮件同步）<br>|<br>|— MultiResolution        （多分辨率）<br>|   |— MySampleRss        （RSS）<br>|<br>|— NotePad                （记事本）<br>|   |— RSSReader                （RSS阅读器）</p>
<p>|   |— SearchableDictionary        （目录搜索）<br>|   |—<br>SimpleJNI                （JNI例程）<br>|   |— SkeletonApp        （空壳APP）<br>|<br>|— Snake                        （snake程序）<br>|   |— SoftKeyboard        （软键盘）</p>
<p>|   |— Wiktionary                （？维基）<br>|   `— WiktionarySimple（？维基例程）</p>
<table>
<thead>
<tr>
<th>— scripts                                （脚本）</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>sdk                                （sdk配置）<br>|—<br>simulator                        （？模拟器）<br>|—<br>testrunner                        （？测试用）<br>`—<br>tools                                （一些工具）</p>
<p>external 目录<br>.<br>|—<br>aes                        （AES加密）<br>|— apache-http                （网页服务器）</p>
<p>|— astl                        （ASTL (Android STL) is a slimmed-down<br>version of the regular C++ STL.）<br>|— bison<br>（自动生成语法分析器，将无关文法转换成C、C++）<br>|— blktrace                （blktrace is a block<br>layer IO tracing mechanism）<br>|— bluetooth                （蓝牙相关、协议栈）<br>|—<br>bsdiff                        （diff工具）<br>|— bzip2<br>（压缩工具）<br>|— clearsilver                （html模板系统）<br>|—<br>dbus                        （低延时、低开销、高可用性的IPC机制）<br>|— dhcpcd<br>（DHCP服务）<br>|— dosfstools                （DOS文件系统工具）<br>|—<br>dropbear                （SSH2的server）<br>|— e2fsprogs<br>（EXT2文件系统工具）<br>|— elfcopy                （复制ELF的工具）<br>|—<br>elfutils                        （ELF工具）<br>|— embunit                （Embedded<br>Unit Project）<br>|— emma                        （java代码覆盖率统计工具）<br>|—<br>esd                        （Enlightened Sound Daemon，将多种音频流混合在一个设备上播放）<br>|—<br>expat                        （Expat is a stream-oriented XML parser.）<br>|—<br>fdlibm                        （FDLIBM (Freely Distributable LIBM)）<br>|—<br>freetype                （字体）<br>|— fsck_msdos                （dos文件系统检查工具）</p>
<table>
<thead>
<tr>
<th>— gdata                        （google的无线数据相关）</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>genext2fs                （genext2fs generates an ext2 filesystem as a normal<br>(non-root) user）<br>|— giflib                        （gif库）<br>|—<br>googleclient        （google用户库）<br>|— grub                        （This is GNU<br>GRUB, the GRand Unified Bootloader.）<br>|— gtest<br>（Google C++ Testing Framework）<br>|— icu4c<br>（ICU(International Component for Unicode)在C/C++下的版本）<br>|—<br>ipsec-tools                （This package provides a way to use the native IPsec<br>functionality ）<br>|— iptables                （防火墙）<br>|—<br>jdiff                        （generate a report describing the difference<br>between two public Java APIs.）<br>|— jhead                        （jpeg头部信息工具）</p>
<p>|— jpeg                        （jpeg库）<br>|— junit<br>（JUnit是一个Java语言的单元测试框架）<br>|— kernel-headers        （内核的一些头文件）<br>|—<br>libffi                        （libffi is a foreign function interface library.）</p>
<p>|— libpcap                （网络数据包捕获函数）<br>|— libpng<br>（png库）<br>|— libxml2                （xml解析库）<br>|—<br>mtpd                        （一个命令）<br>|— netcat                        （simple<br>Unix utility which reads and writes dataacross network connections）<br>|—<br>netperf                        （网络性能测量工具）<br>|— neven<br>（看代码和JNI相关）<br>|— opencore                （多媒体框架）<br>|—<br>openssl                （SSL加密相关）<br>|— openvpn                （VPN开源库）<br>|—<br>oprofile                （OProfile是Linux内核支持的一种性能分析机制。）<br>|—<br>ping                        （ping命令）<br>|— ppp<br>（pppd拨号命令，好像还没有chat）<br>|— proguard                （Java class file shrinker,<br>optimizer, obfuscator, and preverifier）<br>|— protobuf                （a<br>flexible, efficient, automated mechanism for serializing structured data）</p>
<p>|— qemu                        （arm模拟器）<br>|— safe-iop<br>（functions for performing safe integer operations ）<br>|—<br>skia                        （skia图形引擎）<br>|— sonivox                （sole MIDI<br>solution for Google Android Mobile Phone Platform）<br>|—<br>speex                        （Speex编/解码API的使用(libspeex)）<br>|—<br>sqlite                        （数据库）<br>|— srec                        （Nuance<br>公司提供的开源连续非特定人语音识别）<br>|— strace                        （trace工具）<br>|—<br>svox                        （Embedded Text-to-Speech）<br>|—<br>tagsoup                （TagSoup是一个Java开发符合SAX的HTML解析器）<br>|—<br>tcpdump                （抓TCP包的软件）<br>|— tesseract                （Tesseract<br>Open Source OCR Engine.）<br>|— tinyxml                （TinyXml is a simple,<br>small, C++ XML parser）<br>|— tremor                        （I stream and file<br>decoder provides an embeddable,integer-only library）<br>|—<br>webkit                        （浏览器核心）<br>|— wpa_supplicant        （无线网卡管理）</p>
<table>
<thead>
<tr>
<th>— xmlwriter                （XML 编辑工具）</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>yaffs2                        （yaffs文件系统）<br>`— zlib                        （a<br>general purpose data compression library）</p>
<p>frameworks 目录<br>（核心框架——java及C++语言）<br>.<br>|— base                        （基本内容）<br>|   |—<br>api                  （？都是xml文件，定义了java的api？）<br>|   |— awt<br>（AWT库）<br>|   |— build                （空的）<br>|   |— camera<br>（摄像头服务程序库）<br>|   |— cmds              （重要命令：am、app_proce等）<br>|   |—<br>core                （核心库）<br>|   |— data                （字体和声音等数据文件）<br>|<br>|— docs                （文档）<br>|   |— graphics           （图形相关）<br>|   |—<br>include             （头文件）<br>|   |— keystore        （和数据签名证书相关）<br>|   |—<br>libs                （库）<br>|   |— location        （地区库）<br>|   |—<br>media                （媒体相关库）<br>|   |— obex                （蓝牙传输库）<br>|   |—<br>opengl                （2D-3D加速库）<br>|   |— packages        （设置、TTS、VPN程序）</p>
<p>|   |— sax                （XML解析器）<br>|   |— services        （各种服务程序）</p>
<p>|   |— telephony        （电话通讯管理）<br>|   |— test-runner        （测试工具相关）</p>
<p>|   |— tests                （各种测试）<br>|   |— tools<br>（一些叫不上名的工具）<br>|   |— vpn                （VPN）<br>|   <code>-- wifi
（无线网络）
|-- opt                        （可选部分）
|   |--
com.google.android                                （有个framework.jar）
|   |--
com.google.android.googlelogin                （有个client.jar）
|</code>—<br>emoji                （standard message elements）<br>`— policies<br>（Product policies are operating system directions aimed at specific uses）</p>
<p>`— base<br>|— mid        （MID设备）</p>
<p>`— phone   （手机类设备一般用这个，与锁屏有关的代码）</p>
<p>hardware 目录<br>（部分厂家开源的硬解适配层HAL代码）<br>|— broadcom                        （博通公司）<br>|   <code>--
wlan                        （无线网卡）
|-- libhardware
（硬件库）
|   |-- include                        （头文件）
|</code>—<br>modules                （Default (and possibly architecture dependents) HAL<br>modules）<br>|       |— gralloc                （gralloc显示相关）<br>|       `—<br>overlay                （Skeleton for the “overlay” HAL module.）<br>|—<br>libhardware_legacy        （旧的硬件库）<br>|   |— flashlight                （背光）</p>
<p>|   |— gps                        （GPS）<br>|   |—<br>include                        （头文件）<br>|   |— mount<br>（旧的挂载器）<br>|   |— power                        （电源）<br>|   |—<br>qemu                        （模拟器）<br>|   |— qemu_tracing        （模拟器跟踪）</p>
<p>|   |— tests                        （测试）<br>|   |—<br>uevent                        （uevent）<br>|   |—<br>vibrator                        （震动）<br>|   `— wifi<br>（无线）<br>|— msm7k                        （高通7k处理器开源抽象层）<br>|   |—<br>boot                        （启动）<br>|   |— libaudio                （声音库）</p>
<p>|   |— libaudio-qsd8k        （qsd8k的声音相关库）<br>|   |—<br>libcamera                （摄像头库）<br>|   |— libcopybit                （copybit库）</p>
<p>|   |— libgralloc                （gralloc库）<br>|   |—<br>libgralloc-qsd8k        （qsd8k的gralloc库）<br>|   |— liblights<br>（背光库）<br>|   <code>-- librpc                        （RPC库）
|--
ril                                （无线电抽象层）
|   |--
include                        （头文件）
|   |-- libril
（库）
|   |-- reference-cdma-sms        （cdma短信参考）
|   |--
reference-ril                        （ril参考）
|</code>—<br>rild                                （ril后台服务程序）<br><code>--
ti                                                （ti公司开源HAL）
|--
omap3                                （omap3处理器）
|   |--
dspbridge                （DSP桥）
|   |-- libopencorehw
（opencore硬件库）
|   |-- liboverlay                （overlay硬件库）
|
|-- libstagefrighthw        （stagefright硬件库）
|</code>—<br>omx                        （omx组件）<br>`—<br>wlan                                （无线网卡）</p>
<p>packages 目录<br>.<br>|—<br>apps                            （应用程序库）<br>|   |— AlarmClock              （闹钟）</p>
<p>|   |— Bluetooth                （蓝牙）<br>|   |— Browser<br>（浏览器）<br>|   |— Calculator                （计算器）<br>|   |—<br>Calendar                  （日历）<br>|   |— Camera                   （相机）<br>|<br>|— CertInstaller             （在Android中安装数字签名，被调用）<br>|   |—<br>Contacts                 （拨号(调用)、联系人、通话记录）<br>|   |— DeskClock<br>（桌面时钟）<br>|   |— Email                       （Email）<br>|   |—<br>Gallery                     （相册，和Camera类似，多了列表）<br>|   |—<br>Gallery3D                 （？3D相册）<br>|   |— GlobalSearch<br>（为google搜索服务，提供底层应用）<br>|   |— GoogleSearch           （google搜索）<br>|   |—<br>HTMLViewer             （浏览器附属界面，被浏览器应用调用，同时提供存储记录功能）<br>|   |—<br>IM                            （即时通讯，为手机提供信号发送、接收、通信的服务）<br>|   |—<br>Launcher                  （登陆启动项，显示图片框架等等图形界面）<br>|   |—<br>Launcher2                （登陆启动项，负责应用的调用）<br>|   |— Mms<br>（？彩信业务）<br>|   |— Music                        （音乐播放器）<br>|   |—<br>PackageInstaller        （安装、卸载程序的响应）<br>|   |— Phone<br>（电话拨号程序）<br>|   |— Provision                （预设应用的状态，使能应用）<br>|   |—<br>Settings                （开机设定，包括电量、蓝牙、设备信息、界面、wifi等）<br>|   |—<br>SoundRecorder        （录音机，可计算存储所需空间和时间）<br>|   |— Stk<br>（接收和发送短信）<br>|   |— Sync                        （空）   ———-○1<br>|   |—<br>Updater                （空）<br>|   `— VoiceDialer                （语音识别通话）</p>
<p>|— inputmethods                （输入法）<br>|   |— LatinIME<br>（拉丁文输入法）<br>|   |— OpenWnn                （OpenWnn输入法）<br>|   <code>--
PinyinIME                （拼音输入法）
|-- providers
（提供器，提供应用程序、界面所需的数据）
|   |-- ApplicationsProvider
（应用程序提供器，提供应用程序启动项、更新等）
|   |-- CalendarProvider
（日历提供器）
|   |-- ContactsProvider                        （联系人提供器）
|   |--
DownloadProvider                （下载管理提供器）
|   |--
DrmProvider                        （创建和更新数据库时调用）
|   |--
GoogleContactsProvider        （联系人提供器的子类，用以同步联系人）
|   |--
GoogleSubscribedFeedsProvider（设置信息提供器）
|   |--
ImProvider                                （空）
|   |--
ManagementProvider                （空）
|   |--
MediaProvider                        （媒体提供器，提供存储数据）
|   |--
TelephonyProvider                （彩信提供器）
|   |--
UserDictionaryProvider        （用户字典提供器，提供用户常用字字典）
|</code>—<br>WebSearchProvider                （空）<br>|—<br>services<br>|   |—<br>EasService                                （空）<br>|   <code>--
LockAndWipe                        （空）</code>—<br>wallpapers                                        （墙纸）<br>|—<br>Basic                                        （基本墙纸，系统内置墙纸）<br>|—<br>LivePicker                                （选择动态壁纸）<br>|—<br>MagicSmoke                        （壁纸特殊效果）<br>`—<br>MusicVisualization                （音乐可视化，图形随音乐而变化）</p>
<p>○1里面有一个隐藏的.git文件夹，内容都是一样的，没有有意义的代码，config看似乎是一个下载程序，因此认为这些文件夹下没有实质东西。</p>
<p>prebuilt 目录                        （x86和arm架构下预编译的一些资源）<br>.<br>|—<br>android-arm                （arm-android相关）<br>|   |— gdbserver<br>（gdb调试器）<br>|   <code>-- kernel                        （模拟的arm内核）
|--
android-x86                （x86-android相关）
|</code>—<br>kernel                        （空的）<br>|— common<br>（通用编译好的代码，应该是java的）<br>|— darwin-x86                        （drawin x86平台）</p>
<p>|   `— toolchain                （工具链）<br>|       |— arm-eabi-4.2.1</p>
<p>|       |— arm-eabi-4.3.1<br>|       `— arm-eabi-4.4.0</p>
<table>
<thead>
<tr>
<th>— darwin-x86_64                （drawin x86 64bit平台）</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>linux-x86                        （linux x86平台）<br>|   `—<br>toolchain                （工具链，我们应该主要用这个）<br>|       |— arm-eabi-4.2.1</p>
<p>|       |— arm-eabi-4.3.1<br>|       |— arm-eabi-4.4.0</p>
<table>
<thead>
<tr>
<th>`— i686-unknown-linux-gnu-4.2.1        （x86版编译器）</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>linux-x86_64                （linux x86 64bit平台）<br>|—<br>windows                        （windows平台）<br>`— windows-x86_64        （64bit<br>windows平台）<br>system 目录                （底层文件系统库、应用及组件——C语言）<br>.<br>|—<br>Bluetooth                （蓝牙相关）<br>|— core                        （系统核心工具盒接口）</p>
<p>|   |— adb                （adb调试工具）<br>|   |— cpio<br>（cpio工具，创建img）<br>|   |— debuggerd        （调试工具）<br>|   |— fastboot<br>（快速启动相关）<br>|   |— include                （系统接口头文件）<br>|   |—<br>init                （init程序源代码）<br>|   |— libacc                （轻量级C编译器）</p>
<p>|   |— libctest                （libc测试相关）<br>|   |— libcutils<br>（libc工具）<br>|   |— liblog                （log库）<br>|   |— libmincrypt<br>（加密库）<br>|   |— libnetutils        （网络工具库）<br>|   |— libpixelflinger<br>（图形处理库）<br>|   |— libsysutils        （系统工具库）<br>|   |— libzipfile<br>（zip库）<br>|   |— logcat                （查看log工具）<br>|   |— logwrapper<br>（log封装工具）<br>|   |— mkbootimg        （制作启动boot.img的工具盒脚本）<br>|   |—<br>netcfg                （网络配置netcfg源码）<br>|   |— nexus<br>（google最新手机的代码）<br>|   |— rootdir                （rootfs，包含一些etc下的脚本和配置）</p>
<p>|   |— sh                        （shell代码）<br>|   |—<br>toolbox                （toolbox，类似busybox的工具集）<br>|   `— vold<br>（SD卡管理器）<br>|— extras                        （额外工具）<br>|   |—<br>latencytop        （a tool for software developers ，identifying system latency<br>happen）<br>|   |— libpagemap        （pagemap库）<br>|   |—<br>librank                （Java Library Ranking System库）<br>|   |— procmem<br>（pagemap相关）<br>|   |— procrank        （Java Library Ranking System相关）<br>|<br>|— showmap        （showmap工具）<br>|   |— showslab        （showslab工具）<br>|<br>|— sound                （声音相关）<br>|   |— su                        （su命令源码）</p>
<p>|   |— tests                （一些测试工具）<br>|   `— timeinfo        （时区相关）</p>
<p><code>-- wlan                        （无线相关）</code>— ti<br>（ti网卡相关工具及库）</p>
<p>vendor 目录                        （厂家定制内容）</p>
<p>|—<br>aosp                             （android open source project）<br>|   <code>--
products                  （一些板级规则）
|-- htc
（HTC公司）
|   |-- common-open         （通用部分）
|   |</code>—<br>akmd                 （解压img用的工具）<br>|   |— dream-open            （G1开放部分）</p>
<p>|   |— prebuilt-open           （预编译开放部分）<br>|   <code>-- sapphire-open
（sapphire这款型号开放内容）
|-- pv-open                       （没东西）
|--
qcom                           （里面基本是空的）</code>— sample<br>（google提供的样例）<br>|— apps                        （应用）<br>|   |—<br>client                   （用户）<br>|   `— upgrade              （升级）</p>
<p>|— frameworks             （框架）<br>|   `— PlatformLibrary   （平台库）</p>
<p>|— products                  （产品）<br>|— sdk_addon              （sdk添加部分）</p>
<p>`— skins                       （皮肤）</p>
<p>`— WVGAMedDpi      （WVGA适用的图片）</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这是Android2.1的源代码的目录结构，可以帮助我们研究Android的源代码。Android源代码的下载请参考官网</p>
<p>Android 2.1<br>|— Makefile<br>|— bionic                        （bioni]]>
    </summary>
    
      <category term="Android" scheme="http://www.flysnow.org/tags/Android/"/>
    
      <category term="Linux" scheme="http://www.flysnow.org/tags/Linux/"/>
    
      <category term="Android" scheme="http://www.flysnow.org/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android ListView组件的使用]]></title>
    <link href="http://www.flysnow.org/2011/01/08/android-listview-tutorials.html"/>
    <id>http://www.flysnow.org/2011/01/08/android-listview-tutorials.html</id>
    <published>2011-01-08T00:59:56.000Z</published>
    <updated>2016-05-22T10:14:57.290Z</updated>
    <content type="html"><![CDATA[<p>ListView是Android开发中非常常用的组件，ListView可以用来显示一个列表，我们可以对这个列表操作，比如点击列表要做什么等等。这篇文章主要通过一个示例来展示ListView的用法。</p>
<p>请加入，大家一块学习。</p>
<h2 id="一、不使用xml布局文件创建一个ListView">一、不使用xml布局文件创建一个ListView</h2><ol>
<li>创建一个名称为HelloListView的Android工程，可以参见<br><a href="/admin/blog/810785">Android 第一个Android应用，HelloWorld</a></li>
</ol>
<ol>
<li>要使用ListView，需要让你的Activity继承于ListActivity，这个和以前的有区别，以前的都是继承Activity，该ListActivity继承Activity，扩展了很多常用的用于操作ListView的方法，使用很方便。</li>
</ol>
<ol>
<li>现修改HelloListView类如下</li>
</ol>
<pre><code>public <span class="class"><span class="keyword">class</span> <span class="title">HelloListView</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">ListActivity</span> {</span>
    <span class="comment">/** Called when the activity is first created. */</span>
    <span class="annotation">@Override</span>
    public void onCreate(<span class="type">Bundle</span> savedInstanceState) {
        <span class="keyword">super</span>.onCreate(savedInstanceState);
        <span class="comment">//setContentView(R.layout.main);</span>
        <span class="comment">//设置一个Adapter</span>
        setListAdapter(<span class="keyword">new</span> <span class="type">ArrayAdapter</span>(<span class="keyword">this</span>,android.<span class="type">R</span>.layout.simple_list_item_1,<span class="type">COUNTRIES</span>));
    }
    <span class="comment">//数据数据</span>
    <span class="keyword">private</span>  static <span class="keyword">final</span> <span class="type">String</span>[] <span class="type">COUNTRIES</span>=<span class="keyword">new</span> <span class="type">String</span>[]{<span class="string">"中国"</span>,<span class="string">"俄罗斯"</span>,<span class="string">"英国"</span>,<span class="string">"法国"</span>};
}
</code></pre><ol>
<li>运行程序效果如下：<img src="http://dl.iteye.com/upload/attachment/385759/1864e29c-2014-3275-80d2-760c9de2fa23.jpg" alt=""><br>看到了吧，我们的数据已经通过列表的形式显示了出来！！！</li>
</ol>
<p>这里主要的是使用了一个Adapter—适配器，你可以把他看成是ListView的数据源，ListView要展示的数据都是已Adapter的形势传递给ListView的。这个Adapter很重要，Android的用于传给集合控件（ListView,Spinner,GridView等）的数据都是以Adapter的形势，这样的好处就是只要掌握了Adapter，就可以很随意的给这些集合控制传递数据，因为他们使用的都是Adapter。适配器适配器关键就是适配，只需公布一个Adapter，就全搞定了。Android已经给我们实现了一些常用的适配器，如刚刚使用的数组器，还有简单适配器等,如果这些不能满足，我们还可以通过自定义适配器来实现自己的适配器。其实一种适配器就对应了一个集合控件中的一个元素的布局展示。</p>
<h2 id="二:使用xml来自定义ListView">二:使用xml来自定义ListView</h2><ol>
<li>上个例子我们并没有使用在main.xml中定义一个ListView的形势来布局ListView，而是使用的ListActivity中默认的ListView来演示的。</li>
</ol>
<ol>
<li>下面就使用我们在main.xml中自定义的ListView,这样我们可以很方便的控制ListView展示的布局，大小，背景色等属性。当然上个例子中我们一样可以通过getListView获取ListView后使用它的方法来改变布局、大小和背景色等。</li>
</ol>
<ol>
<li>修改main.xml为：</li>
</ol>
<pre><code><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span>
<span class="tag">&lt;<span class="title">ListView</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span>
    <span class="attribute">android:id</span>=<span class="value">"@android:id/list"</span>
    <span class="attribute">android:layout_width</span>=<span class="value">"fill_parent"</span>
    <span class="attribute">android:layout_height</span>=<span class="value">"fill_parent"</span>
    <span class="attribute">android:background</span>=<span class="value">"#FF0000FF"</span>
    &gt;</span>
<span class="tag">&lt;/<span class="title">ListView</span>&gt;</span>
</code></pre><p>这里要注意的是我们设置ListView的id为”@android:id/list”,意思是我们引用Android已经为我们定义好的一个id，名字是list，如果你不定义成这样，这个ListView是不能被ListActivity识别的。然后就是添加了一个蓝色的背景，看看我们这个自定义的ListView是否起了作用。</p>
<ol>
<li>修改HelloListView类为：</li>
</ol>
<pre><code>public <span class="class"><span class="keyword">class</span> <span class="title">HelloListView</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">ListActivity</span> {</span>
    <span class="comment">/** Called when the activity is first created. */</span>
    <span class="annotation">@Override</span>
    public void onCreate(<span class="type">Bundle</span> savedInstanceState) {
        <span class="keyword">super</span>.onCreate(savedInstanceState);
        setContentView(<span class="type">R</span>.layout.main);
        <span class="comment">//设置一个Adapter</span>
        setListAdapter(<span class="keyword">new</span> <span class="type">ArrayAdapter</span>(<span class="keyword">this</span>,android.<span class="type">R</span>.layout.simple_list_item_1,<span class="type">COUNTRIES</span>));
    }
    <span class="comment">//数据数据</span>
    <span class="keyword">private</span>  static <span class="keyword">final</span> <span class="type">String</span>[] <span class="type">COUNTRIES</span>=<span class="keyword">new</span> <span class="type">String</span>[]{<span class="string">"中国"</span>,<span class="string">"俄罗斯"</span>,<span class="string">"英国"</span>,<span class="string">"法国"</span>};
}
</code></pre><p>比上个例子只是多了setContentView(R.layout.main);是为了让Android识别我们定义的ListView。</p>
<ol>
<li>运行效果图：<img src="http://dl.iteye.com/upload/attachment/385771/602d0716-3fea-315b-a846-a61c9a78c793.jpg" alt=""><br>背景已经变成了蓝色，说明我们在xml中定义的ListView起作用了。</li>
</ol>
<h2 id="三：自定义要展示的元素">三：自定义要展示的元素</h2><ol>
<li>前面的两个例子都是展示一行文字，如果我们想图文混排怎么做呢，比如前面是文字，后面是图片。要实现这种功能就需要我们自定义Adapter啦。</li>
</ol>
<ol>
<li>新建布局文件item.xml,内容如下：</li>
</ol>
<pre><code>&lt;?xml <span class="variable">version=</span><span class="string">"1.0"</span> <span class="variable">encoding=</span><span class="string">"utf-8"</span>?&gt;
&lt;RelativeLayout
  xmlns:<span class="variable">android=</span><span class="string">"http://schemas.android.com/apk/res/android"</span>
  android:<span class="variable">layout_width=</span><span class="string">"fill_parent"</span>
  android:<span class="variable">layout_height=</span><span class="string">"wrap_content"</span>&gt;
  &lt;TextView    
      android:<span class="variable">id=</span><span class="string">"@+id/text"</span>
      android:<span class="variable">layout_alignParentLeft=</span><span class="string">"true"</span>
      android:<span class="variable">layout_width=</span><span class="string">"wrap_content"</span>
      android:<span class="variable">layout_height=</span><span class="string">"wrap_content"</span>/&gt;
  &lt;ImageView 
      android:<span class="variable">id=</span><span class="string">"@+id/image"</span>
      android:<span class="variable">layout_alignParentRight=</span><span class="string">"true"</span>
      android:<span class="variable">layout_width=</span><span class="string">"wrap_content"</span>
      android:<span class="variable">layout_height=</span><span class="string">"wrap_content"</span>/&gt;
&lt;/RelativeLayout&gt;
</code></pre><p>这里主要定义一个TextView和一个ImageView，用于显示列表每一行的文本和图片</p>
<ol>
<li>修改HelloListView类如下：</li>
</ol>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloListView</span> <span class="keyword">extends</span> <span class="title">ListActivity</span> </span>{
    <span class="javadoc">/** Called when the activity is first created. */</span>
    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>{
        <span class="keyword">super</span>.onCreate(savedInstanceState);
        setContentView(R.layout.main);
        <span class="comment">//设置一个Adapter,使用自定义的Adapter</span>
        setListAdapter(<span class="keyword">new</span> TextImageAdapter(<span class="keyword">this</span>));
    }
    <span class="javadoc">/**
     * 自定义视图
     *<span class="javadoctag"> @author</span> 飞雪无情
     *
     */</span>
    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">TextImageAdapter</span> <span class="keyword">extends</span> <span class="title">BaseAdapter</span></span>{
        <span class="keyword">private</span> Context mContext;
        <span class="function"><span class="keyword">public</span> <span class="title">TextImageAdapter</span><span class="params">(Context context)</span> </span>{
            <span class="keyword">this</span>.mContext=context;
        }
        <span class="javadoc">/**
         * 元素的个数
         */</span>
        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>{
            <span class="keyword">return</span> texts.length;
        }

        <span class="function"><span class="keyword">public</span> Object <span class="title">getItem</span><span class="params">(<span class="keyword">int</span> position)</span> </span>{
            <span class="keyword">return</span> <span class="keyword">null</span>;
        }

        <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getItemId</span><span class="params">(<span class="keyword">int</span> position)</span> </span>{
            <span class="keyword">return</span> <span class="number">0</span>;
        }
        <span class="comment">//用以生成在ListView中展示的一个个元素View</span>
        <span class="function"><span class="keyword">public</span> View <span class="title">getView</span><span class="params">(<span class="keyword">int</span> position, View convertView, ViewGroup parent)</span> </span>{
            <span class="comment">//优化ListView</span>
            <span class="keyword">if</span>(convertView==<span class="keyword">null</span>){
                convertView=LayoutInflater.from(mContext).inflate(R.layout.item, <span class="keyword">null</span>);
                ItemViewCache viewCache=<span class="keyword">new</span> ItemViewCache();
                viewCache.mTextView=(TextView)convertView.findViewById(R.id.text);
                viewCache.mImageView=(ImageView)convertView.findViewById(R.id.image);
                convertView.setTag(viewCache);
            }
            ItemViewCache cache=(ItemViewCache)convertView.getTag();
            <span class="comment">//设置文本和图片，然后返回这个View，用于ListView的Item的展示</span>
            cache.mTextView.setText(texts[position]);
            cache.mImageView.setImageResource(images[position]);
            <span class="keyword">return</span> convertView;
        }
    }
    <span class="comment">//元素的缓冲类,用于优化ListView</span>
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ItemViewCache</span></span>{
        <span class="keyword">public</span> TextView mTextView;
        <span class="keyword">public</span> ImageView mImageView;
    }
  <span class="comment">//展示的文字</span>
    <span class="keyword">private</span>  String[] texts=<span class="keyword">new</span> String[]{<span class="string">"天气"</span>,<span class="string">"我团"</span>,<span class="string">"背景"</span>};
    <span class="comment">//展示的图片</span>
    <span class="keyword">private</span> <span class="keyword">int</span>[] images=<span class="keyword">new</span> <span class="keyword">int</span>[]{R.drawable.img1,R.drawable.img2,R.drawable.img3};
}
</code></pre><p>这里的主要地方是自定义了一个Adapter，我们只需要继承BaseAdapter即可，BaseAdapter已经实现了Adapter的大部分方法，我们继承后只需要实现部分的方法即可。必须实现的就是getCount和getView方法，前一个是返回ListView中有多少个元素，后一个是生成要展示的View。ListView在每添加一个View是就会调用Adapter的getView方法，所以我们有必要对这个方法做优化，例子中就做了部分的优化，一般面试的时候会被问到ListView优化，回答例子中的这些代码就差不多了。</p>
<ol>
<li>运行，我们会看到效果如图：<img src="http://dl.iteye.com/upload/attachment/385773/07462b29-e24f-387b-9649-842cfbfb0359.jpg" alt=""></li>
</ol>
<h2 id="四、ListView列表中的元素的单击事件响应">四、ListView列表中的元素的单击事件响应</h2><ol>
<li>如果我们要想单击一个ListView的元素使其作出相应的响应怎么办呢？比如弹出什么，打开什么，展示什么等等，那么我们只需要实现单击事件的函数既可。</li>
</ol>
<ol>
<li>要实现ListView的单击事件有两种方法，一个是使用getListView().setOnClickListener(l);设置，这个和平时我们用的控件设置是一样的，不做介绍，下面介绍第二个，就是重写ListActivity的onListItemClick方法，其实这个的最后处理也是ListView的setOnClickListener进行监听调用的。</li>
</ol>
<ol>
<li>在HelloListView类中增加如下代码：</li>
</ol>
<pre><code><span class="annotation">@Override</span>
<span class="keyword">protected</span> <span class="function"><span class="keyword">void</span> <span class="title">onListItemClick</span><span class="params">(ListView l, View v, <span class="keyword">int</span> position, <span class="keyword">long</span> id)</span> </span>{
        Toast.makeText(<span class="keyword">this</span>, <span class="string">"你单击了"</span>+texts[position], Toast.LENGTH_SHORT).show();
</code></pre><ol>
<li>运行单击其中的一行效果如下图：<br><img src="http://dl.iteye.com/upload/attachment/385776/b52954ad-12b5-34dd-8c8c-b2bb03312427.jpg" alt=""></li>
</ol>
<h2 id="五、小结">五、小结</h2><p>到这里ListView应该算是会使用了，起码常用的功能会的，当然还有很多没有说到的，比如ListView的分割部分，headView和footView以及ListView的分页等等，这些就需要我们自己下去好好摸索了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>ListView是Android开发中非常常用的组件，ListView可以用来显示一个列表，我们可以对这个列表操作，比如点击列表要做什么等等。这篇文章主要通过一个示例来展示ListView的用法。</p>
<p>请加入，大家一块学习。</p>
<h2 id="一、不使用xm]]>
    </summary>
    
      <category term="Android" scheme="http://www.flysnow.org/tags/Android/"/>
    
      <category term="Widget" scheme="http://www.flysnow.org/tags/Widget/"/>
    
      <category term="Android" scheme="http://www.flysnow.org/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android EditText使用详解-包含很多教程上看不到的功能演示]]></title>
    <link href="http://www.flysnow.org/2010/11/29/android-edittext-tutorials.html"/>
    <id>http://www.flysnow.org/2010/11/29/android-edittext-tutorials.html</id>
    <published>2010-11-29T00:51:00.000Z</published>
    <updated>2016-05-22T10:14:57.290Z</updated>
    <content type="html"><![CDATA[<p>标题有点大，说是详解，其实就是对EditText的一些常用功能的介绍，包括密码框，电话框，空白提示文字等等的讲解，尽量的介绍详细一点，也就是所谓的详解了。。呵呵</p>
<h2 id="一：新建HelloEditText工程">一：新建HelloEditText工程</h2><p>新建一个Hello world详细步骤可以参见</p>
<p><a href="/2010/11/13/android-helloworld.html">Android 第一个Android应用，HelloWorld</a></p>
<p>创建设置如下：</p>
<ol>
<li>Project name:HelloEditText</li>
<li>Build Target :android 2.2</li>
<li>Application name:HelloEditText</li>
<li>Package name:com.flysnow</li>
<li>create Activity:HelloEditText</li>
<li>min SDK 8</li>
</ol>
<p>这时候运行还看不到EditText，因为我们还没有加上,修改main.xml如下：</p>
<pre><code><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span>
    <span class="tag">&lt;<span class="title">LinearLayout</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span>
        <span class="attribute">android:orientation</span>=<span class="value">"vertical"</span>
        <span class="attribute">android:layout_width</span>=<span class="value">"fill_parent"</span>
        <span class="attribute">android:layout_height</span>=<span class="value">"fill_parent"</span>
        &gt;</span>
    <span class="tag">&lt;<span class="title">EditText</span>
        <span class="attribute">android:id</span>=<span class="value">"@+id/edit_text"</span>  
        <span class="attribute">android:layout_width</span>=<span class="value">"fill_parent"</span> 
        <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span> 
        <span class="attribute">android:text</span>=<span class="value">"这是一个EditText"</span>/&gt;</span>
<span class="tag">&lt;/<span class="title">LinearLayout</span>&gt;</span>
</code></pre><p> 这里添加了一个id为”edit_text”的EditText，设置默认显示为本为“这是一个EditText”。。运行效果如下：</p>
<p><img src="http://dl.iteye.com/upload/attachment/355666/8abc632a-3e6c-3c5f-9dc1-90aac6470f96.png" alt=""></p>
<h2 id="二：EditText简介">二：EditText简介</h2><p>EditText是一个非常重要的组件，可以说它是用户和Android应用进行数据传输窗户，有了它就等于有了一扇和Android应用传输的门，通过它用户可以把数据传给Android应用，然后得到我们想要的数据。</p>
<p>EditText是TextView的子类，所以TextView的方法和特性同样存在于EditText中，具体的TextView的介绍可以参考上一节<a href="/2010/11/25/android-textview-tutorials.html">Android TextView小组件的使用—附带超链接和跑马灯效果 </a></p>
<h2 id="三：长度和空白提示文字,提示文字颜色,是否可编辑等">三：长度和空白提示文字,提示文字颜色,是否可编辑等</h2><p>EditText有一些属性可以设置EditText的特性，比如最大长度，空白提示文字等。</p>
<ol>
<li>有时候我们有一些特属的需要，要求只能在EditText中输入特定个数的字符，比如身份证号、手机号吗等。这时候就可以通过android:maxLength属性来设置最大输入字符个数，比如android:maxLength=“4”就表示最多能输入4个字符，再多了就输入不进去了。</li>
</ol>
<ol>
<li>空白提示文字。有时候我们需要说明你定义的这个EditText是做什么用的，比如让输入“用户名”，或者输入“电话号码”等，但是你又不想在EditText前面加一个TextView来说明这是输入“用户名”的，因为这会使用一个TextView，那么怎么办呢？EditText为我们提供了android:hint来设置当EditText内容为空时显示的文本，这个文本只在EditText为空时显示，你输入字符的时候就消失了，不影响你的EditText的文本。。修改main.xml如下：</li>
</ol>
<pre><code><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span>
<span class="tag">&lt;<span class="title">LinearLayout</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span>
    <span class="attribute">android:orientation</span>=<span class="value">"vertical"</span>
    <span class="attribute">android:layout_width</span>=<span class="value">"fill_parent"</span>
    <span class="attribute">android:layout_height</span>=<span class="value">"fill_parent"</span>
    &gt;</span>
<span class="tag">&lt;<span class="title">EditText</span>
    <span class="attribute">android:id</span>=<span class="value">"@+id/edit_text"</span>  
    <span class="attribute">android:layout_width</span>=<span class="value">"fill_parent"</span> 
    <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span>
    <span class="attribute">android:maxLength</span>=<span class="value">"40"</span>
    <span class="attribute">android:hint</span>=<span class="value">"请输入用户名..."</span>/&gt;</span>
<span class="tag">&lt;/<span class="title">LinearLayout</span>&gt;</span>
</code></pre><p>运行应用就会看到如下的效果：</p>
<p><img src="http://dl.iteye.com/upload/attachment/355690/1fe441fe-e9fc-32f2-8fcf-53e0445d654c.png" alt=""><br>看看吧，简洁明了还不用新增一个TextView说明，也不影响用户操作。</p>
<ol>
<li>上面列出了空白时的提示文字，有的人说了，我不想要这个灰色的提示文字，和我的应用整体风格不协调，那也行啊，我们可以换颜色，怎么换呢，就是通过android:textColorHint属性设置你想要的颜色。修改main.xml如下:</li>
</ol>
<pre><code>&lt;?xml <span class="variable">version=</span><span class="string">"1.0"</span> <span class="variable">encoding=</span><span class="string">"utf-8"</span>?&gt;
&lt;LinearLayout xmlns:<span class="variable">android=</span><span class="string">"http://schemas.android.com/apk/res/android"</span>
    android:<span class="variable">orientation=</span><span class="string">"vertical"</span>
    android:<span class="variable">layout_width=</span><span class="string">"fill_parent"</span>
    android:<span class="variable">layout_height=</span><span class="string">"fill_parent"</span>
    &gt;
&lt;EditText
    android:<span class="variable">id=</span><span class="string">"@+id/edit_text"</span>  
    android:<span class="variable">layout_width=</span><span class="string">"fill_parent"</span> 
    android:<span class="variable">layout_height=</span><span class="string">"wrap_content"</span>
    android:<span class="variable">maxLength=</span><span class="string">"40"</span>
    android:<span class="variable">hint=</span><span class="string">"请输入用户名..."</span>
    android:<span class="variable">textColorHint=</span><span class="string">"#238745"</span>/&gt;
&lt;/LinearLayout&gt;
</code></pre><p>运行程序效果如下：</p>
<p><img src="http://dl.iteye.com/upload/attachment/355702/7751967e-633b-3c69-bdc0-f135b1a25a25.png" alt=""><br>看到了吧，颜色已经变了。。</p>
<ol>
<li>还有一个比较实用的功能，就是设置EditText的不可编辑。设置android:enabled=”false”可以实现不可编辑，可以获得焦点。这时候我们看到EditText和一个TextView差不多：<img src="http://dl.iteye.com/upload/attachment/355705/dccc8638-134c-3532-9d44-03fbb394669b.png" alt=""></li>
</ol>
<ol>
<li>实现类似html中Textarea的文本域。在Android中没有专门的文本域组件，但是可以通过设置EditText的高来实现同样的文本域功能。修改main.xml如下:</li>
</ol>
<pre><code><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span>
<span class="tag">&lt;<span class="title">LinearLayout</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span>
    <span class="attribute">android:orientation</span>=<span class="value">"vertical"</span>
    <span class="attribute">android:layout_width</span>=<span class="value">"fill_parent"</span>
    <span class="attribute">android:layout_height</span>=<span class="value">"fill_parent"</span>
    &gt;</span>
<span class="tag">&lt;<span class="title">EditText</span>
    <span class="attribute">android:id</span>=<span class="value">"@+id/edit_text"</span>  
    <span class="attribute">android:layout_width</span>=<span class="value">"fill_parent"</span> 
    <span class="attribute">android:layout_height</span>=<span class="value">"200dip"</span>/&gt;</span>
<span class="tag">&lt;/<span class="title">LinearLayout</span>&gt;</span>
</code></pre><p>运行程序效果如下：</p>
<p><img src="http://dl.iteye.com/upload/attachment/355707/a1e61bd2-1162-3b7a-8a5c-3dfe880e3866.png" alt=""></p>
<h2 id="四：输入特殊格式的字符">四：输入特殊格式的字符</h2><p>在我们开发程序的时候不免会输入一些特属个数的字符，比如密码（输入框的字符要加密显示），电话号码（比如数字和-）,数字等，这些都算是一些特属格式的字符，强大的EditText同样为我们提供了输入这些特属格式字符的设置。</p>
<ol>
<li>密码文本框。密码输入也是Android应用常用的功能，通过配置EditText的android:password=”true”就可以实现这一密码输入功能，修改main.xml如下：</li>
</ol>
<pre><code><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span>
<span class="tag">&lt;<span class="title">LinearLayout</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span>
    <span class="attribute">android:orientation</span>=<span class="value">"vertical"</span>
    <span class="attribute">android:layout_width</span>=<span class="value">"fill_parent"</span>
    <span class="attribute">android:layout_height</span>=<span class="value">"fill_parent"</span>
    &gt;</span>
<span class="tag">&lt;<span class="title">EditText</span>
    <span class="attribute">android:id</span>=<span class="value">"@+id/edit_text"</span>  
    <span class="attribute">android:layout_width</span>=<span class="value">"fill_parent"</span> 
    <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span>
    <span class="attribute">android:password</span>=<span class="value">"true"</span>/&gt;</span>
<span class="tag">&lt;/<span class="title">LinearLayout</span>&gt;</span>
</code></pre><p>运行效果如下：</p>
<p><img src="http://dl.iteye.com/upload/attachment/355709/b4831d6e-2f6a-3b1e-a8ae-982083b1e596.png" alt=""><br>可以看到我们输入的字符已经被“.”这样的掩码所代替。</p>
<ol>
<li>手机中发短信打电话是必不可少的，所以用于专门输入电话号码的文本框也是大有用途，有了他我们对是否是电话号码的校验就容易的多了(因为字符是正确的，只要校验格式<br>).通过设置android:phoneNumber=”true”就可以把EditText变成只接受电话号码输入的文本框，连软键盘都已经变成拨号专用软键盘了，所以不用再担心输入其他字符了。修改main.xml如下： </li>
</ol>
<pre><code><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span>
<span class="tag">&lt;<span class="title">LinearLayout</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span>
    <span class="attribute">android:orientation</span>=<span class="value">"vertical"</span>
    <span class="attribute">android:layout_width</span>=<span class="value">"fill_parent"</span>
    <span class="attribute">android:layout_height</span>=<span class="value">"fill_parent"</span>
    &gt;</span>
<span class="tag">&lt;<span class="title">EditText</span>
    <span class="attribute">android:id</span>=<span class="value">"@+id/edit_text"</span>  
    <span class="attribute">android:layout_width</span>=<span class="value">"fill_parent"</span> 
    <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span>
    <span class="attribute">android:phoneNumber</span>=<span class="value">"true"</span>/&gt;</span>
<span class="tag">&lt;/<span class="title">LinearLayout</span>&gt;</span>
</code></pre><p>运行程序效果如下：</p>
<p><img src="http://dl.iteye.com/upload/attachment/355713/525c31d6-adbe-39e2-8edb-afb6431d657f.png" alt=""><br>注意看软键盘，已经变成拨号专用的啦.</p>
<ol>
<li>有时候我们只想输入数字，不想输入字母，EditText为我们提供了android:numeric来控制输入的数字类型，一共有三种分别为integer（正整数）、signed（带符号整数）和decimal(浮点数)。这里以signed类型的为例，修改main.xml如下：</li>
</ol>
<pre><code><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span>
<span class="tag">&lt;<span class="title">LinearLayout</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span>
    <span class="attribute">android:orientation</span>=<span class="value">"vertical"</span>
    <span class="attribute">android:layout_width</span>=<span class="value">"fill_parent"</span>
    <span class="attribute">android:layout_height</span>=<span class="value">"fill_parent"</span>
    &gt;</span>
<span class="tag">&lt;<span class="title">EditText</span>
    <span class="attribute">android:id</span>=<span class="value">"@+id/edit_text"</span>  
    <span class="attribute">android:layout_width</span>=<span class="value">"fill_parent"</span> 
    <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span>
    <span class="attribute">android:numeric</span>=<span class="value">"signed"</span>/&gt;</span>
<span class="tag">&lt;/<span class="title">LinearLayout</span>&gt;</span>
</code></pre><p>运行效果如下：</p>
<p><img src="http://dl.iteye.com/upload/attachment/355719/88cc320b-3d8f-3cd7-9dc0-19c8da6df9dd.png" alt=""><br>注意这里的软键盘变成“数字键盘”的变化.</p>
<h2 id="五：为文本指定特定的软键盘类型">五：为文本指定特定的软键盘类型</h2><p>前面我们通过指定为电话号码特定格式，然后键盘类型变成了拨号专用的键盘，这个是自动变的，其实我们也可以通<br>过android:inputType来设置文本的类型，让输入法选择合适的软键盘的。。android:inputType有很多类型，这里使用date类型来演示,修改main.xml如下：</p>
<pre><code><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span>
<span class="tag">&lt;<span class="title">LinearLayout</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span>
    <span class="attribute">android:orientation</span>=<span class="value">"vertical"</span>
    <span class="attribute">android:layout_width</span>=<span class="value">"fill_parent"</span>
    <span class="attribute">android:layout_height</span>=<span class="value">"fill_parent"</span>
    &gt;</span>
<span class="tag">&lt;<span class="title">EditText</span>
    <span class="attribute">android:id</span>=<span class="value">"@+id/edit_text"</span>  
    <span class="attribute">android:layout_width</span>=<span class="value">"fill_parent"</span> 
    <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span>
    <span class="attribute">android:inputType</span>=<span class="value">"date"</span>/&gt;</span>
<span class="tag">&lt;/<span class="title">LinearLayout</span>&gt;</span>
</code></pre><p>运行效果如下：</p>
<p><img src="http://dl.iteye.com/upload/attachment/355729/bbfe54c6-a87a-3ab6-908d-32644cda7d31.png" alt=""></p>
<h2 id="六：Enter键图标的设置">六：Enter键图标的设置</h2><p>软键盘的Enter键默认显示的是“完成”文本，我们知道按Enter建表示前置工作已经准备完毕了，要去什么什么啦。比如，在一个搜索中，我们输入要搜索的文本，然后按Enter表示要去搜索了，但是默认的Enter键显示的是“完成”文本，看着不太合适，不符合搜索的语义，如果能显示“搜索”两个字或者显示一个表示搜索的图标多好。事实证明我们的想法是合理的，Android也为我们提供的这样的功能。通过设置android:imeOptions来改变默认的“完成”文本。这里举几个常用的常量值：</p>
<ol>
<li>actionUnspecified  未指定，对应常量EditorInfo.IME_ACTION_UNSPECIFIED.效果：<img src="http://dl.iteye.com/upload/attachment/355737/bd9d7b7c-2a93-37b3-afd9-cda2f3593058.png" alt=""></li>
</ol>
<ol>
<li>actionNone 没有动作,对应常量EditorInfo.IME_ACTION_NONE 效果：<img src="http://dl.iteye.com/upload/attachment/355737/bd9d7b7c-2a93-37b3-afd9-cda2f3593058.png" alt=""></li>
</ol>
<ol>
<li>actionGo 去往，对应常量EditorInfo.IME_ACTION_GO 效果：<img src="http://dl.iteye.com/upload/attachment/355757/a8db4447-ec91-39aa-a546-c117db16cf55.png" alt=""></li>
</ol>
<ol>
<li>actionSearch 搜索，对应常量EditorInfo.IME_ACTION_SEARCH 效果： <img src="http://dl.iteye.com/upload/attachment/355769/c35d6b78-d5b9-314a-9698-144bc12d0af3.png" alt=""></li>
</ol>
<ol>
<li>actionSend 发送，对应常量EditorInfo.IME_ACTION_SEND 效果：<img src="http://dl.iteye.com/upload/attachment/355788/c168252f-bb3d-3831-8e3c-8bced16b12a1.png" alt=""></li>
</ol>
<ol>
<li>actionNext 下一个，对应常量EditorInfo.IME_ACTION_NEXT 效果：<img src="http://dl.iteye.com/upload/attachment/355798/aa6bd8b1-8ab3-38d9-b162-01ce10f4f998.png" alt=""></li>
</ol>
<ol>
<li>actionDone 完成，对应常量EditorInfo.IME_ACTION_DONE 效果：<img src="http://dl.iteye.com/upload/attachment/355804/79979746-7373-3377-bb7e-3dd4bdede464.png" alt=""></li>
</ol>
<p>下面已搜索为例，演示一个实例，修改main.xml如下：</p>
<pre><code><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span>
<span class="tag">&lt;<span class="title">LinearLayout</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span>
    <span class="attribute">android:orientation</span>=<span class="value">"vertical"</span>
    <span class="attribute">android:layout_width</span>=<span class="value">"fill_parent"</span>
    <span class="attribute">android:layout_height</span>=<span class="value">"fill_parent"</span>
    &gt;</span>
<span class="tag">&lt;<span class="title">EditText</span>
    <span class="attribute">android:id</span>=<span class="value">"@+id/edit_text"</span>  
    <span class="attribute">android:layout_width</span>=<span class="value">"fill_parent"</span> 
    <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span>
    <span class="attribute">android:imeOptions</span>=<span class="value">"actionSearch"</span>/&gt;</span>
<span class="tag">&lt;/<span class="title">LinearLayout</span>&gt;</span>
</code></pre><p>修改HelloEditText如下：</p>
<pre><code><span class="keyword">package</span> com.flysnow;

<span class="keyword">import</span> android.app.<span class="type">Activity</span>;
<span class="keyword">import</span> android.os.<span class="type">Bundle</span>;
<span class="keyword">import</span> android.view.<span class="type">KeyEvent</span>;
<span class="keyword">import</span> android.widget.<span class="type">EditText</span>;
<span class="keyword">import</span> android.widget.<span class="type">TextView</span>;
<span class="keyword">import</span> android.widget.<span class="type">Toast</span>;
<span class="keyword">import</span> android.widget.<span class="type">TextView</span>.<span class="type">OnEditorActionListener</span>;

public <span class="class"><span class="keyword">class</span> <span class="title">HelloEditText</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Activity</span> {</span>
    <span class="comment">/** Called when the activity is first created. */</span>
    <span class="annotation">@Override</span>
    public void onCreate(<span class="type">Bundle</span> savedInstanceState) {
        <span class="keyword">super</span>.onCreate(savedInstanceState);
        setContentView(<span class="type">R</span>.layout.main);
        <span class="type">EditText</span> editText=(<span class="type">EditText</span>)findViewById(<span class="type">R</span>.id.edit_text);
        editText.setOnEditorActionListener(<span class="keyword">new</span> <span class="type">OnEditorActionListener</span>() {
            <span class="annotation">@Override</span>
            public boolean onEditorAction(<span class="type">TextView</span> v, int actionId, <span class="type">KeyEvent</span> event) {
                <span class="type">Toast</span>.makeText(<span class="type">HelloEditText</span>.<span class="keyword">this</span>, <span class="type">String</span>.valueOf(actionId), <span class="type">Toast</span>.<span class="type">LENGTH_SHORT</span>).show();
                <span class="keyword">return</span> <span class="literal">false</span>;
            }
        });
    }
}
</code></pre><p>运行程序，点击回车（也就是搜索图标软键盘按钮）会显示该actionId.我们上面的每一个设置都会对应一个常量，这里的actionId就是那个常量值。</p>
<p><img src="http://dl.iteye.com/upload/attachment/355851/c9f95967-fe2f-3850-a96a-17bc220fcc32.png" alt=""></p>
<h2 id="七：EditText的取值、全选、部分选择、获取选中文本">七：EditText的取值、全选、部分选择、获取选中文本</h2><p>下面通过一个例子来演示EditText的取值、全选、部分选择和获取选中文本.main.xml修改如下：</p>
<pre><code>&lt;?xml <span class="variable">version=</span><span class="string">"1.0"</span> <span class="variable">encoding=</span><span class="string">"utf-8"</span>?&gt;
&lt;LinearLayout xmlns:<span class="variable">android=</span><span class="string">"http://schemas.android.com/apk/res/android"</span>
    android:<span class="variable">orientation=</span><span class="string">"vertical"</span>
    android:<span class="variable">layout_width=</span><span class="string">"fill_parent"</span>
    android:<span class="variable">layout_height=</span><span class="string">"fill_parent"</span>
    &gt;
&lt;EditText
    android:<span class="variable">id=</span><span class="string">"@+id/edit_text"</span>  
    android:<span class="variable">layout_width=</span><span class="string">"fill_parent"</span> 
    android:<span class="variable">layout_height=</span><span class="string">"wrap_content"</span>
    android:<span class="variable">imeOptions=</span><span class="string">"actionSearch"</span>/&gt;
&lt;Button 
    android:<span class="variable">id=</span><span class="string">"@+id/btn_get_value"</span>
    android:<span class="variable">text=</span><span class="string">"取值"</span>
    android:<span class="variable">layout_width=</span><span class="string">"wrap_content"</span>
    android:<span class="variable">layout_height=</span><span class="string">"wrap_content"</span>/&gt;
&lt;Button 
    android:<span class="variable">id=</span><span class="string">"@+id/btn_all"</span>
    android:<span class="variable">text=</span><span class="string">"全选"</span>
    android:<span class="variable">layout_width=</span><span class="string">"wrap_content"</span>
    android:<span class="variable">layout_height=</span><span class="string">"wrap_content"</span>/&gt;
&lt;Button 
    android:<span class="variable">id=</span><span class="string">"@+id/btn_select"</span>
    android:<span class="variable">text=</span><span class="string">"从第2个字符开始选择"</span>
    android:<span class="variable">layout_width=</span><span class="string">"wrap_content"</span>
    android:<span class="variable">layout_height=</span><span class="string">"wrap_content"</span>/&gt;
&lt;Button 
    android:<span class="variable">id=</span><span class="string">"@+id/btn_get_select"</span>
    android:<span class="variable">text=</span><span class="string">"获取选中文本"</span>
    android:<span class="variable">layout_width=</span><span class="string">"wrap_content"</span>
    android:<span class="variable">layout_height=</span><span class="string">"wrap_content"</span>/&gt;
&lt;/LinearLayout&gt;
</code></pre><p>HelloEditText修改如下：</p>
<pre><code><span class="keyword">package</span> com.flysnow;

<span class="keyword">import</span> android.app.Activity;
<span class="keyword">import</span> android.os.Bundle;
<span class="keyword">import</span> android.text.Editable;
<span class="keyword">import</span> android.text.Selection;
<span class="keyword">import</span> android.view.KeyEvent;
<span class="keyword">import</span> android.view.View;
<span class="keyword">import</span> android.view.View.OnClickListener;
<span class="keyword">import</span> android.widget.Button;
<span class="keyword">import</span> android.widget.EditText;
<span class="keyword">import</span> android.widget.TextView;
<span class="keyword">import</span> android.widget.Toast;
<span class="keyword">import</span> android.widget.TextView.OnEditorActionListener;
<span class="javadoc">/**
 * EditText演示
 *<span class="javadoctag"> @author</span> 飞雪无情
 *<span class="javadoctag"> @since</span> 2010-11-29
 */</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloEditText</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>{
    <span class="javadoc">/** Called when the activity is first created. */</span>
    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>{
        <span class="keyword">super</span>.onCreate(savedInstanceState);
        setContentView(R.layout.main);
        <span class="keyword">final</span> EditText editText=(EditText)findViewById(R.id.edit_text);
        <span class="comment">//监听回车键</span>
        editText.setOnEditorActionListener(<span class="keyword">new</span> OnEditorActionListener() {
            <span class="annotation">@Override</span>
            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onEditorAction</span><span class="params">(TextView v, <span class="keyword">int</span> actionId, KeyEvent event)</span> </span>{
                Toast.makeText(HelloEditText.<span class="keyword">this</span>, String.valueOf(actionId), Toast.LENGTH_SHORT).show();
                <span class="keyword">return</span> <span class="keyword">false</span>;
            }
        });
        <span class="comment">//获取EditText文本</span>
        Button getValue=(Button)findViewById(R.id.btn_get_value);
        getValue.setOnClickListener(<span class="keyword">new</span> OnClickListener() {
            <span class="annotation">@Override</span>
            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>{
                Toast.makeText(HelloEditText.<span class="keyword">this</span>, editText.getText().toString(), Toast.LENGTH_SHORT).show();
            }
        });
        <span class="comment">//让EditText全选</span>
        Button all=(Button)findViewById(R.id.btn_all);
        all.setOnClickListener(<span class="keyword">new</span> OnClickListener() {
            <span class="annotation">@Override</span>
            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>{
                editText.selectAll();
            }
        });
        <span class="comment">//从第2个字符开始选择EditText文本</span>
        Button select=(Button)findViewById(R.id.btn_select);
        select.setOnClickListener(<span class="keyword">new</span> OnClickListener() {
            <span class="annotation">@Override</span>
            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>{
                Editable editable=editText.getText();
                Selection.setSelection(editable, <span class="number">1</span>,editable.length());
            }
        });
      <span class="comment">//获取选中的文本</span>
        Button getSelect=(Button)findViewById(R.id.btn_get_select);
        getSelect.setOnClickListener(<span class="keyword">new</span> OnClickListener() {
            <span class="annotation">@Override</span>
            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>{
                <span class="keyword">int</span> start=editText.getSelectionStart();
                <span class="keyword">int</span> end=editText.getSelectionEnd();
                CharSequence selectText=editText.getText().subSequence(start, end);
                Toast.makeText(HelloEditText.<span class="keyword">this</span>, selectText, Toast.LENGTH_SHORT).show();
            }
        });
    }
    <span class="javadoc">/**
     * 交换两个索引
     *<span class="javadoctag"> @param</span> start 开始索引
     *<span class="javadoctag"> @param</span> end 结束索引
     */</span>
    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">switchIndex</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>{
        <span class="keyword">int</span> temp=start;
        start=end;
        end=temp;
    }
}
</code></pre><p>运行效果如下：</p>
<p><img src="http://dl.iteye.com/upload/attachment/356058/4926c2d1-36a0-3cb6-b02f-e743e2313045.png" alt=""><br>可以通过输入文字和点击下面的按钮测试。</p>
<h2 id="八：小结">八：小结</h2><p>这结详细介绍了EditText的大部分特性和常用功能，如常用的密码框，获取值等等。这几天忙的没更新，这次更新个长的。可以够消化一阵子的。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>标题有点大，说是详解，其实就是对EditText的一些常用功能的介绍，包括密码框，电话框，空白提示文字等等的讲解，尽量的介绍详细一点，也就是所谓的详解了。。呵呵</p>
<h2 id="一：新建HelloEditText工程">一：新建HelloEditText工程</h2]]>
    </summary>
    
      <category term="Android" scheme="http://www.flysnow.org/tags/Android/"/>
    
      <category term="Widget" scheme="http://www.flysnow.org/tags/Widget/"/>
    
      <category term="Android" scheme="http://www.flysnow.org/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android TextView小组件的使用--附带超链接和跑马灯效果]]></title>
    <link href="http://www.flysnow.org/2010/11/24/android-textview-tutorials.html"/>
    <id>http://www.flysnow.org/2010/11/24/android-textview-tutorials.html</id>
    <published>2010-11-24T08:19:03.000Z</published>
    <updated>2016-05-22T10:14:57.290Z</updated>
    <content type="html"><![CDATA[<p>这节主要介绍一下TextView的简单用法，以及超链接文本、跑马灯等实例。</p>
<h2 id="一：新建HelloTextView_工程">一：新建HelloTextView 工程</h2><p>新建一个Hello world详细步骤可以参见</p>
<h3 id="Android第一个Android应用，HelloWorld"><a href="/2010/11/13/android-helloworld.html">Android第一个Android应用，HelloWorld</a></h3><p>创建设置如下：</p>
<ol>
<li>Project name:HelloTextView</li>
</ol>
<ol>
<li>Build Target :android 2.2</li>
</ol>
<ol>
<li>Application name:HelloTextView</li>
</ol>
<ol>
<li>Package name:com.flysnow</li>
</ol>
<ol>
<li>create Activity:HelloTextView</li>
</ol>
<ol>
<li>min SDK 8</li>
</ol>
<p>然后运行该应用就可以看到TextView的效果，是显示一行字：“Hello World, HelloTextView!”，这是因为新建的Hello项目自带的一个TextView。</p>
<h2 id="二：分析TextView组件">二：分析TextView组件</h2><p>TextView是Android中常用的组件之一，可以用他来显示文字，就像一个标签一样，或者你可以认为是html中的span。对于TextView我们最关心的应该是怎么设置显示的文本，怎样设置字体的大小，字体的颜色，字体的样式，</p>
<p>其实很简单，TextView中提供了大量的属性帮我们配置TextView。</p>
<ol>
<li>修改xml配置文件实现。我们修改main.xml如下:</li>
</ol>
<pre><code>&lt;?xml <span class="variable">version=</span><span class="string">"1.0"</span> <span class="variable">encoding=</span><span class="string">"utf-8"</span>?&gt;
&lt;LinearLayout xmlns:<span class="variable">android=</span><span class="string">"http://schemas.android.com/apk/res/android"</span>
    android:<span class="variable">orientation=</span><span class="string">"vertical"</span>
    android:<span class="variable">layout_width=</span><span class="string">"fill_parent"</span>
    android:<span class="variable">layout_height=</span><span class="string">"fill_parent"</span>
    &gt;
&lt;TextView  
    android:<span class="variable">layout_width=</span><span class="string">"fill_parent"</span> 
    android:<span class="variable">layout_height=</span><span class="string">"wrap_content"</span>
    android:<span class="variable">textColor=</span><span class="string">"#ff0000"</span>
    android:<span class="variable">textSize=</span><span class="string">"24sp"</span>
    android:<span class="variable">textStyle=</span><span class="string">"bold"</span>
    android:<span class="variable">text=</span><span class="string">"@string/hello"</span>
    /&gt;
&lt;/LinearLayout&gt;
</code></pre><p>这里增加了三个属性的设置，分别是android:textColor=”#ff0000”设置字体为红色，android:textSize=”24sp”设置字体为24sp, android:textStyle=”bold”设置字体加粗，预览效果如下图：<br><img src="http://dl.iteye.com/upload/attachment/353237/12c1bbb8-419b-3dbd-b53a-501f73088c50.png" alt="">看到我们的TextView的内容已经变成红色，24sp大，加粗。。</p>
<ol>
<li>2.修改java代码实现。同样我们不修改xml文件，而是通过java编码来实现上面的图示效果，首先我们先给这个TextView分配一个id，也就是这个TextView的标记记号，方便我们找到他。在main.xml的TextView中加入android:id=”@+id/text_view”就可以为该TextView分配一个id。。这里@+id/是表示在R类的id类下新增常量字段，这里的常量字段是text_view。下面修改HelloTextView类如下：</li>
</ol>
<pre><code><span class="keyword">package</span> com.flysnow;

<span class="keyword">import</span> android.app.<span class="type">Activity</span>;
<span class="keyword">import</span> android.graphics.<span class="type">Color</span>;
<span class="keyword">import</span> android.graphics.<span class="type">Typeface</span>;
<span class="keyword">import</span> android.os.<span class="type">Bundle</span>;
<span class="keyword">import</span> android.util.<span class="type">TypedValue</span>;
<span class="keyword">import</span> android.widget.<span class="type">TextView</span>;

public <span class="class"><span class="keyword">class</span> <span class="title">HelloTextView</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Activity</span> {</span>
    <span class="comment">/** Called when the activity is first created. */</span>
    <span class="annotation">@Override</span>
    public void onCreate(<span class="type">Bundle</span> savedInstanceState) {
        <span class="keyword">super</span>.onCreate(savedInstanceState);
        setContentView(<span class="type">R</span>.layout.main);<span class="comment">//设置内容显示的xml布局文件</span>
        <span class="type">TextView</span> textView=(<span class="type">TextView</span>)findViewById(<span class="type">R</span>.id.text_view);<span class="comment">//取得我们的TextView组件</span>
        textView.setTextColor(<span class="type">Color</span>.<span class="type">RED</span>);<span class="comment">//设置成红色</span>
        textView.setTextSize(<span class="type">TypedValue</span>.<span class="type">COMPLEX_UNIT_SP</span>, <span class="number">24</span>f);<span class="comment">//设置成24sp</span>
        textView.setTypeface(<span class="type">Typeface</span>.defaultFromStyle(<span class="type">Typeface</span>.<span class="type">BOLD</span>));<span class="comment">//加粗</span>
    }
}
</code></pre><p>最终结果和上图一样的，这说明通过代码和xml配置都可以定制TextView，但是推荐使用xml进行定制，使用java代码控制逻辑，这符合mvc模式，也符合Android的设计思想。</p>
<p>这里说一下度量单位。度量单位有很多，如px,pt,dip,sp等等。不过建议应该使用sp作为字体大小的单位，使用dip作为其他元素的单位。。因为sp是刻度无关的像素，更重要的是他可以根据用户的字体大小的首选项进行缩放，这才是重要的，这样当你调整了整体的字体大小时不至于使得个别字体的大小不一致而影响美观。</p>
<h2 id="三：TextView的一些有用的实例">三：TextView的一些有用的实例</h2><ol>
<li>TextView的超链接形势。我们应该都见过html中的超链接，加一个a标记就可以让一段文字变成超链接的形式，可以点击到连接的地址。那么TextView可以实现吗？作为强大的TextView当然不会忘记这一点。TextView为我们提供了android:autoLink属性，只要把他设置成“web”,那么该TextView中的是网址形势的文件就会自动变成超链接的形式。好了，耳听为虚，眼见为实，看下面的例子。修改strings.xml为：</li>
</ol>
<pre><code><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span>
<span class="tag">&lt;<span class="title">resources</span>&gt;</span>
    <span class="tag">&lt;<span class="title">string</span> <span class="attribute">name</span>=<span class="value">"hello"</span>&gt;</span>我的博客地址是：http://www.flysnow.org    \n我的电话是：400-34534-500\n我的email是12235@163.com<span class="tag">&lt;/<span class="title">string</span>&gt;</span>
    <span class="tag">&lt;<span class="title">string</span> <span class="attribute">name</span>=<span class="value">"app_name"</span>&gt;</span>HelloTextView<span class="tag">&lt;/<span class="title">string</span>&gt;</span>
<span class="tag">&lt;/<span class="title">resources</span>&gt;</span>
</code></pre><p>修改main.xml为：</p>
<pre><code><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span>
<span class="tag">&lt;<span class="title">LinearLayout</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span>
    <span class="attribute">android:orientation</span>=<span class="value">"vertical"</span>
    <span class="attribute">android:layout_width</span>=<span class="value">"fill_parent"</span>
    <span class="attribute">android:layout_height</span>=<span class="value">"fill_parent"</span>
    &gt;</span>
<span class="tag">&lt;<span class="title">TextView</span> 
    <span class="attribute">android:id</span>=<span class="value">"@+id/text_view"</span>
    <span class="attribute">android:autoLink</span>=<span class="value">"web"</span>
    <span class="attribute">android:layout_width</span>=<span class="value">"fill_parent"</span> 
    <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span>
    <span class="attribute">android:text</span>=<span class="value">"@string/hello"</span>
    /&gt;</span>
<span class="tag">&lt;/<span class="title">LinearLayout</span>&gt;</span>
</code></pre><p>然后把HelloTextView类中的那一段设置文本颜色、大小和样式的代码注释掉，运行程序就会看到如下图的效果:<br><img src="http://dl.iteye.com/upload/attachment/353258/c4c40145-5e31-3541-8fbd-bfb734a8b3cd.png" alt=""><br>当我们点击蓝色的我的博客的网址的时候，Android系统就会调用默认的web浏览器打开我的博客。<br>有的朋友已经注意到了，文本里我还写了我的电话和email，难道TextView也支持电话和email超链接吗？没错，的确支持，当我们设置android:autoLink=”phone”的时候，文本里的电话就会变成蓝色超链接形式，点击就会打开拨号界面等待你按通话键拨号，email也是同理。。</p>
<p>当我们把 android:autoLink换成phone的时候发现网址不超连接了，换成email也是一样。难道我们不能一下子让网址，电话，email都超链接吗？答案是肯定的，这时候我们可以把 android:autoLink设置成all，这样里面的网址、电话和email就都可以超链接了。<br><img src="http://dl.iteye.com/upload/attachment/353264/3de8c6b3-263b-3c8b-86b8-951de945bce6.png" alt=""></p>
<ol>
<li>跑马丁效果。有时候我们要显示的文本较长，TextView不能完全显示，这时候可以通过这中跑马灯的方式让文本移动展示，达到了既不占用地方又能完全看到文本的目的。这里直接复用农民伯伯的跑马灯代码：</li>
</ol>
<pre><code>&lt;?xml <span class="variable">version=</span><span class="string">"1.0"</span> <span class="variable">encoding=</span><span class="string">"utf-8"</span>?&gt;
&lt;LinearLayout xmlns:<span class="variable">android=</span><span class="string">"http://schemas.android.com/apk/res/android"</span>
    android:<span class="variable">orientation=</span><span class="string">"vertical"</span>
    android:<span class="variable">layout_width=</span><span class="string">"fill_parent"</span>
    android:<span class="variable">layout_height=</span><span class="string">"fill_parent"</span>
    &gt;
&lt;TextView 
    android:<span class="variable">id=</span><span class="string">"@+id/text_view"</span>
    android:<span class="variable">autoLink=</span><span class="string">"all"</span>
    android:<span class="variable">layout_width=</span><span class="string">"fill_parent"</span> 
    android:<span class="variable">layout_height=</span><span class="string">"wrap_content"</span>
    android:<span class="variable">text=</span><span class="string">"@string/hello"</span>
    android:<span class="variable">ellipsize=</span><span class="string">"marquee"</span> 
    android:<span class="variable">focusable=</span><span class="string">"true"</span> 
    android:<span class="variable">marqueeRepeatLimit=</span><span class="string">"marquee_forever"</span> 
    android:<span class="variable">focusableInTouchMode=</span><span class="string">"true"</span> 
    android:<span class="variable">scrollHorizontally=</span><span class="string">"true"</span>/&gt;
&lt;/LinearLayout&gt;
</code></pre><p>然后为TextView设置一个很长的字符串。运行就可以看到横向移动的效果。</p>
<p><img src="http://dl.iteye.com/upload/attachment/353267/fab3be3a-0850-32d1-8b74-893ac8dcb816.png" alt=""><br>设置的属性说明可以参考TextView的文档，这里也有中文版本：<a href="http://www.cnblogs.com/over140/archive/2010/08/27/1809745.html" target="_blank" rel="external">TextView中文API文档</a></p>
<p>这里要进行说明的是：以上设置在大部分情况下都会成功的展示跑马灯样式，但是在一些复杂的布局中就会看不到任何文字。比如我开发的Android应用“我团”，在展示团购详细信息页面，我自定义了一个标题栏让其显示团购的信息，想让其跑马灯的方式显示，但是使用了上述代码后看不到文字，其实是文字被撑下来的，这时候我们设置android:singleLine=”true”以单行的方式展示就好了。所以请以后实现跑马灯效果的时候最好加上android:singleLine=”true”单行展示。。</p>
<h2 id="四：小结">四：小结</h2><p>好了，一个TextView也啰嗦了那么多，希望大家能听明白，最后两个实用的例子能帮助大家更好的学习和使用TextView。。这两天JE挂了，没来得及更新，对不起大家了。最近忙于升级“我团”应用，也只能网上10点后才能上网写。可能更新会很慢，请见谅，谢谢各位的支持。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这节主要介绍一下TextView的简单用法，以及超链接文本、跑马灯等实例。</p>
<h2 id="一：新建HelloTextView_工程">一：新建HelloTextView 工程</h2><p>新建一个Hello world详细步骤可以参见</p>
<h3 id="A]]>
    </summary>
    
      <category term="Android" scheme="http://www.flysnow.org/tags/Android/"/>
    
      <category term="Widget" scheme="http://www.flysnow.org/tags/Widget/"/>
    
      <category term="Android" scheme="http://www.flysnow.org/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android Activity的生命周期]]></title>
    <link href="http://www.flysnow.org/2010/11/17/android-activity-statement-cycle-tutorials.html"/>
    <id>http://www.flysnow.org/2010/11/17/android-activity-statement-cycle-tutorials.html</id>
    <published>2010-11-16T17:02:20.000Z</published>
    <updated>2016-05-22T10:14:57.290Z</updated>
    <content type="html"><![CDATA[<p>通过上一节“Android系列之四：Android项目的目录结构”我们已经知道了什么是Activity，那么为什么我们创建一个Activity的导出类的时候为什么都要覆盖Activity的onCreate方法呢，为什么会在onPause()方法中保存一些当前Activity中的变化，要弄明白这些就要先了解Activity的生命周期，也就是一个Activity才开始到结束都要经过那些状态，下面通过一个例子了解Activity的<br>声明周期.</p>
<h2 id="一：Activity的生命周期方法">一：Activity的生命周期方法</h2><p>Android提供了很多Activity的生命周期方法，比如我们常用的onCreate、onPause、onResume等。这里主要介绍粗粒度的周期方法，诸如onPostCreate、onPostResume等这些细粒度的周期方法可以参考Android的API文档，在你需要更细层次的控制的时候可以使用这些细粒度的方法。粗粒度的周期方法有以下几个：onCreate()、onStart()、onResume()、onPause()、onStop()、onDestroy()，从名字上就可以看出来这些方法在什么时候执行。</p>
<h2 id="二：测试Activity的生命周期方法的执行顺序">二：测试Activity的生命周期方法的执行顺序</h2><p>为了能更明白上这几个周期放的执行顺序，我们新建一个HelloWorld项目，在Activity中覆盖这几个方法，打印出日志就可以看出来执行顺序了</p>
<ol>
<li>新建HelloWorld项目，详细步骤可以参见：<br><a href="/2010/11/13/android-helloworld.html">Android第一个Android应用，HelloWorld</a></li>
</ol>
<ol>
<li>修改main.xml内容为：</li>
</ol>
<pre><code>&lt;?xml <span class="variable">version=</span><span class="string">"1.0"</span> <span class="variable">encoding=</span><span class="string">"utf-8"</span>?&gt;
&lt;LinearLayout xmlns:<span class="variable">android=</span><span class="string">"http://schemas.android.com/apk/res/android"</span>
    android:<span class="variable">orientation=</span><span class="string">"vertical"</span>
    android:<span class="variable">layout_width=</span><span class="string">"fill_parent"</span>
    android:<span class="variable">layout_height=</span><span class="string">"fill_parent"</span>
    &gt;
&lt;TextView  
    android:<span class="variable">layout_width=</span><span class="string">"fill_parent"</span> 
    android:<span class="variable">layout_height=</span><span class="string">"wrap_content"</span> 
    android:<span class="variable">text=</span><span class="string">"第一个Activity"</span>
    /&gt;
&lt;Button 
    android:<span class="variable">id=</span><span class="string">"@+id/second"</span>
    android:<span class="variable">layout_width=</span><span class="string">"wrap_content"</span>
    android:<span class="variable">layout_height=</span><span class="string">"wrap_content"</span>
    android:<span class="variable">text=</span><span class="string">"打开第二个Activity"</span>/&gt;
&lt;/LinearLayout&gt;
</code></pre><p>这里主要是为增加一个文本显示和一个按钮用于显示信息和操作。</p>
<ol>
<li>新建布局文件second.xml，内容如下：</li>
</ol>
<pre><code>&lt;?xml <span class="variable">version=</span><span class="string">"1.0"</span> <span class="variable">encoding=</span><span class="string">"utf-8"</span>?&gt;
&lt;LinearLayout
  xmlns:<span class="variable">android=</span><span class="string">"http://schemas.android.com/apk/res/android"</span>
  android:<span class="variable">orientation=</span><span class="string">"vertical"</span>
  android:<span class="variable">layout_width=</span><span class="string">"fill_parent"</span>
  android:<span class="variable">layout_height=</span><span class="string">"fill_parent"</span>&gt;
  &lt;TextView  
    android:<span class="variable">layout_width=</span><span class="string">"fill_parent"</span> 
    android:<span class="variable">layout_height=</span><span class="string">"wrap_content"</span> 
    android:<span class="variable">text=</span><span class="string">"第二个Activity"</span>
    /&gt;
&lt;Button 
    android:<span class="variable">id=</span><span class="string">"@+id/exit"</span>
    android:<span class="variable">layout_width=</span><span class="string">"wrap_content"</span>
    android:<span class="variable">layout_height=</span><span class="string">"wrap_content"</span>
    android:<span class="variable">text=</span><span class="string">"退出"</span>/&gt;
&lt;/LinearLayout&gt;
</code></pre><p>这里主要是为增加一个文本显示和一个退出按钮用于退出当前Activity。</p>
<ol>
<li>新建一个Activity，名字为SecondActivity，内容如下:</li>
</ol>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecondActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>{
    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String TAG=<span class="string">"SecondActivity"</span>;
    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>{
        <span class="keyword">super</span>.onCreate(savedInstanceState);
        Log.v(TAG, <span class="string">"onCreate"</span>);
        setContentView(R.layout.second);
        <span class="comment">//退出按钮</span>
        Button btnExit=(Button)findViewById(R.id.exit);
        <span class="comment">//为退出按钮设置单击事件</span>
        btnExit.setOnClickListener(<span class="keyword">new</span> OnClickListener() {
            <span class="annotation">@Override</span>
            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>{
                finish();<span class="comment">//关闭当前Activity，也就是退出</span>
            }
        });
    }
    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>{
        <span class="keyword">super</span>.onStart();
        Log.v(TAG, <span class="string">"onStart"</span>);
    }
    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span> </span>{
        <span class="keyword">super</span>.onResume();
        Log.v(TAG, <span class="string">"onResume"</span>);
    }
    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPause</span><span class="params">()</span> </span>{
        <span class="keyword">super</span>.onPause();
        Log.v(TAG, <span class="string">"onPause"</span>);
    }
    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">()</span> </span>{
        <span class="keyword">super</span>.onStop();
        Log.v(TAG, <span class="string">"onStop"</span>);
    }
    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>{
        <span class="keyword">super</span>.onDestroy();
        Log.v(TAG, <span class="string">"onDestroy"</span>);
    }

}
</code></pre><p>我在各个周期方法了都加了日志信息，便于跟踪Activity的运行过程</p>
<ol>
<li>修改HelloWorld类，内容如下：</li>
</ol>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>{
    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String TAG=<span class="string">"HelloWorld"</span>;
    <span class="javadoc">/** Called when the activity is first created. */</span>
    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>{
        <span class="keyword">super</span>.onCreate(savedInstanceState);
        Log.v(TAG, <span class="string">"onCreate"</span>);
        setContentView(R.layout.main);
        <span class="comment">//打开第二个Activity的按钮</span>
        Button btnSecond=(Button)findViewById(R.id.second);
        <span class="comment">//设置单击事件</span>
        btnSecond.setOnClickListener(<span class="keyword">new</span> OnClickListener() {
            <span class="annotation">@Override</span>
            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>{
                startActivity(<span class="keyword">new</span> Intent(HelloWorld.<span class="keyword">this</span>,SecondActivity.class));
                finish();<span class="comment">//关闭当前Activity</span>
            }
        });
    }
    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>{
        <span class="keyword">super</span>.onStart();
        Log.v(TAG, <span class="string">"onStart"</span>);
    }
    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span> </span>{
        <span class="keyword">super</span>.onResume();
        Log.v(TAG, <span class="string">"onResume"</span>);
    }
    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPause</span><span class="params">()</span> </span>{
        <span class="keyword">super</span>.onPause();
        Log.v(TAG, <span class="string">"onPause"</span>);
    }
    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">()</span> </span>{
        <span class="keyword">super</span>.onStop();
        Log.v(TAG, <span class="string">"onStop"</span>);
    }
    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>{
        <span class="keyword">super</span>.onDestroy();
        Log.v(TAG, <span class="string">"onDestroy"</span>);
    }
}
</code></pre><ol>
<li>运行程序，分析结果，发现当程序启动的时候，日志信息为下图:<img src="http://dl.iteye.com/upload/attachment/349655/baddee2d-f46b-347d-b1f4-10b902def717.png" alt=""><br>由此可见当打开一个Activity的时候，其周期方法执行顺序为：onCreate()-&gt;onStart()-&gt;onResume(),现在点击“打开第二个Activity”按钮，看日志的输出如下图:</li>
</ol>
<p><img src="http://dl.iteye.com/upload/attachment/349660/2fcfc919-cae3-36a5-9536-0bae63cc0636.png" alt=""><br>当应用从Helloworld这个Activity启动SecondActivity的时候，Android会先执行HelloWorld的onPause方法，然后依次执行SecondActivity的onCreate()-&gt;onStart()-&gt;onResume()方法<br>当SecondActivity呈现到屏幕上的时候再一次执行Helloworld的onStop()-&gt;onDestroy(),把HelloWorld从Activity栈中移除销毁。这里值得提的就是HelloWorld 中finish方法，因为执行了他所以<br>HelloWorld才会从Activity栈中移除销毁，这样当你按“返回”键返回的时候就回不到HelloWorld 这个Activity的界面了，而是直接回到的Android的应用程序列表<br>。</p>
<h2 id="三：分析结果">三：分析结果</h2><p>根据上面例子可见一个Activity在启动的时候会执行onCreate()-&gt;onStart()-&gt;onResume()，在结束（或离开）的时候会执行onPause()-&gt;onStop()-&gt;onDestroy(),这就是一个Activity的生命周期。<br>因此我们要在onCreate方法里把Activity的需要的东西准备好，也就是初始化；在onResume里对Activity里的东西做一些调整；在onPause做一些清理和保存工作(保存持久状态),因为这是最后的<br>机会，因为onPause完成之前Android不会结束托管Activity类的进程，而之后进程可能被结束。总结一下这几个周期方法的作用：</p>
<ol>
<li>onCreate():创建Activity调用，用于Activity的初始化，还有个Bundle类型的参数，可以访问以前存储的状态。</li>
</ol>
<ol>
<li>onStart():Activity在屏幕上对用户可见时调用</li>
</ol>
<ol>
<li>onResume():Activity开始和用户交互的时候调用，这时该Activity是在Activity栈的顶部。</li>
</ol>
<ol>
<li>onPause():Activity被暂停时调用，也就是你要对你能看到的这个Activity说byebye的时候调用,这里可以做一些清理和保存工作</li>
</ol>
<ol>
<li>onStop():Activity被停止或者Activity变成不可见时调用</li>
</ol>
<ol>
<li>onDestroy():Activity被从内存中移除，一般发生在执行finish方法时或者Android回收内存的时候</li>
</ol>
<p>好了，最后让我们看一个API提供的Activity的状态图吧，看了他相信你对Activity的生命周期会更了解，如下图：</p>
<p><img src="http://dl.iteye.com/upload/attachment/349672/df78b0d1-8998-38ce-a5b7-95632d1192ac.png" alt=""></p>
<h2 id="四：小结">四：小结</h2><p>这节主要是通过一个例子分析Activity声明周期，并对常用生命周期方法做了一些说明，应该什么时候使用他们。到这里Android的很基础的东西已经说完了，<br>下面就直接Android的UI组件介绍了。。</p>
<p>下期预告：TextView的介绍—包含跑马灯效果</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>通过上一节“Android系列之四：Android项目的目录结构”我们已经知道了什么是Activity，那么为什么我们创建一个Activity的导出类的时候为什么都要覆盖Activity的onCreate方法呢，为什么会在onPause()方法中保存一些当前Activity]]>
    </summary>
    
      <category term="Android" scheme="http://www.flysnow.org/tags/Android/"/>
    
      <category term="Android" scheme="http://www.flysnow.org/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android项目的目录结构]]></title>
    <link href="http://www.flysnow.org/2010/11/16/android-project-directory-structure.html"/>
    <id>http://www.flysnow.org/2010/11/16/android-project-directory-structure.html</id>
    <published>2010-11-15T17:12:19.000Z</published>
    <updated>2016-05-22T10:14:57.290Z</updated>
    <content type="html"><![CDATA[<p>这两天家里晚上断网，不能晚上写了，请各位读官见谅。上一次我们使用ADT创建了一个Android的HelloWorld项目，并且介绍了模拟器以及模拟器的配置，这节就重点讲讲Android项目的目录结构，看看和我们常见的Java项目的目录结构有什么不同。</p>
<h2 id="一：Android项目的目录结构">一：Android项目的目录结构</h2><ol>
<li>Android项目结构概览。其实Android项目的目录结构和Java的差不多，没有太大变化，如下图：<br><img src="http://dl.iteye.com/upload/attachment/348966/4a17123a-21bf-335f-8d0a-3e81b69531b1.png" alt=""></li>
</ol>
<ol>
<li>可以看到src文件夹里的是源文件，Android2.2是引用的类库，这些和java的都一样，那么下面的这个gen是什么呢？这个里面的类就是ADT自动生成的啦，一般只有一个R.java文件，是不能修改的，那么他是怎么生成的呢，看到下面的res文件夹了吗？R.java就是根据资源文件夹res<br>生成的,R.java里放的就是res中资源文件索引，用一个常量标记res中的一个资源文件，便于我们在代码中引用。</li>
</ol>
<ol>
<li>现在让我们看看res文件夹，这下面又有几种类别，其中drawable是放图片的，有drawable-hdpi,drawable-ldpi,drawable-mdpi<br>之分，对应的是高密度图片，低密度图片，和中等密度的图片，如果你要使用一个图片，你根据密度的不同做了三种相同的图片分别放到这三个文件夹里，那么你的应用运行在不同分辨率机器上的时候，就会根据该机器的分辨率自动选择合适的图片，怎么样智能吧！下图是密度和手机尺寸对应关系表。<br><img src="http://dl.iteye.com/upload/attachment/348968/7e81aab5-3172-310d-a41f-8c68742225c0.png" alt=""><br>Layout中放的就是布局文件了，Android支持通过xml生成视图，这样视图就和逻辑控制的代码分离了便于管理。<br>Values中放的就是我们常用的字符串，颜色值，数组等<br>其实资源文件还有多种，这里生成的HelloWorld结构中没有，比如动画,菜单等。<br>接下来的这个AndroidManifest.xml很重要，每个Android项目都有一个，这是Android的配置文件，我们可以在这里配置应用的属性，定义<br>Activity，声明使用的权限等等，这里就不具体介绍，后面的章节会讲到default.properties也是一个配置文件。</li>
</ol>
<h2 id="二：Android项目文件的具体讲解">二：Android项目文件的具体讲解</h2><ol>
<li>首先看这个HelloWorld类。</li>
</ol>
<pre><code>public <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Activity</span> {</span>
    <span class="comment">/** Called when the activity is first created. */</span>
    <span class="annotation">@Override</span>
    public void onCreate(<span class="type">Bundle</span> savedInstanceState) {
        <span class="keyword">super</span>.onCreate(savedInstanceState);
        setContentView(<span class="type">R</span>.layout.main);
    }
}
</code></pre><p>他继承了Activity，前面讲了，一个Activity可以想象成一个手机的屏幕，用于展示一屏的内容，所以所有要展示内容的屏幕都要继承Activity才能实现，接着覆盖了onCreate()方法对该Activity进行初始化setContentView(R.layout.main);<br>设置了使用main.xml这个布局文件作为当前Activity的内容展示.main.xml就是放在res下，layout下面的文件xml布局文件,<br>我们可以直接使用R.layout.main进行直接的引用他，这也是Android亮点的地方，省得我们为了引用一个xml文件再使用File类去读取，我们要做的只是把这个xml文件的索引给Android，他会自动的帮我们找到它并使用.</p>
<ol>
<li>main.xml布局文件</li>
</ol>
<pre><code><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span>
<span class="tag">&lt;<span class="title">LinearLayout</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span>
    <span class="attribute">android:orientation</span>=<span class="value">"vertical"</span>
    <span class="attribute">android:layout_width</span>=<span class="value">"fill_parent"</span>
    <span class="attribute">android:layout_height</span>=<span class="value">"fill_parent"</span>
    &gt;</span>
<span class="tag">&lt;<span class="title">TextView</span>  
    <span class="attribute">android:layout_width</span>=<span class="value">"fill_parent"</span> 
    <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span> 
    <span class="attribute">android:text</span>=<span class="value">"@string/hello"</span>
    /&gt;</span>
<span class="tag">&lt;/<span class="title">LinearLayout</span>&gt;</span>
</code></pre><p>布局文件的内容不多,开始就是一个LinearLayout组件的定义，然后在这个LinearLayout放了一个用于显示文字的TextView。现在来看一下几个参数:</p>
<pre><code>* LinearLayout一个线性布局面板，只能垂直和水平布局，<span class="string">android:</span>orientation=<span class="string">"vertical"</span>代表里面的子元素只能垂直排列，而使用<span class="string">android:</span>orientation=<span class="string">"horizontal"</span>就标识里面的子元素水平排列..


* <span class="string">android:</span>layout_width定义当前视图占的宽度，这里是fill_parent即为充满整个屏幕。而设置成wrap_content会根据当前视图的大小只能的改变宽度


* <span class="string">android:</span>layout_height是定义视图的高度，这里也是填充整个屏幕。而设置成wrap_content会根据当前视图的大小只能的改变高度。


* <span class="string">android:</span>text是这是TextView要显示的文本，可以是字符串，也可以是一个字符串的引用，这里是一个引用，引用的是strings.xml定义好的名字为hello的字符串
</code></pre><ol>
<li>string.xml介绍。</li>
</ol>
<pre><code><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span>
<span class="tag">&lt;<span class="title">resources</span>&gt;</span>
    <span class="tag">&lt;<span class="title">string</span> <span class="attribute">name</span>=<span class="value">"hello"</span>&gt;</span>Hello World, HelloWorld!<span class="tag">&lt;/<span class="title">string</span>&gt;</span>
    <span class="tag">&lt;<span class="title">string</span> <span class="attribute">name</span>=<span class="value">"app_name"</span>&gt;</span>HelloWorld<span class="tag">&lt;/<span class="title">string</span>&gt;</span>
<span class="tag">&lt;/<span class="title">resources</span>&gt;</span>
</code></pre><p>这里我们看看就明白了，只要是定义一个个的K-V的键值对，供其他地方使用。比如上面的main中对hello的引用。这对字符的统一管理和国际化有很大的意义。</p>
<ol>
<li>AndroidManifest.xml的介绍</li>
</ol>
<pre><code><span class="tag">&lt;<span class="title">manifest</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span>
      <span class="attribute">package</span>=<span class="value">"com.flysnow"</span>
      <span class="attribute">android:versionCode</span>=<span class="value">"1"</span>
      <span class="attribute">android:versionName</span>=<span class="value">"1.0"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">application</span> <span class="attribute">android:icon</span>=<span class="value">"@drawable/icon"</span> <span class="attribute">android:label</span>=<span class="value">"@string/app_name"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">activity</span> <span class="attribute">android:name</span>=<span class="value">".HelloWorld"</span>
                  <span class="attribute">android:label</span>=<span class="value">"@string/app_name"</span>&gt;</span>
            <span class="tag">&lt;<span class="title">intent-filter</span>&gt;</span>
                <span class="tag">&lt;<span class="title">action</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.action.MAIN"</span> /&gt;</span>
                <span class="tag">&lt;<span class="title">category</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.category.LAUNCHER"</span> /&gt;</span>
            <span class="tag">&lt;/<span class="title">intent-filter</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">activity</span>&gt;</span>

    <span class="tag">&lt;/<span class="title">application</span>&gt;</span>
    <span class="tag">&lt;<span class="title">uses-sdk</span> <span class="attribute">android:minSdkVersion</span>=<span class="value">"8"</span> /&gt;</span>

<span class="tag">&lt;/<span class="title">manifest</span>&gt;</span>
</code></pre><p>这是项目的重要配置文件，诸如Activity，权限，Intent等都在这里配置</p>
<pre><code><span class="keyword">*</span> Package:定义了该应用的包。


<span class="keyword">*</span> android:versioCode定义了应用的版本号


<span class="keyword">*</span> android:versionName定义了应用的版本名字


<span class="keyword">*</span> application标签定义了一个应用，一个项目最多有一个Application标签。


<span class="keyword">*</span> android:icon=<span class="string">"@drawable/icon"</span>定义了应用的图标引用资源文件中的icon图片


<span class="keyword">*</span> android:label=<span class="string">"@string/app_name"</span>定义了应用的名称


<span class="keyword">*</span> activity标签定义了一个Activity，你的每一个Activity必须在这里定义，否则不能运行.


<span class="keyword">*</span> Android:name定义了Activity的类名,这里的.HelloWorld是以上面的Package定义为基础的，也就是Package(com.flysnow)加上这个android:name(.HelloWorld)要能定位到这个Activity(com.flysnow.HelloWorld)，否则就是找不到.


<span class="keyword">*</span> android:label定义了该Activity的标题


<span class="keyword">*</span> intent-filter定义一个Intent过滤器，用于标记对应的Activity，以便Android系统能找到该Activity，定义的是隐性的Intent，主要使用两个子标签action和category来区分每个Intent.
</code></pre><p>最后的 <uses-sdk android:minsdkversion="_"8"_"> 就是定义应用的最低 SDK 的级别</uses-sdk></p>
<p>三：小结</p>
<p>为了把Android项目的各个部分说清楚，啰嗦的多了一点，希望个为看官耐心看完.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这两天家里晚上断网，不能晚上写了，请各位读官见谅。上一次我们使用ADT创建了一个Android的HelloWorld项目，并且介绍了模拟器以及模拟器的配置，这节就重点讲讲Android项目的目录结构，看看和我们常见的Java项目的目录结构有什么不同。</p>
<h2 id=]]>
    </summary>
    
      <category term="Android" scheme="http://www.flysnow.org/tags/Android/"/>
    
      <category term="Android" scheme="http://www.flysnow.org/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[第一个Android应用，HelloWorld]]></title>
    <link href="http://www.flysnow.org/2010/11/13/android-helloworld.html"/>
    <id>http://www.flysnow.org/2010/11/13/android-helloworld.html</id>
    <published>2010-11-13T06:01:04.000Z</published>
    <updated>2016-05-22T10:14:57.286Z</updated>
    <content type="html"><![CDATA[<p>这节主要内容是使用ADT创建一个Helloword实例，并进行概要分析，中间会有AVD的创建。</p>
<h2 id="一：使用ADT创建Helloword应用">一：使用ADT创建Helloword应用</h2><p>使用ADT我们能很方便的创建一个Android的Helloworld应用，关于ADT的配置请看<a href="/2010/11/11/setup-android-for-window.html">
</a></p>
<p><a href="/2010/11/11/setup-android-for-window.html">Window下搭建开发平台</a></p>
<p>这里只讲ADT创建Android应用，关于CMD下的ant方式请看Android开发手册。</p>
<ol>
<li>打开Eclipse工具，新建一个项目-&gt;Others-&gt;Android-&gt;Android Project然后点击Next进入下一步.<br><img src="http://dl.iteye.com/upload/attachment/347774/45909298-5921-3eb6-a1dd-71012dd3408b.png" alt=""></li>
</ol>
<ol>
<li>在Project name中输入Helloword，Build Target的列表里选择Android2.2，在Application name输入应用的名字Helloworld ，然后在Package name输入你的应用的包名com.flysnow.helloworld,Create Activity里输入HelloWorld，min SDK输入8.这里我们不创建测试工程，点击finsh就完成了项目的创建。<br><img src="http://dl.iteye.com/upload/attachment/347776/e4946ab1-4525-37fe-b86a-92e9fdb96ac8.png" alt=""></li>
</ol>
<p><img src="http://dl.iteye.com/upload/attachment/347778/d7b19fac-77e5-37d4-8774-709cdbde2f6d.png" alt=""></p>
<ol>
<li><img src="http://dl.iteye.com/upload/attachment/347780/703b6595-7366-35a5-89ac-46253c495361.png" alt=""><br>Activity是Android的主要元素，你可以把Activity理解为一个手机屏幕界面，一个Android应用是有多个Activity组成的，也就是多个界面。min SDK Version就是你的应用最低运行在什么API等级的手机上。Android的API有7个等级。下面是API等级和Android版本对应列表<br><img src="http://dl.iteye.com/upload/attachment/347782/dcac6a13-c363-3aef-b729-01a03c1b256f.png" alt=""></li>
</ol>
<h2 id="二：创建AVD">二：创建AVD</h2><p>一个Android要想运行起来必须要有一个环境，这个环境就是模拟器。使用 AVD manager可以轻松的创建一个AVD（配置好的模拟器）。</p>
<ol>
<li>单击Eclipse工具栏上的AVD Manager图标打开AVD Manager</li>
</ol>
<p><img src="http://dl.iteye.com/upload/attachment/347786/22416f00-c704-34e5-ace0-98a5402f381b.png" alt=""></p>
<ol>
<li>点击右侧的“New”按钮打开创建AVD界面。在Name输入一个AVD的名字，这里使用Android2.2以注明是使用的是2.2版本的SDK，好的命名容易区分。Target出选择Android 2.2-API 8接着创建一个100M的SD卡，用于以后装一些注入音乐视频之类的文件。，最后就是在Skin选择皮肤了，就是你打算让你的模拟器长社么样，这里使用默认的就好，然后点击Create AVD就创建了一个AVD，这会有一段时间（特别是SD卡大的时候），之间最好别有任何操作，等会就好。<br><img src="http://dl.iteye.com/upload/attachment/347793/0c9c139a-29fe-37dd-ac98-d1d57142489b.png" alt=""></li>
</ol>
<h2 id="三：运行Helloword应用">三：运行Helloword应用</h2><p>有个AVD我们就可以运行Android应用了。找到我们的Helloword的项目，右击选择“Run”，选择Android Application 就可以运行Helloword应用了，这个过程有点长，稍等一下就可以看到模拟器的界面了。。好了让我们看看多么漂亮。<br><img src="http://dl.iteye.com/upload/attachment/347795/1a3fcead-cd37-3058-89b0-4204de13f585.png" alt=""></p>
<p>有的读官说了怎么还看不到我们自己的Helloword应用运行的效果啊，这是应为我们的模拟器还处于锁定状态，我们都知道手机都可以加键盘锁的，有的是按通话键打开，有的是按星号打开，但是我们的Android模拟器是滑动打开的，让我们用鼠标左键按住屏幕上的“锁”图标，然后向右滑动，然后松开鼠标，ok，打开了，很绚丽吧，等一会就看到我们的Helloword应用的效果了。<br><img src="http://dl.iteye.com/upload/attachment/347799/291df35a-46b6-3909-ab4b-c0a2f1bbe353.png" alt=""></p>
<h2 id="四：Android_模拟器的一些设置和小技巧">四：Android 模拟器的一些设置和小技巧</h2><ol>
<li>更改模拟器语言为中文。模拟器默认是英文的，我们需要设置成中文，这样看着才方便。我们可以通过Android的语言设置达到这个目的。在模拟器的菜单中找到Setting，然后向下滚动找到Language&amp;keyboard单击。<br><img src="http://dl.iteye.com/upload/attachment/347801/15c5b93e-d8ca-3df3-9040-ae41af1c3a47.png" alt=""><br>然后在打开的界面的最上面的找到Select Language单击，然后打开一个语言选择列表，找到中文(简体)选择就ok了。。你的模拟器就变成中文的啦。。<br><img src="http://dl.iteye.com/upload/attachment/347803/a30de346-b74a-3b45-92e7-365039647e74.png" alt=""></li>
</ol>
<ol>
<li>有人说我设置成中文后，在输入文字的地方怎么不能输入中文啊。其实这是因为模拟器默认的输入法是Android 键盘。模拟器自带的有谷歌输入法，我们只要选择谷歌输入法就可以输入中文了。在你输入文字的文本框处长按鼠标，会弹出一个“编辑文字”的弹出框，<br><img src="http://dl.iteye.com/upload/attachment/347805/0e7db327-c2c0-3cee-87b6-b902b18add26.png" alt=""><br>选择输入法，就可以看到输入法列表了，有“Android 键盘，谷歌输入法”，还有一个日本的输入法。<br><img src="http://dl.iteye.com/upload/attachment/347808/6bbe06c4-6b5d-34df-a1a6-7cf69b6a5d57.png" alt=""><br>我们选择“谷歌输入法”即可。。这时候可以输入中文啦。。</li>
</ol>
<ol>
<li>由于模拟器每次启动都比较慢，我们可以在打开模拟器之后不要再关闭，这样每次运行Android应用 ADT就会自动使用这个模拟器，这样就不用每次都启动了。。</li>
</ol>
<ol>
<li>Min SDK Version和模拟器。还记得我们创建Helloworld应用时最后输入的Min SDK Version吗？我们输入的是8，这个数字代表我们这个应用只能运行在Android SDk版本为2.2的机器上。这个Min SDK Version和模拟器也有关系的，如果你的机器上有多个模拟器，且每个Android SDK版本的模拟器都有，那么当你运行应用的时候，ADT就会根据Min SDK Version的值选择相应版本的模拟器。加入你的Min SDK Version是3，而且你已经创建了Android1.5的模拟器，那么你运行应用的时候，ADT就会打开Android版本的那个模拟器。。方便我们测试，智能吧。。</li>
</ol>
<h2 id="五：小结">五：小结</h2><p>这一节主要讲的就是怎么创建一个最简单的Android应用，并且对模拟器的创建和一些设置、常用的技巧做了一些介绍，目的就是尽量的熟悉ADT的创建和模拟器的使用。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这节主要内容是使用ADT创建一个Helloword实例，并进行概要分析，中间会有AVD的创建。</p>
<h2 id="一：使用ADT创建Helloword应用">一：使用ADT创建Helloword应用</h2><p>使用ADT我们能很方便的创建一个Android的Hel]]>
    </summary>
    
      <category term="Android" scheme="http://www.flysnow.org/tags/Android/"/>
    
      <category term="Android" scheme="http://www.flysnow.org/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Linux下搭建Android开发环境]]></title>
    <link href="http://www.flysnow.org/2010/11/12/android-setup-config-for-linux.html"/>
    <id>http://www.flysnow.org/2010/11/12/android-setup-config-for-linux.html</id>
    <published>2010-11-12T01:26:54.000Z</published>
    <updated>2016-05-22T10:14:57.286Z</updated>
    <content type="html"><![CDATA[<p>上一次说到在window下搭建Android开发环境，总体比较简单。这一次就说说在Linux搭建Android开发环境，这里主要以很流行的Ubuntu 操作系统为例，其他的大同小异。</p>
<h2 id="一：准备工作">一：准备工作</h2><pre><code>其实准备工作和上一篇的window下搭建的差不多，这里不再进行说明，请参见[<span class="link_label">Window下搭建Android开发环境</span>](<span class="link_url">/2010/11/11/setup-android-for-window.html</span>)
</code></pre><p>需要注意的是JDK以及Eclipse要下载Linux版本的.</p>
<h2 id="二：JDK配置">二：JDK配置</h2><p>JDK的配置网上说的很多了，但是还是有些人配置了之后不起作用，这里我再详细说一下，这里以我的JDK再/usr/locallib/目下下为例，如果你想把你的JDK也放到该目录下，那么使用 sudo cp<br>命令拷贝即可。</p>
<ol>
<li>首先要修改权限。在shell下执行 sudo chmod +x jdk-6u20-linux-i586.bin<br>,修改完权限后使用ls查看会发现JDK变成绿色的拉，这就ok了，见下图：<br><img src="http://dl.iteye.com/upload/attachment/347394/19f38961-b4b7-3727-a526-1f3aae01e107.jpg" alt=""></li>
</ol>
<ol>
<li>然后就可以安装了，执行sudo ./jdk-6u20-linux-i586.bin<br>就开始安装JDK了，遇到协议和同意协议的时候回车或者输入Y回车即可。</li>
</ol>
<ol>
<li>安装好后我们就可以开始配置环境变量了。执行 sudo gedit /etc/profile 打开配置文件在文件尾部加入以下文本：</li>
</ol>
<pre><code><span class="constant">JAVA_HOME</span>=<span class="regexp">/usr/local</span><span class="regexp">/lib/jdk</span>1.<span class="number">6.0_20</span>
<span class="constant">JRE_HOME</span>=<span class="regexp">/usr/local</span><span class="regexp">/lib/jdk</span>1.<span class="number">6.0_20</span>/jre
<span class="constant">CLASSPATH</span>=.<span class="symbol">:</span><span class="variable">$JAVA_HOME</span>/<span class="symbol">lib:</span><span class="variable">$JRE_HOME</span>/lib
<span class="constant">PATH</span>=<span class="variable">$PATH</span><span class="symbol">:</span><span class="variable">$JAVA_HOME</span>/<span class="symbol">bin:</span>/home/flysnow/bin
export <span class="constant">PATH</span> <span class="constant">JAVA_HOME</span>  <span class="constant">JRE_HOME</span> <span class="constant">CLASSPATH</span>
</code></pre><p>保存关闭。。但是这个时候我们输入javac还是会报错的，因为这个配置必须重启才能生效。重启后输入java -version就可以看到版本信息了。</p>
<p><img src="http://dl.iteye.com/upload/attachment/347404/f74708b5-b16b-34e9-b9b7-d818bc82bf8a.jpg" alt=""></p>
<ol>
<li>JDK安装的最后以下补充。有的时候我们输入java -version 显示并不是Java HotSpot（TM）Client VM，而是其他的诸如Open JDK 什么的,这是因为你机器里默认安装的有其他的JDK，那么我们怎么才能让我们自己的JDK设置成默认的呢。其实很简单，只需要执行以下命令即可。</li>
</ol>
<pre><code>update-alternatives --install <span class="regexp">/usr/</span>bin<span class="regexp">/java java /</span>usr<span class="regexp">/local/</span>lib<span class="regexp">/jdk1.6.0_20/</span>bin/java <span class="number">500</span>
update-alternatives --install <span class="regexp">/usr/</span>bin<span class="regexp">/javac javac /</span>usr<span class="regexp">/local/</span>lib<span class="regexp">/jdk1.6.0_20/</span>bin/javac <span class="number">500</span>
</code></pre><p>上面的命令是将我们安装的jdk加入java选单。然后接着执行</p>
<pre><code><span class="operator"><span class="keyword">update</span>-alternatives <span class="comment">--config java</span></span>
</code></pre><p>这是为系统选择默认的JDK，也就是我们的。这时候你再执行Java -version就会看到使用的是你自己的JDK了。 注：以及均基于JDK目录在/usr/local/lib下，读官们可以根据自己的实际情况而定.</p>
<h2 id="三：Android_SDK配置">三：Android SDK配置</h2><p>SDK 的配置和JDK大同小异，比JDK的配置更加简单。这里以SDK目录在~/Dev/Frame/Android下为例进行配置。</p>
<ol>
<li>首先你已经解压了sdk 目录。然后使用<br>sudo gedit /etc/profile<br>打开配置文件，加入android后的配置文件应该是如下这样的： </li>
</ol>
<pre><code> JAVA_HOME=<span class="regexp">/usr/</span>local<span class="regexp">/lib/</span>jdk1<span class="number">.6</span><span class="number">.0</span>_20
ANDROID_HOME=<span class="regexp">/home/</span>flysnow<span class="regexp">/Dev/</span>Frame<span class="regexp">/Android/</span>android-sdk
JRE_HOME=<span class="regexp">/usr/</span>local<span class="regexp">/lib/</span>jdk1<span class="number">.6</span><span class="number">.0</span>_20/jre
CLASSPATH=.:$JAVA_HOME<span class="regexp">/lib:$JRE_HOME/</span>lib
PATH=<span class="string">$PATH:</span>$JAVA_HOME<span class="regexp">/bin:/</span>home<span class="regexp">/flysnow/</span><span class="string">bin:</span>$ANDROID_HOME/tools
export PATH JAVA_HOME ANDROID_HOME JRE_HOME CLASSPATH
</code></pre><p>读官们可以参考的修改自己的。然后保存重启，sdk就配置好了。</p>
<h2 id="四：Eclipse的安装_ADT的安装_SDK的API，DOC的下载">四：Eclipse的安装 ADT的安装 SDK的API，DOC的下载</h2><p>这些和Window下一样，可以参考<br><a href="/2010/11/11/setup-android-for-window.html">Window下搭建Android开发环境</a></p>
<h2 id="五：小结">五：小结</h2><p>linux下和window的配置步骤基本上一样，都是下载软件，配置环境变量等，linux下的难点还是对于shell命令的掌握以及对于环境变量的配置，说白了还是对于linux系统掌握的程度，是否能熟练使用？也就是linux的基本功。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>上一次说到在window下搭建Android开发环境，总体比较简单。这一次就说说在Linux搭建Android开发环境，这里主要以很流行的Ubuntu 操作系统为例，其他的大同小异。</p>
<h2 id="一：准备工作">一：准备工作</h2><pre><code>其实准]]>
    </summary>
    
      <category term="Android" scheme="http://www.flysnow.org/tags/Android/"/>
    
      <category term="Android" scheme="http://www.flysnow.org/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Window下搭建Android开发环境]]></title>
    <link href="http://www.flysnow.org/2010/11/11/setup-android-for-window.html"/>
    <id>http://www.flysnow.org/2010/11/11/setup-android-for-window.html</id>
    <published>2010-11-10T22:41:25.000Z</published>
    <updated>2016-05-22T10:14:57.286Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>自2007年Google发布Android后，Android是越来越火，甚至有超越IPhone的势头。Android的推出，对于我们java开发人员无疑是一件值得庆幸的事情，因为Android的应用是由java开发的，因此，我们java开发人员入门Android比其他语言开发者有很大的优势。本系列教程将有浅到深系统的学习Android，这是我学习的过程，相信也会对你们有所帮助。该系列教程尽量保证每日一更。</p>
</blockquote>
<h3 id="一：准备工作">一：准备工作</h3><ol>
<li>JDK1.6.0_13 下载地址<a href="http://java.sun.com/products/archive/index.html" target="_blank" rel="external">http://java.sun.com/products/archive/index.html</a></li>
<li>Eclipse3.5.2 下载地址<a href="http://www.eclipse.org/downloads/packages/release/galileo/sr2" target="_blank" rel="external">http://www.eclipse.org/downloads/packages/release/galileo/sr2</a></li>
<li>Android SDK2.2 下载地址<a href="http://developer.android.com/index.html" target="_blank" rel="external">http://developer.android.com/index.html</a></li>
<li>ADT0.9.9 下载地址<a href="http://developer.android.com/sdk/installing/installing-adt.html" target="_blank" rel="external">http://developer.android.com/sdk/installing/installing-adt.html</a></li>
<li>有一定的java基础</li>
<li><h3 id="二：环境配置">二：环境配置</h3></li>
</ol>
<ul>
<li>JDk配置略，不会可以参考网上，很多帖子</li>
<li>SDK Setup启动和设置。下载好Android SDK后，解压放到一个你常用的目录下，然后运行SDK Setup.exe将启动Android SDK and AVD Manager。这里打开后会常遇到的一个问题是“Failed to fetch URL…”，这是因为默认是使用的HTTPS的方式，我们改成HTTP方式就行了。。选择左边窗口的Settings，选中Forece Https://……即可。</li>
</ul>
<p><img src="/uploads/2013/10/7c61ddbf-2da7-3b62-ba2a-2bcc1d9d1587-300x156.png" alt="android manager https下载方法"></p>
<ul>
<li>SDK版本下载。点击Available Packages 选择要安装的API版本以及SDK文档，然后点击“install selected”即可安装。等待一段时间就可以下载好SDK以及相应的文档了。。</li>
</ul>
<p><img src="/uploads/2013/10/7c61ddbf-2da7-3b62-ba2a-2bcc1d9d15871-300x218.png" alt="android sdk 选择"></p>
<ul>
<li>Android SDK配置。右击“我的电脑”，选择“属性”-“高级”-“环境变量”，新建系统变量,名称为“ANDROID_HOME”，值为你的Android SDK目录，我这里是“H:\Frame\android\android-sdk-windows”，然后把“%ANDROID_HOME%\tools”加入到PATH环境变量中，这时候你打开CMD输入android就可以看到Android SDK and AVD Manager了。</li>
</ul>
<p><img src="/uploads/2013/10/7c61ddbf-2da7-3b62-ba2a-2bcc1d9d15872-300x170.png" alt="配置环境变量"></p>
<ul>
<li>安装和配置ADT。ADT是一个Eclipse插件们用于开发Android应用程序。打开eclipse,安装ADT，在线安装地址为<a href="https://dl-ssl.google.com/android/eclipse/" target="_blank" rel="external">https://dl-ssl.google.com/android/eclipse/</a> ，也可以下载ADT压缩包安装。安装成功后重启Eclipse，然后选择Preferences-&gt;android-&gt;点击Browse..选择你的Android SDK所在目录，然后ok即可。</li>
</ul>
<p><img src="/uploads/2013/10/5afc0bd8-fe88-3770-a492-aded3c56f0fa-300x61.png" alt="配置adt"></p>
<h3 id="三：结束语">三：结束语</h3><p>到这里我们的开发环境就配置好了，因为我们有java开发基础，其实很简单，总结起来就三个步骤：</p>
<ol>
<li>下载JDK，Eclipse，SDK，ADT</li>
<li>配置JDK，SDK</li>
<li>配置ADT。。</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>自2007年Google发布Android后，Android是越来越火，甚至有超越IPhone的势头。Android的推出，对于我们java开发人员无疑是一件值得庆幸的事情，因为Android的应用是由java开发的，因此，我们java开发人员入门]]>
    </summary>
    
      <category term="Android" scheme="http://www.flysnow.org/tags/Android/"/>
    
      <category term="Android" scheme="http://www.flysnow.org/categories/Android/"/>
    
  </entry>
  
</feed>